enum QUALITY
{
    LOW_Q = 0, //CROSS
    MED_Q,
    HIGH_Q, 
    MAX_QUALITY    
};

enum VOLUMENUM
{
    VOLUME1, 
    VOLUME2, 
    VOLUME3, 
    VOLUME4,
    MAX_VOLUME
};

static void writeBinaryShader(const vlGLSLTechnique* tech, const char* binfileName)
{
    if(tech)
    {
        fprintf(stderr, "writebinary: %s\n", binfileName);
        tech ->writeBinary(binfileName);
    }
}

struct vrProfile
{
    float m_avg; //ms
    float m_max; //ms
    float m_min; 
    uint64_t m_totalFrame;
    uint64_t m_totalWorseFrame; 
    
    vrProfile()
    {
        m_avg = 0; 
        m_max = 0.f; 
        m_min = FLT_MAX; 
        m_totalFrame = 0; 
        m_totalWorseFrame = 0; 
    }
    
    void append(float ms)
    {
        m_max = std::max(ms, m_max); 
        m_min = std::min(ms, m_min); 
        double total = m_totalFrame * m_avg + ms; 
        m_avg = total/(m_totalFrame + 1); 
        
        if( ms > 0 && 25 * ms > 1)
            m_totalWorseFrame++;
        
        if(total > 0.95 * DBL_MAX)
        {
            m_totalFrame = 0; 
        }
        m_totalFrame++; 
    }
    
    void print()
    {
        fprintf(stderr, "average fps: %f, worst case: %f, ratio of bad frame: %f\n", 
                1/m_avg, 1/m_max, (double)m_totalWorseFrame/m_totalFrame); 
        
        clear(); 
    }
    
    void clear()
    {
        m_avg = 0; 
        m_max = 0.f; 
        m_min = FLT_MAX; 
        m_totalFrame = 0; 
        m_totalWorseFrame = 0; 
    }
    
};

//this class could be re-implemented as a scenenode and be managed by sceneManager
class VolumeRayCasterAlgorithmImp 
{
public: 
    VolumeRayCasterAlgorithmImp( 
        VolumeRayCasterAlgorithm* instance, 
        VolumeOctreeConfig* defOctreeCfg, 
        VolumeRenderConfig* defVolRendCfg): 
        myInstance(instance),  
        myFboDirty(true),
        mySVOFboDirty(true),
        mySamplerDirty(true), 
        myShaderInitialized(false), 
        m_primDirty(true),
        m_bbMin( Vect3f(0, 0, 0)), 
        m_bbMax( Vect3f(1,1,1)), 
        myOctreeVol(NULL), 
        myNodeBuffer(NULL),
        myNodeBufferSize(0),
        myNumBrickBufferSlots(0),
        myNumBrickUploadBufferSlots(0),
        myNodeBufferGL(0), 
        myOctreeNodeInfos(NULL), 
        myBrickUsageBufferGL(0), 
        myBrickVolTextureGL(0),  
        myRayBufferDim( Vect2i(0) ),
        myBrickUsageBuffer(NULL),
        myNodeBufferInvalid(true), 
        myBrickBufferInvalid(true), 
        myVoxelPickInvalid(true), 
        myRenderState( RENDER_STATE_FIRST_INTERACTION_FRAME ), 
        myDownsampledRenderSize(Vect2i(-1, -1)), 
        myRenderParamsUniformBlockBuffer(0), 
        myOctreeParamsUniformBlockBuffer(0),
        myMaskParamsUniformBlockBuffer(0), 
        myBufferUsageUniformBlockBuffer(0),
        myVolOctreeConfig(defOctreeCfg), 
        myVolRenderConfig(defVolRendCfg), 
        myBrickUpdateBufferGL(0), 
        myBrickUpdateAddressGL(0),
        myCurrentGLSyncRangeIndex(0),
        myGLSyncWaitTime(0),
        myPersistentBufferUsageMapPtr(NULL), 
        myPersistentGLNodeBufferPtr(NULL), 
        myPersistentPickVoxelBufferPtr(NULL),
        myFirstFrame(false), 
        myJitterInitialized(false), 
        myExtraVolumeTransferFunctionDirty(true), 
        myVoxelPickBuffer(NULL), 
        myJitteringTexture(0),
        vertexBufferName(0), 
        elementBufferName(0), 
        vertexBufferNameROI(0), 
        elementBufferNameROI(0),
        vertexArrayName(0), 
        vertexArrayNameROI(0), 
        myGridTexture3D(0),
        myDummyPointsVboId(0), 
        myDummyPointsVaoId(0), 
        myEnvelopeVboId(0),
        myEnvelopeVaoId(0), 
        myEnvelopeIsDirty(true),
        myZNearCanIntersectVolume(false) , 
        myCubeCreated(false)
        ,myShowCubeBackSides(false)
        , myOctreeRayCasterDVRTechnique(NULL)
        , myOctreeRayCasterGradTechnique(NULL)
        , myOctreeRayCasterMipTechnique(NULL) 
        , myOctreeRayCasterMopTechnique(NULL)
        , myOctreeRayCasterIsosurfaceTechnique(NULL) 
        , myOctreeRayCasterTSurfTechnique(NULL)
        , myComputeEnvelopeTechnique(NULL)
        , mySinglePassDepthBoundTechnique(NULL)
        , myDrawEnvelopeTechnique(NULL)
        , myFullScreenCopyComputeTechnique(NULL)
        , myFullScreenCopyBasicTechnique(NULL)
        , myDrawWellLogZPassTechnique(NULL)
        , myChenEdgeDetectionTechnique(NULL)
        , mySobelEdgeDetectionTechnique(NULL)
        , myAmbientOcclusionTechnique(NULL)
        , mySSAOBlurTechnique(NULL)
        , myUseAOBlurPass(true)
        , myFullScreenFBOCopyTechnique(NULL)
        , myFullScreenCopyTex2dTechnique(NULL)
        , myRenderSlateBaseTechnique(NULL)
        , myRenderTraverseSlateBaseTechnique(NULL)
        , myTimeQueryInited(false)
        , myOutputPerformance(false)
        , myGeomDirty(true)
        , myActiveVolumeDirty(true)
        , myExtraVolumeDirty(true)
        , myIsRGBAMode(false)
    { 
        myMVPMatrix.identity();
        myMVMatrixInverse.identity(); 
        myMVPMatrixInverse.identity(); 
        myProjMatrixInverse.identity(); 
        myCameraEyePosition = Vect3f(0.0f); 
        myTransFuncTextureArray = 0; 
        myOpacitySATTextureArray = 0; 
        myExtraTransFuncTexture = 0;  
        myVolumeTex2WorldMatrix.identity(); 
        myCameraPos = Vect3f(0.0f, 0.0f, 0.0f); 
        myProjectionMatrix.identity(); 
        
        memset(myRayCasterColorDepthTextureArray, 0, sizeof(GLuint) * MAX_MIPMAP_LEVELS);
        memset(myRayBufferGL, 0, sizeof(GLuint) * MAX_MIPMAP_LEVELS); 
        memset(myIntermiateFBO, 0, sizeof(GLuint) * MAX_MIPMAP_LEVELS);
        memset(myIntermiateEdgeTexture, 0, sizeof(GLuint) * MAX_MIPMAP_LEVELS);
        memset(mySSAOFBO, 0, sizeof(GLuint) * MAX_MIPMAP_LEVELS);
        memset(mySSAOBlurredFBO, 0, sizeof(GLuint) * MAX_MIPMAP_LEVELS);
        memset(mySSAOTexture, 0, sizeof(GLuint) * MAX_MIPMAP_LEVELS);
        memset(mySSAOBlurredTexture, 0, sizeof(GLuint) * MAX_MIPMAP_LEVELS);   
         
     
        memset( myOctreeRayCasterDVRFragTechnique, 0, sizeof(vlOctreeRayCasterDVRFragTechnique*) *MAX_QUALITY*MAX_VOLUME); 
        memset( myOctreeRayCasterDVRRGBAFragTechnique, 0, sizeof(vlOctreeRayCasterDVRFragTechnique*) *MAX_QUALITY*MAX_VOLUME); 
        memset( myOctreeRayCasterIsosurfaceFragTechnique, 0, sizeof(vlOctreeRayCasterIsosurfaceFragTechnique*) *MAX_QUALITY*MAX_VOLUME); 
        memset( myOctreeRayCasterGradFragTechnique, 0, sizeof(vlOctreeRayCasterGradFragTechnique*) *MAX_QUALITY*MAX_VOLUME); 
        memset( myOctreeRayCasterMipFragTechnique, 0, sizeof(vlOctreeRayCasterMipFragTechnique*) * MAX_VOLUME); 
        memset( myOctreeRayCasterMopFragTechnique, 0, sizeof(vlOctreeRayCasterMopFragTechnique*) * MAX_VOLUME);   
        memset( myOctreeRayCasterMinIntProjFragTechnique, 0, sizeof(vlOctreeRayCasterMipFragTechnique*) * MAX_VOLUME);  
        memset( myOctreeRayCasterAipFragTechnique, 0, sizeof(vlOctreeRayCasterMipFragTechnique*) * MAX_VOLUME);  
        memset( myOctreeRayCasterSipFragTechnique, 0, sizeof(vlOctreeRayCasterMipFragTechnique*) * MAX_VOLUME);  
        memset( myUpdateBrickTexturePoolTechnique, 0, sizeof(vlUpdateBrickTexturePoolTechnique*) * MAX_VOLUME);  
        
        myDataRangeSeismic = Vect2f( -1, -1); 
        myDataRangeAttribute = Vect2f( -1, -1); 

        myTfRangeSeismic = Vect2f( -1, -1 ); 
        myTfRangeAttribute = Vect2f( -1, -1 ); 

        //checkMaskCorrectness(); 
        resetRenderState();
        myOutputRenderSize = Vect2i( -1, -1); 
        memset(myClippingHrzTex2D, 0, sizeof(GLuint) * 2); 
    }

    ~VolumeRayCasterAlgorithmImp()
    {
        reset();
    }

    void reset();
    
    void updateBoundingBoxRange( Vect3f min, Vect3f max); 
    
    bool exportBinaryShader(); 
    bool initShader(); 
    bool initTimeQueries(); 
    bool initBuffer(); 
    bool initVertexArray(); 
    bool initRenderTargets();
    bool initSVORenderTargets(); 
    bool initGLSampler(); 
    
    bool checkError( const char* title); 
    //
    bool initOctreeNodeBuffer(); 
    bool initOctreeBrickBuffer();
    bool initUniformBuffer(); 
    bool initVoxelPickBuffer(); 
    
    void updateOctreeBrickUsage();
    size_t updateOctreeBrickPools(size_t lodNodeLevel); //return bricks uploaded 
    void updateRenderState( const size_t& brickUploaded, RenderState& curState,
                            RenderState& nextState, DisplayMode& displayMode); 
    
    void preRenderTornadoOpaque();
    
    void postRenderTornadoOpaque(); 
    
    void psuedoVsgAdpRefinement(timeval t); 
    
    void inVoxelRender(timeval t); 
    
    void postRenderEdgeDetection(const int currentReduction); 
    void combineCurrentRefinement(const int currentReduction); 
    
    void imageSpacePostProcessing(const int currentReduction); 
    //render to AO fbo
    void imageSpaceAO(const int currentReduction); 

    void renderBasicSlicePreZPass(OrthoSliceRenderable* node); 
    void renderBasicSliceShadingPass(OrthoSliceRenderable* node); 
    
    void renderCurvedFenceSlicePreZPass(CurvedSliceRenderable* node); 
    void renderCurvedFenceSliceShadingPass(CurvedSliceRenderable* node) ; 
     
    bool isEarlyDiscardFromRenderingLoop( ); 
    uint64_t createOctreeNodeBufferEntry( bool homogeous, bool inPool, size_t childPointer, size_t brickAddress, const uint16_t* avgValues, 
            size_t numChannels); 
    void extractOctreeNodeValues( const uint64_t nodeEntry, bool& inPool, bool& homogeous, size_t& childPointer, uint16_t& avgValue, 
            size_t& brickPointer ); 
    
    void updateOctreeNodeChildPointer( uint64_t& nodeEntry, size_t childPointer ); 
    size_t getOctreeNodeChildPointer( uint64_t& nodeEntry ) const ; 
    
    void updateOctreeNodeBrickPointer( uint64_t& nodeEntry, bool hasBrick, size_t brickPointer, const uint16_t* avgValues, size_t numChannels); 
    size_t getOctreeNodeBrickPointer( uint64_t& nodeEntry ) const ; 
     
    void updateOctreeBrickBuffer( int keepLevel, size_t& numUsed, size_t& numRequested, size_t& numUploaded, size_t& slotOccupied ); 
    void analyzeOctreeBrickUsageBuffer( size_t& numTraversed, size_t& numUsed, size_t& numRequested ) const ; 
    void clearOctreeBrickUsageBuffer( size_t numNodes, bool clearTraversed, GLuint currGLSyncIndex ); 
    
    void clearVoxelPickBuffer(); 
    //computer shader version, obsolete
    //void renderFrame( DisplayMode displayMode, float sampleingStepSize, size_t nodeLevel, bool useBricks , GLuint currGLSyncIndex, bool renderTrg = false); 
    void renderFrameFS( const int screenResolutionReduction,  
                        size_t nodeLevel, 
                        float sampleingStepSize, 
                        bool isLinearFilter, 
                        bool isAdaptiveSampling, 
                        bool isCubicSpline, 
                        bool isHardwareSampling, 
                        bool isUseLighting, 
                        bool isUseJittering, 
                        int gradientQuality, 
                        DisplayMode displayMode, 
                        bool useBricks, 
                        GLuint currGLSyncIndex); 

    void rescaleRenderingFS(); 
    
    
    void invalidateNodeBuffer(); 
    void invalidateBrickBuffer(); 
    void invalidateVoxelPickBuffer(); 
    void invalidateExtraVolTransferFunction(); 
    void resetRenderState();
    void clearIntermiateTexture(); 
    void compareOctreeNodeToBuffer( const vlSparseVolumeOctreeNode* node, size_t nodeOffset ) ; 
   
    //node usage 
    bool hasOctreeNodeBrick( uint64_t& nodeEntry) const;
    
    //brick usage 
    bool hasOctreeBrickBeenUsed( const uint8_t flagEntry ) const; 
    uint8_t setOctreeBrickUsed( const uint8_t flagEntry, const bool used ); 
    bool hasOctreeNodeBeenTraversed( const uint8_t flagEntry ) const ; 
    uint8_t setOctreeNodeTraversed( const uint8_t flagEntry, const bool traversed ); 
    bool isOctreeBrickRequested( const uint8_t flagEntry ) const ; 
    uint8_t setOctreeBrickRequested( const uint8_t flagEntry, const bool requested ); 
    
    bool isOctreeNodeHomogeneous(const uint64_t& nodeEntry) const; 
    
    bool waitGLBuffer(GLsync& syncObj); 
    void lockGLBuffer(GLsync& syncObj);     
    //
    //void spectrum2array( Spectrum& spectrum, float*& array, float*& opacitySAT); 
    
    GLuint &getTransferFunctionTextureArray( ) ; 
    GLuint &getExtraTransferFunctionTexture(); 
    GLuint &getOpacitySATArray() ; 
    
    GLuint &getJitteringTexture(); 
    bool initJitteringTexture(); 
    
    //object-space empty skipping 
   // void computeGridTexture(Volume* torVolCh1, Volume* torVolCh2); // seismic mode: seismic, attribute mode: attribute, co-render: both
   
    void initializeGridDimension(); 
    void initializeGridBuffer(); 
   
    void computeEnvelope(); 
    void invalidateStreamSliceTexture(); 
  
    
    void renderDualDepthPeel(); 
    void renderEnvelopeBrick(); 
    
    void createCube(); 
    void drawCube(); 
    void drawEnvelope(); 
    
    
    
    void updateBasicSliceNodeImp(int id, int type, Vect4d bgn, Vect4d end, float* texure, Vect2i texSize, bool visibility, 
             bool isShowSeis, bool isShowAttr);
    
    void updateTraverseSliceNodeImp(int id, int type, Vect4d bgn, Vect4d end, float* texure, Vect2i texSize, bool visibility, 
             bool isShowSeis, bool isShowAttr);    
    
    void updateFenceSliceNodeImp(int setid, int id, int type, Vect4d bgn, Vect4d end, float* texure, Vect2i texSize, bool visibility, 
             bool isShowSeis, bool isShowAttr);  
    
    void updateCurrentFenceSetImp( int curSetId );
    
    void updateCurvedFenceSliceNodeImp(int id, int type, vector<Vect4d>& pts, vector<float*>& traces, 
                                        double zOrig, double zStep, int numZSamples, Matrixd l2g, 
                                        bool visibility, bool isShowSeis, bool isShowAttr); 
    
    void deleteTraverseSliceNodeImp(int id); 
    void deleteFenceSliceNodeImp(int setId); 
    void deleteCurvedFenceSliceNodeImp(int id); 
    
    void logVolRendProfile(); 
    
    VolumeRayCasterAlgorithm *myInstance;
    vlSparseVolumeOctreeBase* myOctreeVol; 
    VolumeOctreeConfig* myVolOctreeConfig;
    VolumeRenderConfig* myVolRenderConfig; 
    
    bool myShaderInitialized; 
    //RoiBox in region of interest option
    Vect3f m_bbMin;
    Vect3f m_bbMax; 
    //proxy geometry, bounding box for ray casting (unit cube)
    bool m_primDirty; 
    
    //mapping range for transfer function (seismic) 
    Vect2f myTfRangeSeismic;
    //mapping range for transfer function (attribute) 
    Vect2f myTfRangeAttribute; 
    //data range for transfer function (seismic) 
    Vect2f myDataRangeSeismic; 
    //data range for transfer function (attribute) 
    Vect2f myDataRangeAttribute;
    //mapping range for transfer function (extra volume: def. of extra volume, please see ) 
    Vect2f myTfRangeExtraVol; 
    //data range for transfer function (extra volume: def. of extra volume, please see ) 
    Vect2f myDataRangeExtraVol;
    
    //original proxy bounding box for raycasting: vertex buffer + element buffer(aka index buffer + vertexarrayobject
    GLuint vertexBufferName; 
    GLuint elementBufferName; 
    GLuint vertexArrayName; 
    
    //roi proxy bounding box for raycasting: vertex buffer + element buffer(aka index buffer + vertexarrayobject
    GLuint vertexBufferNameROI; 
    GLuint elementBufferNameROI; 
    GLuint vertexArrayNameROI; 
    
    //model view projection matrix
    Matrixf myMVPMatrix; 
    //model view inverse
    Matrixf myMVMatrixInverse; 
    //inverse matrix of model view projection matrix
    Matrixf myMVPMatrixInverse; 
    //inverse of projection matrix
    Matrixf myProjMatrixInverse; 

#ifdef USE_DOUBLEPRECISION    
    //tornado has very large scale and translation, which will cause precision issue. 
    Matrixd myMVPMatrixd; 
#endif
    //emulate camera eye position
    Vect3f myCameraEyePosition; 
    // emulate light source position
    Vect3f myLightPosition; 
    
    //ray casting's entry texture and exit texture. Combined as a texture array(size 2), first layer is entry texture, second layer is exit texture). 
    RenderTargetTextureArrayWrapper myEntryExitBound; 
    // a 1d texture array for storing transfer function(size 2))
    GLuint myTransFuncTextureArray; 
    // a 1d texture array for SAT(summed area table) transfer function(size 2)): this is for empty-space-skipping step
    GLuint myOpacitySATTextureArray; 
    // 1d texture for transfer function for extra volume
    GLuint myExtraTransFuncTexture; 
    // window size
    int myWidth; 
    int myHeight; 
    
    // after resize, fbo will be dirty
    bool myFboDirty; 
    bool mySVOFboDirty; 
    bool mySamplerDirty; 

    //octree node count
    size_t myNodeBufferSize;
    //octree node pool, indexed. 
    uint64_t* myNodeBuffer;  
    //octree node buffer mapped in GL
    GLuint myNodeBufferGL; 
    //high level abstraction, for octree node pool, talk with svo manager
    OctreeNodeInfo* myOctreeNodeInfos; 
    // octree node usage pool, same size as myNodeBuffer
    uint8_t* myBrickUsageBuffer; // 0->255, a ram map to usage of each buffer
    
    //a brick buffer can contain multiple bricks or single brick, its size ( uint16), because address is by uint16
    //size of buffer occupied in vram
    size_t myBrickBufferSize; 
    size_t myNumBrickBufferSlots; // maximal size of bricks that can occupy vram 
    //min(myBrickBufferSize, vram budget). each frame
    size_t myBrickUploadBufferSize;  // 
    size_t myNumBrickUploadBufferSlots; // each frame how many bricks can be uploaded through vram bus
    
    //a big 3d texture to hold all bricks. 
    GLuint myBrickVolTextureGL; 
    //persistent mapping for brick usage buffer in GL
    GLuint myBrickUsageBufferGL; 
    
    //ray buffer is a buffer that hold intermediate ray casting result. provide a way to do "raycaster, pause and continue" fashion. 
    GLuint myRayBufferGL[MAX_MIPMAP_LEVELS]; 
    
    //a buffer to record cursor feed back information and later on reads back to main memory
    GLuint myVoxelPickGL; //shaderStorageBuffer
    VoxelInfo* myVoxelPickBuffer; 
    Vect2i myRayBufferDim; 
    
    //each depth of octree, there is a LRU cache. provide a way to do swap 
    std::vector< std::list<LRUBrick> > myLRUBricks; // vector: level octree bricks, List , each time add new node at the head, o(1)
    
    //flag to invalidate octree node pool. ex: rebuild a new volume
    bool myNodeBufferInvalid; 
    //flag to invalidate octree brick pool. ex: rebuild a new volume
    bool myBrickBufferInvalid; 
    bool myVoxelPickInvalid; 
    
    //
    Matrixf myVolumeTex2WorldMatrix; 
    Vect3f myCameraPos; 
    Matrixf myProjectionMatrix; 
    Vect2i myOutputRenderSize; 
    
    RenderState myRenderState; 
    Timer myRefinementTimer; //first refinment frame to finish
    
    Vect2i myDownsampledRenderSize; 

    //MultiRenderTarget
    //1. texture2DArray as a carrier. layer1: color, layer2: depth for all mipmap levels
    //2. myIntermiateEdgeTexture as a stencil buffer. 
    GLuint myRayCasterColorDepthTextureArray[MAX_MIPMAP_LEVELS]; 
    //3. fbo object as a indicator for texture2DArray and stencil texture
    GLuint myIntermiateFBO[MAX_MIPMAP_LEVELS]; 
    GLuint myIntermiateEdgeTexture[MAX_MIPMAP_LEVELS];
    
    //ScreenSpace Ambient Occlusion. 
    //1. ssao fbo and texture
    //2. gaussian blurred fbo and texture
    GLuint mySSAOFBO[MAX_MIPMAP_LEVELS]; 
    GLuint mySSAOBlurredFBO[MAX_MIPMAP_LEVELS]; 
    GLuint mySSAOTexture[MAX_MIPMAP_LEVELS]; 
    GLuint mySSAOBlurredTexture[MAX_MIPMAP_LEVELS]; 
    
    //Uniform buffer for raycaster
    GLuint myRenderParamsUniformBlockBuffer; 
    GLuint myOctreeParamsUniformBlockBuffer; 
    GLuint myMaskParamsUniformBlockBuffer; 
    GLuint myBufferUsageUniformBlockBuffer; 
    
//    GLint myOctreeParamsUniform; 
//    GLint myMaskParamsUniform; 
//    GLint myBufferUsageUniform; 
    
    // Buffer for brick streaming in computer shader
    // 1. Buffer which has the content
    GLuint myBrickUpdateBufferGL;
    // 2. Address buffer which tells where to write
    GLuint myBrickUpdateAddressGL;
    
    // A mannual GL sync object for Octree Brick Usage buffer, it is a 3x size for lower driver overhead
    GLSyncRange myGLSyncRange[MAX_SYNC_BUFFER_COUNT]; 
    // specify the GLSyncRange of current frame. 
    GLuint myCurrentGLSyncRangeIndex;  
    // for debugging gl sync purpose
    GLuint myGLSyncWaitTime; 
    
    // A mannuall GL sync object to control the all slice read/write order, avoid rw hazard. 
    GLsync myGLSync_TSBufferData; 
    
    // persistent pointer for octree usage buffer, octree node buffer and pick voxel buffer. New feature after GL4.5. Low driver overhead
    void* myPersistentBufferUsageMapPtr; 
    void* myPersistentGLNodeBufferPtr; 
    void* myPersistentPickVoxelBufferPtr;
    bool myFirstFrame; 
    
    bool myJitterInitialized; 
    
    bool myExtraVolumeTransferFunctionDirty; 
    
    // Texture2D object for top/bottom clipping horizon texture. 
    GLuint myClippingHrzTex2D[2]; 
    // Texture2D object for jittering texture. 
    GLuint myJitteringTexture; 
    
    //begin of empty space skipping
    //
    GLuint myGridTexture3D; 
    Vect3i myGridDim; 
    Vect3i myVoxelsPerCell; 
    Vect3f myMaxGridPos; 
    uint maxGridDim; 
    uint maxVolumeDim; 
    GLuint myDummyPointsVboId; //dummy
    GLuint myDummyPointsVaoId; 
    GLuint myEnvelopeVboId; 
    GLuint myEnvelopeVaoId; 
    bool myEnvelopeIsDirty ; 
    GLuint myEnvelopeNumTriangles; 
    GLuint myMaxEnvelopeNumTriangles;    
    bool myZNearCanIntersectVolume;     
    
    //end of empty space skipping
    // render target for single pass depth bound (entry/exit) algorithm
    RenderTargetTextureWrapper mySinglePassDepthRT; 
    
    //Cube related
    bool myCubeCreated; 
    int myNumCubeIndices; 
    GLuint myCubeVaoId;  
    GLuint myCubeVerticesVboId; 
    GLuint myCubeIndicesVboId; //packed one 
      
    bool myShowCubeBackSides;     
    Vect3f myViewVolume; 

    bool myIsShowSeis; 
    bool myIsShowAttr; 
    
    Vect3f myCurrentSliceCube; 
    Vect3i myCurrentRefGeomSize; 

    //shader wrapper
    vlUpdateBrickTexturePoolTechnique* myUpdateBrickTexturePoolTechnique[MAX_VOLUME]; 
    vlOctreeRayCasterDVRTechnique* myOctreeRayCasterDVRTechnique; 
    vlOctreeRayCasterGradTechnique* myOctreeRayCasterGradTechnique; 
    vlOctreeRayCasterMipTechnique* myOctreeRayCasterMipTechnique; 
    vlOctreeRayCasterMopTechnique* myOctreeRayCasterMopTechnique; 
    vlOctreeRayCasterIsosurfaceTechnique* myOctreeRayCasterIsosurfaceTechnique; 
    vlOctreeRayCasterTSurfTechnique* myOctreeRayCasterTSurfTechnique; 
    vlComputeEnvelopeTechnique* myComputeEnvelopeTechnique; 
    vlSinglePassDepthBoundTechnique* mySinglePassDepthBoundTechnique; 
    vlDrawEnvelopeTechnique* myDrawEnvelopeTechnique; 
    vlOctreeRayCasterDVRFragTechnique* myOctreeRayCasterDVRFragTechnique[MAX_VOLUME][MAX_QUALITY];
    vlOctreeRayCasterDVRFragTechnique* myOctreeRayCasterDVRRGBAFragTechnique[MAX_VOLUME][MAX_QUALITY];
    vlFullScreenCopyComputeTechnique* myFullScreenCopyComputeTechnique; 
    vlFullScreenCopyBasicTechnique* myFullScreenCopyBasicTechnique;
    vlFullScreenCopyTex2dTechnique* myFullScreenCopyTex2dTechnique; 
    vlFullScreenFBOCopyTechnique* myFullScreenFBOCopyTechnique; 
    
    vlRenderSlateBaseTechnique* myRenderSlateBaseTechnique; 
    vlRenderTraverseSlateTechnique* myRenderTraverseSlateBaseTechnique; 
    vlOctreeRayCasterIsosurfaceFragTechnique* myOctreeRayCasterIsosurfaceFragTechnique[MAX_VOLUME][MAX_QUALITY];
    vlOctreeRayCasterMipFragTechnique* myOctreeRayCasterMipFragTechnique[MAX_VOLUME]; //maximal intensity projection
    vlOctreeRayCasterMopFragTechnique* myOctreeRayCasterMopFragTechnique[MAX_VOLUME]; 
    vlOctreeRayCasterMipFragTechnique* myOctreeRayCasterMinIntProjFragTechnique[MAX_VOLUME]; //Minimal Intensity Projection
    vlOctreeRayCasterMipFragTechnique* myOctreeRayCasterAipFragTechnique[MAX_VOLUME]; //Average Intensity Projection
    vlOctreeRayCasterMipFragTechnique* myOctreeRayCasterSipFragTechnique[MAX_VOLUME]; //Sum Intensity Projection
    vlOctreeRayCasterGradFragTechnique* myOctreeRayCasterGradFragTechnique[MAX_VOLUME][MAX_QUALITY]; 
    
    //sampler Object, nearest/linear for fragment shader implementation only
    //Not much difference visually, don't know why
    GLuint myNearestSampler; 
    GLuint myLinearSampler; 
    
    //shader uniform updated each frame if necessary
    RayCasterConfigMapping myRayCasterConfig; 
    VisualConfigMapping myVisualConfig; 
    HorizonClippingConfigMapping myHrzClipConfig; 
    RoiClippingConfigMapping myRoiClipConfig; 
    VoxelPickConfigMapping myVoxelPickConfig; 
    ShadingConifgMapping myShadingConfig; 
    StateConfigMapping myStateConfig; 
    GainControlConfigMapping myGainControlConfig; 
    IsosurfaceConfigMapping myIsosurfaceConfig; 
     
    //volume rendering material 
    vlVolumeRenderingQuality myVolumeRenderingQuality; 
    vlDrawWellLogTechnique* myDrawWellLogZPassTechnique; 
    vlChenEdgeDetectionTechnique* myChenEdgeDetectionTechnique; 
    vlSobelEdgeDetectionTechnique* mySobelEdgeDetectionTechnique; 
    vlAmbientOcclusionTechnique* myAmbientOcclusionTechnique; 
    vlSSAOBlurTechnique* mySSAOBlurTechnique; 
    bool myUseAOBlurPass; 
      
    map<vString, const vlGLSLTechnique*> myGLSLTechHash; 
    
    //GPU Time Query Object
    GLuint myTimeQueries[3]; 
    GLuint64 preVoxelRenderTime; 
    GLuint64 inVoxelRenderTime; 
    GLuint64 postVoxelRenderTime; 
    bool myTimeQueryInited;
    bool myOutputPerformance;  
    vrProfile myVRProfile; 
    
    //LATEST PARAMETER FROM TORNADO
    bool myGeomDirty; 
    bool myActiveVolumeDirty; 
    bool myExtraVolumeDirty; 
    
    //Three geometry needs to be updated all the time
    //reference geometry, active volume geometry and extra volume geometry
    Vect3f myGeomOrigin;
    Vect3i myGeomSize; 
    Vect3f myGeomStep; 
    Vect3f myActiveVolumeOrigin; 
    Vect3i myActiveVolumeSize; 
    Vect3f myActiveVolumeStep; 
    Vect3f myExtraVolumeOrigin;
    Vect3i myExtraVolumeSize; 
    Vect3f myExtraVolumeStep; 
    
    //top/bottom clipping horizon geometry
    Vect3f myHrzOrigin[2];
    Vect3i myHrzSize[2]; 
    Vect3f myHrzStep[2]; 
    
    //for seismic gain control, seismic gain control has been obsolete now
    int mySeisGainType; 
    Vect4f myLinearDivergenceParams; 
    float mySrate; 
    Vect2f myDepthExtent; 
    
    //specify if volume rendering is under RGBA mode
    bool myIsRGBAMode; 
};

void VolumeRayCasterAlgorithmImp::reset()
{ 
    //delete gl sampler object
    vlGLExt::glDeleteSamplers(1, &myNearestSampler); 
    vlGLExt::glDeleteSamplers(1, &myLinearSampler);
    
    //
    vlGLExt::glDeleteFramebuffersEXT(2, &myEntryExitBound.fboHandle[0]); 
    vlGLExt::glDeleteTextures(1, &myEntryExitBound.textureArray); 
    vlGLExt::glDeleteTextures(1, &myEntryExitBound.depthTexArray); 
    vlGLExt::glDeleteTextures(1, &myTransFuncTextureArray); 
    vlGLExt::glDeleteTextures(1, &myOpacitySATTextureArray); 
    vlGLExt::glDeleteTextures(1, &myExtraTransFuncTexture);
    vlGLExt::glDeleteBuffers(1, &vertexBufferName);
    vlGLExt::glDeleteBuffers(1, &elementBufferName);   
    vlGLExt::glDeleteVertexArrays(1, &vertexArrayName);
    vlGLExt::glDeleteBuffers(1, &vertexBufferNameROI);
    vlGLExt::glDeleteBuffers(1, &elementBufferNameROI);
    vlGLExt::glDeleteVertexArrays(1, &vertexArrayNameROI);
   
    
#ifdef USE_PERSISTENT_NODEBUFFER
    //unmap persistent mapped buffer before delete
    GLint isMapped; 
    vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, myNodeBufferGL); 
    vlGLExt::glGetBufferParameteriv(GL_SHADER_STORAGE_BUFFER, GL_BUFFER_MAPPED, &isMapped); 
    if(isMapped == GL_TRUE)
        vlGLExt::glUnmapBuffer( GL_SHADER_STORAGE_BUFFER );
    vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, 0); 
#endif    
    vlGLExt::glDeleteBuffers(1, &myNodeBufferGL); 
    vlGLExt::glDeleteTextures(1, &myBrickVolTextureGL); 
       
#ifdef USE_PERSISTENT_NODEBUFFER        
    vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, myBrickUsageBufferGL); 
    vlGLExt::glGetBufferParameteriv(GL_SHADER_STORAGE_BUFFER, GL_BUFFER_MAPPED, &isMapped); 
    if(isMapped == GL_TRUE)
    {
        vlGLExt::glUnmapBuffer( GL_SHADER_STORAGE_BUFFER );
    }
    vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, 0);
#endif 
    vlGLExt::glDeleteBuffers(1, &myBrickUsageBufferGL); 
    
#ifdef USE_PERSISTENT_NODEBUFFER
    vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, myVoxelPickGL); 
    vlGLExt::glGetBufferParameteriv(GL_SHADER_STORAGE_BUFFER, GL_BUFFER_MAPPED, &isMapped); 
    if(isMapped == GL_TRUE)
        vlGLExt::glUnmapBuffer( GL_SHADER_STORAGE_BUFFER );
    vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, 0);
#endif 
    vlGLExt::glDeleteBuffers(1, &myVoxelPickGL);
    
    vlGLExt::glDeleteBuffers(MAX_MIPMAP_LEVELS, &myRayBufferGL[0] ); 
    vlGLExt::glDeleteBuffers(1, &myBrickUpdateBufferGL); 
    vlGLExt::glDeleteBuffers(1, &myBrickUpdateAddressGL); 
    
    vlGLExt::glDeleteBuffers(1, &myRenderParamsUniformBlockBuffer); 
    vlGLExt::glDeleteBuffers(1, &myOctreeParamsUniformBlockBuffer); 
    vlGLExt::glDeleteBuffers(1, &myMaskParamsUniformBlockBuffer); 
    vlGLExt::glDeleteBuffers(1, &myBufferUsageUniformBlockBuffer);    
   
    vlGLExt::glDeleteTextures(MAX_MIPMAP_LEVELS, &myRayCasterColorDepthTextureArray[0] );
    vlGLExt::glDeleteTextures(MAX_MIPMAP_LEVELS, &myIntermiateEdgeTexture[0] );
    vlGLExt::glDeleteTextures(MAX_MIPMAP_LEVELS, &mySSAOTexture[0] ); 
    vlGLExt::glDeleteTextures(MAX_MIPMAP_LEVELS, &mySSAOBlurredTexture[0] ); 
    vlGLExt::glDeleteTextures(1, &myJitteringTexture ); 
    vlGLExt::glDeleteTextures(2, &myClippingHrzTex2D[0] ); 
    
    //empty space skipping
    vlGLExt::glDeleteBuffers(1, &myDummyPointsVboId);    
    vlGLExt::glDeleteVertexArrays(1, &myDummyPointsVaoId);
    vlGLExt::glDeleteBuffers(1, &myEnvelopeVboId); 
    vlGLExt::glDeleteVertexArrays(1, &myEnvelopeVaoId);
    vlGLExt::glDeleteFramebuffersEXT(1, &mySinglePassDepthRT.fboHandle); 
    vlGLExt::glDeleteTextures(1, &mySinglePassDepthRT.textureHandle); 
    vlGLExt::glDeleteTextures(1, &mySinglePassDepthRT.depthHandle); 
    vlGLExt::glDeleteVertexArrays(1, &myCubeVaoId);
    vlGLExt::glDeleteBuffers(1, &myCubeVerticesVboId);
    vlGLExt::glDeleteBuffers(1, &myCubeIndicesVboId);  
    
    //for fragment shader intermediate texture and framebuffer
    vlGLExt::glDeleteFramebuffersEXT(MAX_MIPMAP_LEVELS, &myIntermiateFBO[0]); 
    vlGLExt::glDeleteFramebuffersEXT(MAX_MIPMAP_LEVELS, &mySSAOFBO[0]); 
    vlGLExt::glDeleteFramebuffersEXT(MAX_MIPMAP_LEVELS, &mySSAOBlurredFBO[0]); 
    
    if( myNodeBuffer ){
        delete[] myNodeBuffer; 
        myNodeBuffer = 0; 
    }
    
    if( myOctreeNodeInfos )
    {
        delete[] myOctreeNodeInfos; 
        myOctreeNodeInfos = 0; 
    }
    
    if(myBrickUsageBuffer)
    {
        delete[] myBrickUsageBuffer; 
        myBrickUsageBuffer = 0; 
    }
    
    if(myVoxelPickBuffer)
    {
        delete myVoxelPickBuffer; 
        myVoxelPickBuffer = 0; 
    }
    
    if(myOctreeRayCasterDVRTechnique)
        delete myOctreeRayCasterDVRTechnique; 
    if(myOctreeRayCasterGradTechnique)
        delete myOctreeRayCasterGradTechnique;         
    if(myOctreeRayCasterMipTechnique)
        delete myOctreeRayCasterMipTechnique; 
    if(myOctreeRayCasterMopTechnique)
        delete myOctreeRayCasterMopTechnique; 
    if(myOctreeRayCasterIsosurfaceTechnique)
        delete myOctreeRayCasterIsosurfaceTechnique;
    if(myOctreeRayCasterTSurfTechnique)
        delete myOctreeRayCasterTSurfTechnique;
    if(myComputeEnvelopeTechnique)
        delete myComputeEnvelopeTechnique; 
    if(mySinglePassDepthBoundTechnique)
        delete mySinglePassDepthBoundTechnique;
    if(myDrawEnvelopeTechnique)
        delete myDrawEnvelopeTechnique; 
    
    for(int i = 0; i < MAX_VOLUME; i++)
    {
        for(int j = 0; j < MAX_QUALITY; j++)
        {
            if(myOctreeRayCasterDVRFragTechnique[i][j])
                delete myOctreeRayCasterDVRFragTechnique[i][j];
            if(myOctreeRayCasterDVRRGBAFragTechnique[i][j])
                delete myOctreeRayCasterDVRRGBAFragTechnique[i][j];
            if(myOctreeRayCasterIsosurfaceFragTechnique[i][j])
                delete myOctreeRayCasterIsosurfaceFragTechnique[i][j];    
            if(myOctreeRayCasterGradFragTechnique[i][j])
                delete myOctreeRayCasterGradFragTechnique[i][j]; 
            
        }
        if(myOctreeRayCasterMipFragTechnique[i])
            delete myOctreeRayCasterMipFragTechnique[i];
        if(myOctreeRayCasterMinIntProjFragTechnique[i])
            delete myOctreeRayCasterMinIntProjFragTechnique[i]; 
        if(myOctreeRayCasterMopFragTechnique[i])
            delete myOctreeRayCasterMopFragTechnique[i]; 
        if(myOctreeRayCasterAipFragTechnique[i])
            delete myOctreeRayCasterAipFragTechnique[i]; 
        if(myOctreeRayCasterSipFragTechnique[i])
            delete myOctreeRayCasterSipFragTechnique[i]; 
        if(myUpdateBrickTexturePoolTechnique[i])
            delete myUpdateBrickTexturePoolTechnique[i]; 
    }
  
    if(myFullScreenCopyComputeTechnique)
        delete myFullScreenCopyComputeTechnique; 
    if(myFullScreenCopyBasicTechnique)
        delete myFullScreenCopyBasicTechnique; 
    if(myFullScreenFBOCopyTechnique)
        delete myFullScreenFBOCopyTechnique; 
    if(myFullScreenCopyTex2dTechnique)
        delete myFullScreenCopyTex2dTechnique; 
    if(myRenderSlateBaseTechnique)
        delete myRenderSlateBaseTechnique; 
    if(myRenderTraverseSlateBaseTechnique)
        delete myRenderTraverseSlateBaseTechnique; 
    if(myDrawWellLogZPassTechnique)
        delete myDrawWellLogZPassTechnique; 
    if(myChenEdgeDetectionTechnique)
        delete myChenEdgeDetectionTechnique; 
    if(mySobelEdgeDetectionTechnique)
        delete mySobelEdgeDetectionTechnique;    
    if(myAmbientOcclusionTechnique)
        delete myAmbientOcclusionTechnique; 
    if(mySSAOBlurTechnique)
        delete mySSAOBlurTechnique; 
    
    //delete query
    vlGLExt::glDeleteQueries(3, this->myTimeQueries);
    //delete sync obj
    vlGLExt::glDeleteSync( myGLSync_TSBufferData ); 
}

bool VolumeRayCasterAlgorithmImp :: initBuffer()
{
    //checkError is for debugging purpose, to snap the gl error within function domain
    while(!checkError("before initBuffer"))
    {
        continue;
    }
    
    //some precision issue
    //GLfloat eps = 2 * 1e-3; 
    
    GLfloat eps = 0.0f; 
    static const GLfloat vertex_positions[]=
    {
//       0-eps, 0-eps, 0-eps,
//       0-eps, 1+eps, 0-eps, 
//       1+eps, 1+eps, 0-eps, 
//       1+eps, 0-eps, 0-eps, 
//       0-eps, 0-eps, 1+eps, 
//       0-eps, 1+eps, 1+eps, 
//       1+eps, 1+eps, 1+eps, 
//       1+eps, 0-eps, 1+eps,  
        0,0,0, 
        0,-1,0, 
        1,-1,0, 
        1,0,0, 
        0,0,1, 
        0,-1,1, 
        1,-1,1, 
        1,0,1,         
    }; 
    
    //24 triangle strip
    static const GLuint element_bb[] = 
    {
       //Front
       6, 7, 4, 
       6, 4, 5, 
       
       //back
       3, 2, 1,
       3, 1, 0, 
       
       //TOP
       3, 7, 2, 
       7, 6, 2, 
       //BOTTOWN 
       0, 1, 4, 
       1, 5, 4, 
       //LEFT
       3, 0, 7, 
       0, 4, 7, 
       //RIGHT, 
       2, 6, 1, 
       6, 5, 1,
    }; 
    if(vertexBufferName == 0)
        vlGLExt::glGenBuffers( 1, &vertexBufferName );
    vlGLExt::glBindBuffer( GL_ARRAY_BUFFER, vertexBufferName); 
    vlGLExt::glBufferData( GL_ARRAY_BUFFER, sizeof( vertex_positions), vertex_positions, GL_STATIC_DRAW ); 
    vlGLExt::glBindBuffer( GL_ARRAY_BUFFER, 0); 
    
    if(elementBufferName == 0)
        vlGLExt::glGenBuffers( 1, &elementBufferName );
    vlGLExt::glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, elementBufferName); 
    vlGLExt::glBufferData( GL_ELEMENT_ARRAY_BUFFER, sizeof( element_bb ), element_bb, GL_STATIC_DRAW ); 
    vlGLExt::glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0);   
    
    if(vertexBufferNameROI == 0)
        vlGLExt::glGenBuffers( 1, &vertexBufferNameROI );
    vlGLExt::glBindBuffer( GL_ARRAY_BUFFER, vertexBufferNameROI); 
    vlGLExt::glBufferData( GL_ARRAY_BUFFER, sizeof( vertex_positions), vertex_positions, GL_STATIC_DRAW ); 
    vlGLExt::glBindBuffer( GL_ARRAY_BUFFER, 0); 

    if(elementBufferNameROI == 0)
        vlGLExt::glGenBuffers( 1, &elementBufferNameROI );
    vlGLExt::glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, elementBufferNameROI); 
    vlGLExt::glBufferData( GL_ELEMENT_ARRAY_BUFFER, sizeof( element_bb ), element_bb, GL_STATIC_DRAW ); 
    vlGLExt::glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0);     
    
    static const GLuint sliceElement[] = 
    {   
       7, 4, 0, 
       7, 0, 3, 
       //3, 0, 7, 
       //0, 4, 7, 
       
       4, 5, 1, 
       4, 1, 0, 
       //0, 1, 4, 
       //1, 5, 4,   
       
       3, 2, 1,
       3, 1, 0, 
       
       //border start here
       7,4,0,3, 
       4,5,1,0,
       3,2,1,0,
    }; 
  
    return checkError("initBuffer");
}

bool VolumeRayCasterAlgorithmImp :: initVertexArray()
{
    while(!checkError("before initVertexArray"))
    {
        continue;
    }
    //vao for unit cube
    if(vertexArrayName == 0 )
        vlGLExt::glGenVertexArrays(1, &vertexArrayName); 
    vlGLExt::glBindVertexArray( vertexArrayName );
    vlGLExt::glBindBuffer(GL_ARRAY_BUFFER, vertexBufferName); 
    vlGLExt::glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, NULL); 
    vlGLExt::glBindBuffer(GL_ARRAY_BUFFER, 0); 
    
    vlGLExt::glEnableVertexAttribArray(0);  
    vlGLExt::glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, elementBufferName); 
    vlGLExt::glBindVertexArray( 0); 
    
    //vao for roi cube
    if(vertexArrayNameROI == 0)
        vlGLExt::glGenVertexArrays(1, &vertexArrayNameROI); 
    vlGLExt::glBindVertexArray( vertexArrayNameROI );
    vlGLExt::glBindBuffer(GL_ARRAY_BUFFER, vertexBufferNameROI); 
    vlGLExt::glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, NULL); 
    vlGLExt::glBindBuffer(GL_ARRAY_BUFFER, 0); 
    
    vlGLExt::glEnableVertexAttribArray(0);  
    vlGLExt::glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, elementBufferNameROI); 
    vlGLExt::glBindVertexArray( 0); 
   
    vlGLExt::glBindBuffer(GL_ARRAY_BUFFER, 0);    
    vlGLExt::glBindVertexArray( 0);      
    return checkError("initVertexArray");
}

bool VolumeRayCasterAlgorithmImp::initRenderTargets()
{
    //Entry and exit texture for empty space skipping step
    while(!checkError("before initRenderTargets for empty space skip"))
    {
        continue;
    }
    
    if(myEntryExitBound.textureArray == 0 )  
        vlGLExt::glGenTextures(1, &myEntryExitBound.textureArray); 
    
    glBindTexture( GL_TEXTURE_2D_ARRAY, myEntryExitBound.textureArray); 
    glTexParameteri( GL_TEXTURE_2D_ARRAY, GL_TEXTURE_BASE_LEVEL, 0); 
    glTexParameteri( GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAX_LEVEL, 0); 
    glTexParameteri( GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); 
    glTexParameteri( GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); 
    glTexParameteri( GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); 
    glTexParameteri( GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_LINEAR ); 
    glTexImage3D(GL_TEXTURE_2D_ARRAY, GLint(0), GL_RGBA32F, myWidth, myHeight, 2, 0, GL_RGBA, GL_FLOAT, NULL );
    
    if(myEntryExitBound.depthTexArray == 0 )
        vlGLExt::glGenTextures(1, &myEntryExitBound.depthTexArray); 
    
    glBindTexture( GL_TEXTURE_2D_ARRAY, myEntryExitBound.depthTexArray); 
    glTexParameteri( GL_TEXTURE_2D_ARRAY, GL_TEXTURE_BASE_LEVEL, 0); 
    glTexParameteri( GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAX_LEVEL, 0); 
    glTexParameteri( GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); 
    glTexParameteri( GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); 
    glTexParameteri( GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); 
    glTexParameteri( GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_LINEAR ); 
    glTexImage3D(GL_TEXTURE_2D_ARRAY, GLint(0), GL_DEPTH_COMPONENT32, myWidth, myHeight, 2, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL );
    
    if(myEntryExitBound.fboHandle[0] == 0 )
      vlGLExt::glGenFramebuffersEXT(2, &myEntryExitBound.fboHandle[0]); 
    
    vlGLExt::glBindFramebufferEXT(GL_FRAMEBUFFER, myEntryExitBound.fboHandle[0]);
    vlGLExt::glFramebufferTextureLayer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, myEntryExitBound.textureArray, 0, GLint(0) ); 
    vlGLExt::glFramebufferTextureLayer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, myEntryExitBound.depthTexArray, 0, GLint(0) ); 
    if(vlGLExt::glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE )
    {
        fprintf(stderr, "glCheckFramebufferStatus: Error 0\n"); 
    }
    vlGLExt::glBindFramebufferEXT(GL_FRAMEBUFFER, myEntryExitBound.fboHandle[1]);
    vlGLExt::glFramebufferTextureLayer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, myEntryExitBound.textureArray, 0, GLint(1) ); 
    vlGLExt::glFramebufferTextureLayer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, myEntryExitBound.depthTexArray, 0, GLint(1) ); 
    if(vlGLExt::glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE )
    {
        fprintf(stderr, "glCheckFramebufferStatus: Error 1\n"); 
    }
    
    vlGLExt::glBindFramebufferEXT(GL_FRAMEBUFFER, 0);
    glBindTexture( GL_TEXTURE_2D_ARRAY, 0); 
    
    if(mySinglePassDepthRT.fboHandle == 0 )
        vlGLExt::glGenFramebuffers(1, &mySinglePassDepthRT.fboHandle ); 
    
    vlGLExt::glDeleteTextures(1, &mySinglePassDepthRT.textureHandle); 
    mySinglePassDepthRT.textureHandle = 0; 
    if(mySinglePassDepthRT.textureHandle == 0 )  
        vlGLExt::glGenTextures(1, &mySinglePassDepthRT.textureHandle); 
    
    glBindTexture(GL_TEXTURE_2D, mySinglePassDepthRT.textureHandle); 
    //alpha channel is a mask
    GLenum internalformat = this ->myZNearCanIntersectVolume ? GL_RGBA32F : GL_RGB32F; 
    
    //alpha channel is a mask, 1 : 0, 
    GLenum format = this ->myZNearCanIntersectVolume ? GL_RGBA : GL_RGB; 
    //glTexImage2D(GL_TEXTURE_2D, GLint(0), internalformat,  myWidth, myHeight,0, format,  GL_FLOAT, NULL );
    vlGLExt::glTexStorage2D(GL_TEXTURE_2D, 1, internalformat, myWidth, myHeight); 
    vlGLExt::glBindFramebufferEXT(GL_DRAW_FRAMEBUFFER, mySinglePassDepthRT.fboHandle );
    vlGLExt::glFramebufferTexture2DEXT(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, mySinglePassDepthRT.textureHandle, 0); 
    if(vlGLExt::glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE )
    {
        fprintf(stderr, "mySinglePassDepthRT glCheckFramebufferStatus: Error\n"); 
    }
    vlGLExt::glBindFramebufferEXT(GL_FRAMEBUFFER, 0);
    glBindTexture(GL_TEXTURE_2D, 0); 

    return checkError("after initRenderTargets for empty space skip");
}

bool VolumeRayCasterAlgorithmImp::initGLSampler()
{
    while(!checkError("before initGLSampler"))
    {
        continue;
    }    
    
    vlGLExt::glGenSamplers(1, &myNearestSampler);
    
    vlGLExt::glSamplerParameteri(myNearestSampler, GL_TEXTURE_MIN_FILTER,  GL_NEAREST); 
    checkError("after GL_NEAREST_MIPMAP_NEAREST");
    vlGLExt::glSamplerParameteri(myNearestSampler, GL_TEXTURE_MAG_FILTER, GL_NEAREST); 
    vlGLExt::glSamplerParameteri(myNearestSampler, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    vlGLExt::glSamplerParameteri(myNearestSampler, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    vlGLExt::glSamplerParameteri(myNearestSampler, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
    const GLfloat boarderColor[4] = {0,0,0,0}; 
    vlGLExt::glSamplerParameterfv(myNearestSampler, GL_TEXTURE_BORDER_COLOR, &boarderColor[0] ); 
    //vlGLExt::glSamplerParameterf(myNearestSampler, GL_TEXTURE_MIN_LOD, -1000.f); 
    //vlGLExt::glSamplerParameterf(myNearestSampler, GL_TEXTURE_MAX_LOD, 1000.f);
    //vlGLExt::glSamplerParameterf(myNearestSampler, GL_TEXTURE_LOD_BIAS, 0.f);
    //vlGLExt::glSamplerParameterf(myNearestSampler, GL_TEXTURE_COMPARE_MODE, GL_NONE);
    //vlGLExt::glSamplerParameterf(myNearestSampler, GL_TEXTURE_COMPARE_FUNC, GL_LEQUAL);
    vlGLExt::glGenSamplers(1, &myLinearSampler);
    vlGLExt::glSamplerParameteri(myLinearSampler, GL_TEXTURE_MIN_FILTER, GL_LINEAR); 
    checkError("after GL_LINEAR_MIPMAP_LINEAR");
    vlGLExt::glSamplerParameteri(myLinearSampler, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 
    vlGLExt::glSamplerParameteri(myLinearSampler, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    vlGLExt::glSamplerParameteri(myLinearSampler, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    vlGLExt::glSamplerParameteri(myLinearSampler, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
    vlGLExt::glSamplerParameterfv(myLinearSampler, GL_TEXTURE_BORDER_COLOR, &boarderColor[0] ); 
 //   vlGLExt::glSamplerParameteri(myLinearSampler, GL_TEXTURE_MAX_ANISOTROPY_EXT, 16); 
    //vlGLExt::glSamplerParameterf(myLinearSampler, GL_TEXTURE_MIN_LOD, -1000.f); 
    //vlGLExt::glSamplerParameterf(myLinearSampler, GL_TEXTURE_MAX_LOD, 1000.f);
    //vlGLExt::glSamplerParameterf(myLinearSampler, GL_TEXTURE_LOD_BIAS, 0.f);
    //vlGLExt::glSamplerParameterf(myLinearSampler, GL_TEXTURE_COMPARE_MODE, GL_NONE);
    //vlGLExt::glSamplerParameterf(myLinearSampler, GL_TEXTURE_COMPARE_FUNC, GL_LEQUAL);     
    
    return checkError("after initGLSampler");
}

bool VolumeRayCasterAlgorithmImp::initSVORenderTargets()
{
    //render target for svo ray caster algorithm
//    myIntermiateFBO: intermediate-resolution frame buffer, 1/1, 1/2, 1/4, 1/8 for x,y dimension
//    mySSAOFBO: ssao frame buffer, 
//    mySSAOBlurredFBO: gaussian blurred ssao frame buffer.         
    while(!checkError("before initSVORenderTargets"))
    {
        continue;
    }
    
    //if(myRayCasterColorDepthTextureArray[0] == 0)
        vlGLExt::glGenTextures(MAX_MIPMAP_LEVELS, &myRayCasterColorDepthTextureArray[0]);  
    //if(myRayBufferGL[0] == 0)
        vlGLExt::glGenTextures(MAX_MIPMAP_LEVELS, &myRayBufferGL[0]);   
    //if(myIntermiateEdgeTexture[0] == 0)
        vlGLExt::glGenTextures(MAX_MIPMAP_LEVELS, &myIntermiateEdgeTexture[0]);   
    //if(mySSAOTexture == 0)
        vlGLExt::glGenTextures(MAX_MIPMAP_LEVELS, &mySSAOTexture[0]); 
    //if(mySSAOBlurredTexture == 0)
        vlGLExt::glGenTextures(MAX_MIPMAP_LEVELS, &mySSAOBlurredTexture[0]); 
    
    //if(myIntermiateFBO[0] == 0 )
        vlGLExt::glGenFramebuffersEXT(MAX_MIPMAP_LEVELS, &myIntermiateFBO[0]);
    
    //if(mySSAOFBO[0] == 0)
        vlGLExt::glGenFramebuffersEXT(MAX_MIPMAP_LEVELS, &mySSAOFBO[0]);
    //if(mySSAOBlurredFBO[0] == 0)
        vlGLExt::glGenFramebuffersEXT(MAX_MIPMAP_LEVELS, &mySSAOBlurredFBO[0]);
    
    GLenum fboStatus;
    for(size_t level = 0; level < MAX_MIPMAP_LEVELS; level++ )
    {
#ifdef POWER_REDUCTION
        GLuint coarsenessFactor = (GLuint)pow((double)2.f, (double)level);
#else 
        GLuint coarsenessFactor = level + 1; 
#endif
        Vect2i internalRenderSize( myWidth/coarsenessFactor, myHeight/coarsenessFactor ); 
        
        glBindTexture( GL_TEXTURE_2D_ARRAY, myRayCasterColorDepthTextureArray[level]);   
        glTexParameteri( GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); 
        glTexParameteri( GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); 
        glTexParameteri( GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); 
        glTexParameteri( GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_LINEAR ); 
        glTexParameteri( GL_TEXTURE_2D_ARRAY, GL_TEXTURE_BASE_LEVEL, 0 ); 
        glTexParameteri( GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAX_LEVEL, 0 );
        vlGLExt::glTexStorage3D( GL_TEXTURE_2D_ARRAY, GLint(1), GL_RGBA32F, internalRenderSize[0], internalRenderSize[1], 2); 
        glBindTexture( GL_TEXTURE_2D_ARRAY, 0);
        
        //play as stencil buffer
        glBindTexture( GL_TEXTURE_2D, myIntermiateEdgeTexture[level]);   
        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0 ); 
        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0 );
        //1 or 0 , used by stencil later one
        vlGLExt::glTexStorage2D(GL_TEXTURE_2D, GLint(1), GL_STENCIL_INDEX8, internalRenderSize[0], internalRenderSize[1]);
        glBindTexture( GL_TEXTURE_2D, 0);
        
        vlGLExt::glBindFramebufferEXT(GL_FRAMEBUFFER, myIntermiateFBO[level]);  
        vlGLExt::glFramebufferTextureLayer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, myRayCasterColorDepthTextureArray[level], 0, GLint(0) ); 
        vlGLExt::glFramebufferTextureLayer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, myRayCasterColorDepthTextureArray[level], 0, GLint(1) ); 
        vlGLExt::glFramebufferTexture2D(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_TEXTURE_2D, myIntermiateEdgeTexture[level], 0); 
        
        fboStatus = vlGLExt::glCheckFramebufferStatus(GL_FRAMEBUFFER); 
        
        if(fboStatus != GL_FRAMEBUFFER_COMPLETE )
        {
            switch(fboStatus)
            {
                case GL_FRAMEBUFFER_UNDEFINED: 
                    fprintf(stderr, "GL_FRAMEBUFFER_UNDEFINED glCheckFramebufferStatus: Error\n"); 
                    break; 
                case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    fprintf(stderr, "GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT glCheckFramebufferStatus: Error\n"); 
                    break; 
                case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    fprintf(stderr, "GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT glCheckFramebufferStatus: Error\n"); 
                    break; 
                case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER:
                    fprintf(stderr, "GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER glCheckFramebufferStatus: Error\n"); 
                    break; 
                case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER:
                    fprintf(stderr, "GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER glCheckFramebufferStatus: Error\n"); 
                    break; 
                case GL_FRAMEBUFFER_UNSUPPORTED: 
                    fprintf(stderr, "GL_FRAMEBUFFER_UNSUPPORTED glCheckFramebufferStatus: Error\n"); 
                    break; 
                case GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:
                    fprintf(stderr, "GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE glCheckFramebufferStatus: Error\n"); 
                    break; 
                case GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS:
                    fprintf(stderr, "GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS glCheckFramebufferStatus: Error\n"); 
                    break ;              
            }
        }
        vlGLExt::glBindFramebufferEXT(GL_FRAMEBUFFER, 0);
        
        size_t bufferByteSize = internalRenderSize[0] * internalRenderSize[1] * RAYINFO_LENGTH * sizeof(float); 
        vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, myRayBufferGL[level]);  
        vlGLExt::glBufferStorage(GL_SHADER_STORAGE_BUFFER, bufferByteSize, NULL, GL_MAP_READ_BIT );
        vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, 0);   
        
        glBindTexture( GL_TEXTURE_2D, mySSAOTexture[level]);   
        vlGLExt::glTexStorage2D(GL_TEXTURE_2D, GLint(1), GL_RGBA32F,  internalRenderSize[0], internalRenderSize[1]);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR ); 
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); 
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0 ); 
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0); 
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE ); 
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
        vlGLExt::glBindFramebufferEXT(GL_FRAMEBUFFER, mySSAOFBO[level]);  
        vlGLExt::glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, mySSAOTexture[level], 0);  
        fboStatus = vlGLExt::glCheckFramebufferStatus(GL_FRAMEBUFFER); 
        if(fboStatus != GL_FRAMEBUFFER_COMPLETE )
        {
            return false; 
        }
        glBindTexture( GL_TEXTURE_2D, mySSAOBlurredTexture[level]);   
        //glTexImage2D(GL_TEXTURE_2D, GLint(0), GL_RGBA32F,  internalRenderSize[0], internalRenderSize[1], 0, GL_RGBA,  GL_FLOAT, NULL );
        vlGLExt::glTexStorage2D(GL_TEXTURE_2D, GLint(1), GL_RGBA32F,  internalRenderSize[0], internalRenderSize[1]);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR ); 
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); 
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0 ); 
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0); 
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE ); 
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
        vlGLExt::glBindFramebufferEXT(GL_FRAMEBUFFER, mySSAOBlurredFBO[level]);  
        vlGLExt::glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, mySSAOBlurredTexture[level], 0);  
        fboStatus = vlGLExt::glCheckFramebufferStatus(GL_FRAMEBUFFER); 
        if(fboStatus != GL_FRAMEBUFFER_COMPLETE )
        {
            return false; 
        }
        glBindTexture( GL_TEXTURE_2D, 0);   
        vlGLExt::glBindFramebufferEXT(GL_FRAMEBUFFER, 0); 
    }
    return checkError("initSVORenderTargets");
}

bool VolumeRayCasterAlgorithmImp::initTimeQueries()
{
    while(!checkError("before initTimeQueries"))
    {
        continue;
    }    
    assert(this->myTimeQueryInited == false); 
    vlGLExt::glGenQueries(3, this->myTimeQueries); 
    
    return checkError("initTimeQueries");
}

bool VolumeRayCasterAlgorithmImp::exportBinaryShader()
{
  for(map<vString, const vlGLSLTechnique*>::const_iterator itr = myGLSLTechHash.begin() ; 
            itr != myGLSLTechHash.end(); itr++)
  {
      writeBinaryShader(itr->second, itr->first.c_str()); 
  }
  
  return true; 
}

bool VolumeRayCasterAlgorithmImp::initShader()
{
    while(!checkError("before initShader"))
    {
        continue;
    }
    
    myGLSLTechHash.clear(); 
    
    GLContext* ctx = GLContext::getCurrent();
    GLint formats = 0; 
      
//#ifdef USE_BINARY_SHADER_FILE    
//    myUpdateBrickTexturePoolCS = ctx ->getGLSLProgram(GLSLProgramFactory::eUpdateBrickTex, true); 
//#else
//    myUpdateBrickTexturePoolCS = ctx ->getGLSLProgram(GLSLProgramFactory::eUpdateBrickTex, false); 
//#endif
//    if(!myUpdateBrickTexturePoolCS)
//    {
//       fprintf(stderr, "cannot get GLSL Program: eUpdateBrickTex\n"); 
//       return false; 
//    }
//
//    myNumUpdateBrickUniform = vlGLExt::glGetUniformLocation(myUpdateBrickTexturePoolCS->getProgram(), "numUpdateBrick");
//    myIntertwinedBrickUniform = vlGLExt::glGetUniformLocation(myUpdateBrickTexturePoolCS->getProgram(), "intertwinedBrick");
//    if(myNumUpdateBrickUniform < 0)
//    {
//        fprintf(stderr, "error when try to get UniformLocation: numUpdateBrick\n"); 
//        return false; 
//    }
//    if(myIntertwinedBrickUniform < 0)
//    {
//        fprintf(stderr, "error when try to get UniformLocation: intertwinedBrick\n"); 
//        return false; 
//    }
//    
//#ifdef USE_BINARY_SHADER_FILE     
//    myTriangleMeshRenderPrg = ctx ->getGLSLProgram(GLSLProgramFactory::eSVOTriangleMesh, true); 
//#else
//    myTriangleMeshRenderPrg = ctx ->getGLSLProgram(GLSLProgramFactory::eSVOTriangleMesh, false);
//#endif
//    if(!myTriangleMeshRenderPrg)
//    {
//       fprintf(stderr, "cannot get GLSL Program: eSVOTriangleMesh\n"); 
//       return false; 
//    } 
//
//    {
//        myTriangleMeshRenderMVPUniform = vlGLExt::glGetUniformLocation(myTriangleMeshRenderPrg -> getProgram(), "ModelViewProjection");
//        if(myTriangleMeshRenderMVPUniform < 0)
//        {
//            fprintf(stderr, "error when try to get UniformLocation: ModelViewProjection\n"); 
//            return false; 
//        }
//        myLog2GrdMatrixUniform = vlGLExt::glGetUniformLocation(myTriangleMeshRenderPrg -> getProgram(), "log2gridMatrix");
//        if(myLog2GrdMatrixUniform < 0)
//        {
//            fprintf(stderr, "error when try to get UniformLocation: log2gridMatrix\n"); 
//            return false; 
//        }        
//        myGeoSizeUniform = vlGLExt::glGetUniformLocation(myTriangleMeshRenderPrg -> getProgram(), "geoSize");
//        if(myGeoSizeUniform < 0 )
//        {
//            fprintf(stderr, "error when try to get UniformLocation: geoSize\n"); 
//            return false; 
//        }  
//    }
//   
  
//    vlGLExt::glGenProgramPipelines( 1, &myUpdateBrickTexturePipeline); 
//    vlGLExt::glUseProgramStages( myUpdateBrickTexturePipeline, GL_COMPUTE_SHADER_BIT, myUpdateBrickTexturePoolCS->getProgram() ); 
//    vlGLExt::glGenProgramPipelines( 1, &myTriangleMeshRenderPipeline); 
//    vlGLExt::glUseProgramStages( myTriangleMeshRenderPipeline, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, myTriangleMeshRenderPrg->getProgram() ); 
// 
 
#ifndef USE_BINARY_SHADER_FILE
    //for multi-channel volume rendering, use separate complied shader code. 
    
    //some shared header for all 
    const vString predefineMacrosFS = "#version 450\n#extension GL_NV_bindless_texture:require\n#extension GL_NV_shader_buffer_load:require\n"
        "#extension GL_NV_gpu_shader5: require//uint64_t\n#extension GL_ARB_shading_language_include : require\n"; 
    
    //macro for multi-channel
    const vString macroNumVols[MAX_VOLUME] = {
        "#define MACRO_NUMVOLUMES_1\n", 
        "#define MACRO_NUMVOLUMES_2\n", 
        "#define MACRO_NUMVOLUMES_3\n",
        "#define MACRO_NUMVOLUMES_4\n"
    };
    //macro for different shading quality
    const vString macroQuality[MAX_QUALITY] = {
        "#define LOWQUALITY\n", 
        "#define MEDIUMQUALITY\n", 
        "#define HIGHQUALITY\n", 
    };
    
    const vString predefineMacroUpdateBrickCS= "#version 450\n#extension GL_NV_gpu_shader5: require\n#extension GL_ARB_compute_shader : require\n"
                    "#extension GL_ARB_shader_storage_buffer_object : require\n" 
                    "#extension GL_ARB_shading_language_include : require\n"; 
    
    
    const char* const predefineMacrosCS = "#version 450\n#extension GL_NV_gpu_shader5: require\n#extension GL_ARB_compute_shader : require\n"
                    "#extension GL_ARB_shader_storage_buffer_object : require\n" 
                    "#extension GL_ARB_shading_language_include : require\n"
                    "#define MACRO_NUMVOLUMES_4\n\n";
    
    for(int v = 0; v < MAX_VOLUME; v++)
    {
        for(int q = 0; q < MAX_QUALITY; q++ )
        {     
            const vString predefineMacrosFS_i = predefineMacrosFS + macroNumVols[v] + macroQuality[q];
            fprintf(stderr, "%s\n", predefineMacrosFS_i.c_str()); 

            myOctreeRayCasterDVRFragTechnique[v][q] = new vlOctreeRayCasterDVRFragTechnique(); 
            if(!myOctreeRayCasterDVRFragTechnique[v][q]->init(ctx, GLSLProgramFactory::eOctreeRayCastDVRFrag1L + q + v*3, 
                    GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, predefineMacrosFS_i.c_str(), false))
            {
                fprintf(stderr, "error init the vlOctreeRaycasterDVRFrag_%d_%d technique\n", v, q); 
                return false; 
            }
            myOctreeRayCasterDVRRGBAFragTechnique[v][q] = new vlOctreeRayCasterDVRFragTechnique(); 
            if(!myOctreeRayCasterDVRRGBAFragTechnique[v][q]->init(ctx, GLSLProgramFactory::eOctreeRayCastDVRRGBAFrag1L + q + v*3, 
                    GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, predefineMacrosFS_i.c_str(), false))
            {
                fprintf(stderr, "error init the vlOctreeRaycasterDVRRGBAFrag_%d_%d technique\n", v, q); 
                return false; 
            }
            myOctreeRayCasterIsosurfaceFragTechnique[v][q] = new vlOctreeRayCasterIsosurfaceFragTechnique(); 
            if(!myOctreeRayCasterIsosurfaceFragTechnique[v][q] ->init(ctx, GLSLProgramFactory::eOctreeRayCastIsosurfaceFrag1L + q + v*3, 
                    GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, predefineMacrosFS_i.c_str(), false))
            {
                fprintf(stderr, "error init the vlOctreeRayCasterIsosurfaceFrag_%d_%d technique\n", v, q); 
                return false; 
            }           
            myOctreeRayCasterGradFragTechnique[v][q]  = new vlOctreeRayCasterGradFragTechnique(); 
            if(!myOctreeRayCasterGradFragTechnique[v][q]  ->init(ctx, GLSLProgramFactory::eOctreeRayCastGradFrag1L + q + v*3, 
                    GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, predefineMacrosFS_i.c_str(), false))
            {
                fprintf(stderr, "error init the vlOctreeRayCasterGradFrag_%d_%d technique\n", v,q); 
                return false; 
            }   
        }
        const vString predefineMacroUpdateBrickCS_i = predefineMacroUpdateBrickCS + macroNumVols[v];
        myUpdateBrickTexturePoolTechnique[v] = new vlUpdateBrickTexturePoolTechnique(); 
        if(!myUpdateBrickTexturePoolTechnique[v]->init(ctx,GLSLProgramFactory::eUpdateBrickTex1 + v, GL_COMPUTE_SHADER_BIT, false, 
                predefineMacroUpdateBrickCS_i.c_str(), false))
        {
            fprintf(stderr, "error init the vlUpdateBrickTexturePool technique\n"); 
            return false; 
        }
        
        vString extraMacro = "#define MAXINTPROJMODE\n" ;
        vString predefineMacrosFS_i = predefineMacrosFS + macroNumVols[v] + extraMacro;
        myOctreeRayCasterMipFragTechnique[v] = new vlOctreeRayCasterMipFragTechnique(); 
        if(!myOctreeRayCasterMipFragTechnique[v] ->init(ctx, GLSLProgramFactory::eOctreeRayCastMipFrag1 + v, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, 
            false, predefineMacrosFS_i.c_str(), false))
        {
            fprintf(stderr, "error init the mip (fragment shader version) technique\n"); 
            return false; 
        }    

        extraMacro = "#define MININTPROJMODE\n"; 
        predefineMacrosFS_i = predefineMacrosFS + macroNumVols[v] + extraMacro;
        myOctreeRayCasterMinIntProjFragTechnique[v] = new vlOctreeRayCasterMipFragTechnique(); 
        if(!myOctreeRayCasterMinIntProjFragTechnique[v] ->init(ctx, GLSLProgramFactory::eOctreeRayCastMinIntProjFrag1 + v, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, 
            false, predefineMacrosFS_i.c_str(), false))
        {
            fprintf(stderr, "error init the min intensity proj (fragment shader version) technique\n"); 
            return false; 
        }      
        
        extraMacro = "#define AVGINTPROJMODE\n"; 
        predefineMacrosFS_i = predefineMacrosFS + macroNumVols[v] + extraMacro;
        myOctreeRayCasterAipFragTechnique[v] = new vlOctreeRayCasterMipFragTechnique(); 
        if(!myOctreeRayCasterAipFragTechnique[v] ->init(ctx, GLSLProgramFactory::eOctreeRayCastAipFrag1 + v, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, 
            false, predefineMacrosFS_i.c_str(), false))
        {
            fprintf(stderr, "error init the average intensity proj (fragment shader version) technique\n"); 
            return false; 
        }  
        
        extraMacro = "#define SUMINTPROJMODE\n"; 
        predefineMacrosFS_i = predefineMacrosFS + macroNumVols[v] + extraMacro;
        myOctreeRayCasterSipFragTechnique[v] = new vlOctreeRayCasterMipFragTechnique(); 
        if(!myOctreeRayCasterSipFragTechnique[v] ->init(ctx, GLSLProgramFactory::eOctreeRayCastSipFrag1 + v, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, 
            false, predefineMacrosFS_i.c_str(), false))
        {
            fprintf(stderr, "error init the sum intensity proj (fragment shader version) technique\n"); 
            return false; 
        }  
        
        myOctreeRayCasterMopFragTechnique[v] = new vlOctreeRayCasterMopFragTechnique(); 
        if(!myOctreeRayCasterMopFragTechnique[v] ->init(ctx, GLSLProgramFactory::eOctreeRayCastMopFrag1 + v, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, 
            false,predefineMacrosFS_i.c_str(),  false))
        {
            fprintf(stderr, "error init the mop (fragment shader version) technique\n"); 
            return false; 
        }       
    }
    myOctreeRayCasterDVRTechnique = new vlOctreeRayCasterDVRTechnique(); 
    if(!myOctreeRayCasterDVRTechnique->init(ctx,GLSLProgramFactory::eOctreeRayCastDVR, GL_COMPUTE_SHADER_BIT, false, predefineMacrosCS, false))
    {
        fprintf(stderr, "error init the vlOctreeRaycasterDVR technique\n"); 
        return false; 
    }
    
    myOctreeRayCasterGradTechnique = new vlOctreeRayCasterGradTechnique(); 
    if(!myOctreeRayCasterGradTechnique->init(ctx,GLSLProgramFactory::eOctreeRayCastGrad, GL_COMPUTE_SHADER_BIT, false, predefineMacrosCS, false))
    {
        fprintf(stderr, "error init the vlOctreeRaycasterGrad technique\n"); 
        return false; 
    }
    
    myOctreeRayCasterMipTechnique = new vlOctreeRayCasterMipTechnique(); 
    if(!myOctreeRayCasterMipTechnique->init(ctx,GLSLProgramFactory::eOctreeRayCastMip, GL_COMPUTE_SHADER_BIT, false, predefineMacrosCS, false))
    {
        fprintf(stderr, "error init the vlOctreeRaycasterMip technique\n"); 
        return false; 
    }
   
    myOctreeRayCasterMopTechnique = new vlOctreeRayCasterMopTechnique(); 
    if(!myOctreeRayCasterMopTechnique->init(ctx,GLSLProgramFactory::eOctreeRayCastMop, GL_COMPUTE_SHADER_BIT, false, predefineMacrosCS, false))
    {
        fprintf(stderr, "error init the vlOctreeRayCasterMop technique\n"); 
        return false; 
    }

    myOctreeRayCasterIsosurfaceTechnique = new vlOctreeRayCasterIsosurfaceTechnique(); 
    if(!myOctreeRayCasterIsosurfaceTechnique->init(ctx,GLSLProgramFactory::eOctreeRayCastIsosurface, GL_COMPUTE_SHADER_BIT, false, predefineMacrosCS, false))
    {
        fprintf(stderr, "error init the OctreeRayCasterIsosurface technique\n"); 
        return false; 
    }

    myOctreeRayCasterTSurfTechnique = new vlOctreeRayCasterTSurfTechnique(); 
    if(!myOctreeRayCasterTSurfTechnique->init(ctx,GLSLProgramFactory::eOctreeRayCastTSurf, GL_COMPUTE_SHADER_BIT, false, predefineMacrosCS, false))
    {
        fprintf(stderr, "error init the OctreeRayCasterTSurf technique\n"); 
        return false; 
    }   

    myDrawEnvelopeTechnique = new vlDrawEnvelopeTechnique(); 
    if(!myDrawEnvelopeTechnique->init(ctx,GLSLProgramFactory::eDrawEnvelope, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, false))
    {
        fprintf(stderr, "error init the DrawEnvelopeTechnique\n"); 
        return false; 
    }      

    myComputeEnvelopeTechnique = new vlComputeEnvelopeTechnique(); 
    const char* captured[] = {"block.packedGridToPos"};    
    if(!myComputeEnvelopeTechnique->init(ctx,GLSLProgramFactory::eEnvelope, GL_VERTEX_SHADER_BIT|GL_GEOMETRY_SHADER_BIT, true, NULL, 
    false, 1, captured, GL_SEPARATE_ATTRIBS))
    {
        fprintf(stderr, "error init the ComputeEnvelopeTechnique\n"); 
        return false; 
    }        

    mySinglePassDepthBoundTechnique = new vlSinglePassDepthBoundTechnique(); 
    if(!mySinglePassDepthBoundTechnique->init(ctx,GLSLProgramFactory::eSinglePassDepthBound, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, false))
    {
        fprintf(stderr, "error init the SinglePassDepthBoundTechnique\n"); 
        return false; 
    } 

    myFullScreenCopyBasicTechnique = new vlFullScreenCopyBasicTechnique(); 
    if(!myFullScreenCopyBasicTechnique ->init(ctx, GLSLProgramFactory::eFullScreenCopyBasic, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, false))
    {
        fprintf(stderr, "error init the myFullScreenCopyBasicTechnique technique\n"); 
        return false; 
    }
    myFullScreenCopyComputeTechnique = new vlFullScreenCopyComputeTechnique(); 
    if(!myFullScreenCopyComputeTechnique ->init(ctx, GLSLProgramFactory::eFullScreenCopy, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, false))
    {
        fprintf(stderr, "error init the vlFullScreenCopyComputeTechnique technique\n"); 
        return false; 
    }
    
    myFullScreenFBOCopyTechnique = new vlFullScreenFBOCopyTechnique(); 
    if(!myFullScreenFBOCopyTechnique ->init(ctx, GLSLProgramFactory::eFullScreenFBOCopy, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, false))
    {
        fprintf(stderr, "error init the myFullScreenFBOCopyTechnique technique\n"); 
        return false; 
    }
            
    myFullScreenCopyTex2dTechnique = new vlFullScreenCopyTex2dTechnique(); 
    if(!myFullScreenCopyTex2dTechnique ->init(ctx, GLSLProgramFactory::eFullScreenCopyTex2d, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, false))
    {
        fprintf(stderr, "error init the eFullScreenCopyTex2d technique\n"); 
        return false; 
    }
    
    myRenderSlateBaseTechnique = new vlRenderSlateBaseTechnique(); 
    if(!myRenderSlateBaseTechnique ->init(ctx, GLSLProgramFactory::eRenderSlateBase, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false,NULL,  false))
    {
        fprintf(stderr, "error init the renderSlateBase technique\n"); 
        return false; 
    }    
    
    myRenderTraverseSlateBaseTechnique = new vlRenderTraverseSlateTechnique(); 
    if(!myRenderTraverseSlateBaseTechnique ->init(ctx, GLSLProgramFactory::eRenderTraverseSlate, 
        GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL,  false))
    {
        fprintf(stderr, "error init the renderTraverseSlate technique\n"); 
        return false; 
    } 

    myDrawWellLogZPassTechnique = new vlDrawWellLogTechnique(); 
    if(!myDrawWellLogZPassTechnique ->init(ctx, GLSLProgramFactory::eDrawWellLogZPass, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false,NULL,  false))
    {
        fprintf(stderr, "error init the draw well log (fragment shader version) technique\n"); 
        return false; 
    }   
    
    myChenEdgeDetectionTechnique = new vlChenEdgeDetectionTechnique(); 
    if(!myChenEdgeDetectionTechnique ->init(ctx, GLSLProgramFactory::eChenEdgeDetection, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, false))
    {
        fprintf(stderr, "error init the chen edge detection (fragment shader version) technique\n"); 
        return false; 
    }    
    
    mySobelEdgeDetectionTechnique = new vlChenEdgeDetectionTechnique(); 
    if(!mySobelEdgeDetectionTechnique ->init(ctx, GLSLProgramFactory::eSobelEdgeDetection, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, false))
    {
        fprintf(stderr, "error init the sobel edge detection (fragment shader version) technique\n"); 
        return false; 
    } 
    
    myAmbientOcclusionTechnique = new vlAmbientOcclusionTechnique(); 
    if(!myAmbientOcclusionTechnique ->init(ctx, GLSLProgramFactory::eAmbientOcclusion, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, false))
    {
        fprintf(stderr, "error init the ambient occlusion (fragment shader version) technique\n"); 
        return false; 
    }    
    
    mySSAOBlurTechnique = new vlSSAOBlurTechnique(); 
    if(!mySSAOBlurTechnique ->init(ctx, GLSLProgramFactory::eSSAOBlur, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, false))
    {
        fprintf(stderr, "error init the ambient occlusion blur (fragment shader version) technique\n"); 
        return false; 
    }     
#else
    myOctreeRayCasterDVRTechnique = new vlOctreeRayCasterDVRTechnique(); 
    if(!myOctreeRayCasterDVRTechnique->init(ctx,GLSLProgramFactory::eOctreeRayCastDVR, GL_COMPUTE_SHADER_BIT, false,NULL,  true))
    {
        fprintf(stderr, "error init the vlOctreeRaycasterDVR technique\n"); 
        return false; 
    }
    
    myOctreeRayCasterGradTechnique = new vlOctreeRayCasterGradTechnique(); 
    if(!myOctreeRayCasterGradTechnique->init(ctx,GLSLProgramFactory::eOctreeRayCastGrad, GL_COMPUTE_SHADER_BIT, false,NULL,  true))
    {
        fprintf(stderr, "error init the vlOctreeRaycasterGrad technique\n"); 
        return false; 
    }
    
    myOctreeRayCasterMipTechnique = new vlOctreeRayCasterMipTechnique(); 
    if(!myOctreeRayCasterMipTechnique->init(ctx,GLSLProgramFactory::eOctreeRayCastMip, GL_COMPUTE_SHADER_BIT, false, NULL, true))
    {
        fprintf(stderr, "error init the vlOctreeRaycasterMip technique\n"); 
        return false; 
    }
    myOctreeRayCasterMopTechnique = new vlOctreeRayCasterMopTechnique(); 
    if(!myOctreeRayCasterMopTechnique->init(ctx,GLSLProgramFactory::eOctreeRayCastMop, GL_COMPUTE_SHADER_BIT, false, NULL, true))
    {
        fprintf(stderr, "error init the vlOctreeRayCasterMop technique\n"); 
        return false; 
    }
    myOctreeRayCasterIsosurfaceTechnique = new vlOctreeRayCasterIsosurfaceTechnique(); 
    if(!myOctreeRayCasterIsosurfaceTechnique->init(ctx,GLSLProgramFactory::eOctreeRayCastIsosurface, GL_COMPUTE_SHADER_BIT, false, NULL, true))
    {
        fprintf(stderr, "error init the OctreeRayCasterIsosurface technique\n"); 
        return false; 
    }
    
    myOctreeRayCasterTSurfTechnique = new vlOctreeRayCasterTSurfTechnique(); 
    if(!myOctreeRayCasterTSurfTechnique->init(ctx,GLSLProgramFactory::eOctreeRayCastTSurf, GL_COMPUTE_SHADER_BIT, false,NULL,  true))
    {
        fprintf(stderr, "error init the OctreeRayCasterTSurf technique\n"); 
        return false; 
    }   
    
    myDrawEnvelopeTechnique = new vlDrawEnvelopeTechnique(); 
    if(!myDrawEnvelopeTechnique->init(ctx,GLSLProgramFactory::eDrawEnvelope, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, true))
    {
        fprintf(stderr, "error init the DrawEnvelopeTechnique\n"); 
        return false; 
    } 
        
    myComputeEnvelopeTechnique = new vlComputeEnvelopeTechnique(); 
    if(!myComputeEnvelopeTechnique->init(ctx,GLSLProgramFactory::eEnvelope, GL_VERTEX_SHADER_BIT|GL_GEOMETRY_SHADER_BIT, true,NULL,  true))
    {
        fprintf(stderr, "error init the ComputeEnvelopeTechnique\n"); 
        return false; 
    }             
    mySinglePassDepthBoundTechnique = new vlSinglePassDepthBoundTechnique(); 
    if(!mySinglePassDepthBoundTechnique->init(ctx,GLSLProgramFactory::eSinglePassDepthBound, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, true))
    {
        fprintf(stderr, "error init the SinglePassDepthBoundTechnique\n"); 
        return false; 
    }       
    
    for(int v = 0; v < MAX_VOLUME; v++)
    {
        for(int q = 0; q < MAX_QUALITY; q++ )
        {           
            myOctreeRayCasterDVRFragTechnique[v][q] = new vlOctreeRayCasterDVRFragTechnique(); 
            if(!myOctreeRayCasterDVRFragTechnique[v][q]->init(ctx, GLSLProgramFactory::eOctreeRayCastDVRFrag1L + q + v*3, 
                    GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, true))
            {
                fprintf(stderr, "error init the vlOctreeRaycasterDVRFrag_%d_%d technique\n", v, q); 
                return false; 
            }
            myOctreeRayCasterDVRRGBAFragTechnique[v][q] = new vlOctreeRayCasterDVRFragTechnique(); 
            if(!myOctreeRayCasterDVRRGBAFragTechnique[v][q]->init(ctx, GLSLProgramFactory::eOctreeRayCastDVRRGBAFrag1L + q + v*3, 
                    GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, true))
            {
                fprintf(stderr, "error init the vlOctreeRaycasterDVRRGBAFrag_%d_%d technique\n", v, q); 
                return false; 
            }
            myOctreeRayCasterIsosurfaceFragTechnique[v][q] = new vlOctreeRayCasterIsosurfaceFragTechnique(); 
            if(!myOctreeRayCasterIsosurfaceFragTechnique[v][q] ->init(ctx, GLSLProgramFactory::eOctreeRayCastIsosurfaceFrag1L + q + v*3, 
                    GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, true))
            {
                fprintf(stderr, "error init the vlOctreeRayCasterIsosurfaceFrag_%d_%d technique\n", v, q); 
                return false; 
            }           
            myOctreeRayCasterGradFragTechnique[v][q]  = new vlOctreeRayCasterGradFragTechnique(); 
            if(!myOctreeRayCasterGradFragTechnique[v][q]  ->init(ctx, GLSLProgramFactory::eOctreeRayCastGradFrag1L + q + v*3, 
                    GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, true))
            {
                fprintf(stderr, "error init the vlOctreeRayCasterGradFrag_%d_%d technique\n", v,q); 
                return false; 
            }   
        }
        myUpdateBrickTexturePoolTechnique[v] = new vlUpdateBrickTexturePoolTechnique(); 
        if(!myUpdateBrickTexturePoolTechnique[v]->init(ctx,GLSLProgramFactory::eUpdateBrickTex1 + v, GL_COMPUTE_SHADER_BIT, false, 
                NULL, true))
        {
            fprintf(stderr, "error init the vlUpdateBrickTexturePool technique\n"); 
            return false; 
        }
        
        myOctreeRayCasterMipFragTechnique[v] = new vlOctreeRayCasterMipFragTechnique(); 
        if(!myOctreeRayCasterMipFragTechnique[v] ->init(ctx, GLSLProgramFactory::eOctreeRayCastMipFrag1 + v, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, 
            false, NULL, true))
        {
            fprintf(stderr, "error init the mip (fragment shader version) technique\n"); 
            return false; 
        }    

        myOctreeRayCasterMinIntProjFragTechnique[v] = new vlOctreeRayCasterMipFragTechnique(); 
        if(!myOctreeRayCasterMinIntProjFragTechnique[v] ->init(ctx, GLSLProgramFactory::eOctreeRayCastMinIntProjFrag1 + v, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, 
            false, NULL, true))
        {
            fprintf(stderr, "error init the min intensity proj (fragment shader version) technique\n"); 
            return false; 
        }     
        
        myOctreeRayCasterAipFragTechnique[v] = new vlOctreeRayCasterMipFragTechnique(); 
        if(!myOctreeRayCasterAipFragTechnique[v] ->init(ctx, GLSLProgramFactory::eOctreeRayCastAipFrag1 + v, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, 
            false, NULL, true))
        {
            fprintf(stderr, "error init the average intensity proj (fragment shader version) technique\n"); 
            return false; 
        }  
        
        myOctreeRayCasterSipFragTechnique[v] = new vlOctreeRayCasterMipFragTechnique(); 
        if(!myOctreeRayCasterSipFragTechnique[v] ->init(ctx, GLSLProgramFactory::eOctreeRayCastSipFrag1 + v, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, 
            false, NULL, true))
        {
            fprintf(stderr, "error init the sum intensity proj (fragment shader version) technique\n"); 
            return false; 
        }  
        
        myOctreeRayCasterMopFragTechnique[v] = new vlOctreeRayCasterMopFragTechnique(); 
        if(!myOctreeRayCasterMopFragTechnique[v] ->init(ctx, GLSLProgramFactory::eOctreeRayCastMopFrag1 + v, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, 
            false, NULL,  true))
        {
            fprintf(stderr, "error init the mop (fragment shader version) technique\n"); 
            return false; 
        }            
    }
    
    myFullScreenCopyBasicTechnique = new vlFullScreenCopyBasicTechnique(); 
    if(!myFullScreenCopyBasicTechnique ->init(ctx, GLSLProgramFactory::eFullScreenCopyBasic, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false,NULL,  true))
    {
        fprintf(stderr, "error init the myFullScreenCopyBasicTechnique technique\n"); 
        return false; 
    }
    
    myFullScreenFBOCopyTechnique = new vlFullScreenFBOCopyTechnique(); 
    if(!myFullScreenFBOCopyTechnique ->init(ctx, GLSLProgramFactory::eFullScreenFBOCopy, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, true))
    {
        fprintf(stderr, "error init the myFullScreenFBOCopyTechnique technique\n"); 
        return false; 
    } 
    
    myFullScreenCopyTex2dTechnique = new vlFullScreenCopyTex2dTechnique(); 
    if(!myFullScreenCopyTex2dTechnique ->init(ctx, GLSLProgramFactory::eFullScreenCopyTex2d, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false,NULL,  true))
    {
        fprintf(stderr, "error init the eFullScreenCopyTex2d technique\n"); 
        return false; 
    }
    
    myFullScreenCopyComputeTechnique = new vlFullScreenCopyComputeTechnique(); 
    if(!myFullScreenCopyComputeTechnique ->init(ctx, GLSLProgramFactory::eFullScreenCopy, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, true))
    {
        fprintf(stderr, "error init the vlFullScreenCopyComputeTechnique technique\n"); 
        return false; 
    }
    
    myRenderSlateBaseTechnique = new vlRenderSlateBaseTechnique(); 
    if(!myRenderSlateBaseTechnique ->init(ctx, GLSLProgramFactory::eRenderSlateBase, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, true))
    {
        fprintf(stderr, "error init the renderSlateBase technique\n"); 
        return false; 
    } 
    myRenderTraverseSlateBaseTechnique = new vlRenderTraverseSlateTechnique(); 
    if(!myRenderTraverseSlateBaseTechnique ->init(ctx, GLSLProgramFactory::eRenderTraverseSlate, 
        GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL,  true))
    {
        fprintf(stderr, "error init the renderTraverseSlate technique\n"); 
        return false; 
    } 
     
    myDrawWellLogZPassTechnique = new vlDrawWellLogTechnique(); 
    if(!myDrawWellLogZPassTechnique ->init(ctx, GLSLProgramFactory::eDrawWellLogZPass, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, true))
    {
        fprintf(stderr, "error init the draw well log (fragment shader version) technique\n"); 
        return false; 
    }
    
    myChenEdgeDetectionTechnique = new vlChenEdgeDetectionTechnique(); 
    if(!myChenEdgeDetectionTechnique ->init(ctx, GLSLProgramFactory::eChenEdgeDetection, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, true))
    {
        fprintf(stderr, "error init the chen edge detection (fragment shader version) technique\n"); 
        return false; 
    }    
    
    mySobelEdgeDetectionTechnique = new vlChenEdgeDetectionTechnique(); 
    if(!mySobelEdgeDetectionTechnique ->init(ctx, GLSLProgramFactory::eSobelEdgeDetection, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, true))
    {
        fprintf(stderr, "error init the sobel edge detection (fragment shader version) technique\n"); 
        return false; 
    } 
    myAmbientOcclusionTechnique = new vlAmbientOcclusionTechnique(); 
    if(!myAmbientOcclusionTechnique ->init(ctx, GLSLProgramFactory::eAmbientOcclusion, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, true))
    {
        fprintf(stderr, "error init the ambient occlusion (fragment shader version) technique\n"); 
        return false; 
    } 
    mySSAOBlurTechnique = new vlSSAOBlurTechnique(); 
    if(!mySSAOBlurTechnique ->init(ctx, GLSLProgramFactory::eSSAOBlur, GL_VERTEX_SHADER_BIT|GL_FRAGMENT_SHADER_BIT, false, NULL, true))
    {
        fprintf(stderr, "error init the ambient occlusion blur (fragment shader version) technique\n"); 
        return false; 
    }   
#endif
       
#ifndef USE_BINARY_SHADER_FILE
    //  Retrieve the binary from the program object
    //
#ifdef EXPORT_BINARY_SHADER_FILE
    myOctreeRayCasterDVRTechnique ->writeBinary("eOctreeRayCasterDVR.bsh"); 
    myOctreeRayCasterGradTechnique ->writeBinary("eOctreeRayCasterGrad.bsh"); 
    myOctreeRayCasterMipTechnique ->writeBinary("eOctreeRayCasterMip.bsh"); 
    myOctreeRayCasterMopTechnique ->writeBinary("eOctreeRayCasterMop.bsh"); 
    myOctreeRayCasterIsosurfaceTechnique ->writeBinary("eOctreeRayCasterIsosurface.bsh"); 
    myOctreeRayCasterTSurfTechnique ->writeBinary("eOctreeRayCasterTsurf.bsh"); 
    myComputeEnvelopeTechnique ->writeBinary("eComputeEnvelope.bsh"); 
    mySinglePassDepthBoundTechnique ->writeBinary("eSinglePassDepthBound.bsh");
    myDrawEnvelopeTechnique ->writeBinary("eDrawEnvelope.bsh");
    
    char bshName[256]; 
    const char* q_prefix[MAX_QUALITY] = { "L", "M", "H" };
    for(int v = 0; v < MAX_VOLUME; v++)
    {
        for(int q = 0; q < MAX_QUALITY; q++)
        {
            sprintf(bshName, "eOctreeRayCasterDVRFrag%d%s.bsh", v+1, q_prefix[q]); 
            fprintf(stderr, "%s\n", bshName ); 
            myOctreeRayCasterDVRFragTechnique[v][q]->writeBinary(bshName);
            sprintf(bshName, "eOctreeRayCasterDVRRGBAFrag%d%s.bsh", v+1, q_prefix[q]); 
            myOctreeRayCasterDVRRGBAFragTechnique[v][q]->writeBinary(bshName);
            sprintf(bshName, "eOctreeRayCastIsosurfaceFrag%d%s.bsh", v+1, q_prefix[q]); 
            myOctreeRayCasterIsosurfaceFragTechnique[v][q]->writeBinary(bshName); 
            sprintf(bshName, "eOctreeRayCastGradFrag%d%s.bsh", v+1, q_prefix[q]); 
            myOctreeRayCasterGradFragTechnique[v][q] ->writeBinary(bshName); 
        }
        sprintf(bshName, "eOctreeRayCastMipFrag%d.bsh", v+1); 
        myOctreeRayCasterMipFragTechnique[v]->writeBinary(bshName); 
        sprintf(bshName, "eOctreeRayCastMopFrag%d.bsh", v+1); 
        myOctreeRayCasterMopFragTechnique[v]->writeBinary(bshName); 
        sprintf(bshName, "eOctreeRayCastMinIntProjFrag%d.bsh", v+1);     
        myOctreeRayCasterMinIntProjFragTechnique->writeBinary(bshName);
        sprintf(bshName, "eOctreeRayCastAipFrag%d.bsh", v+1);   
        myOctreeRayCasterAipFragTechnique[v]->writeBinary(bshName); 
        sprintf(bshName, "eOctreeRayCastSipFrag%d.bsh", v+1);   
        myOctreeRayCasterSipFragTechnique[v]->writeBinary(bshName); 
        sprintf(bshName, "eUpdateBrickTex%d.bsh", v+1); 
        myUpdateBrickTexturePoolTechnique[v]->writeBinary(bshName);
    }
    
    myFullScreenCopyComputeTechnique ->writeBinary("eFullScreenCopy.bsh");
    myFullScreenCopyBasicTechnique ->writeBinary("eFullScreenCopyBasic.bsh");
    myFullScreenFBOCopyTechnique -> writeBinary("eFullScreenFBOCopy.bsh");
    myFullScreenCopyTex2dTechnique ->writeBinary("eFullScreenCopyTex2d.bsh");
    myRenderSlateBaseTechnique ->writeBinary("eRenderSlateBase.bsh"); 
    myRenderTraverseSlateBaseTechnique ->writeBinary("eRenderTraverseSlate.bsh"); 
    
    
    myDrawWellLogZPassTechnique -> writeBinary("eDrawWellLogZPass.bsh"); 
    mySobelEdgeDetectionTechnique -> writeBinary("eSobelEdgeDetection.bsh"); 
    myChenEdgeDetectionTechnique -> writeBinary("eChenEdgeDetection.bsh"); 
    myAmbientOcclusionTechnique ->writeBinary("eAmbientOcclusion.bsh");
    mySSAOBlurTechnique ->writeBinary("eSSAOBlur.bsh"); 
#endif
#endif    
    char bshName[256]; 
    const char* q_prefix[MAX_QUALITY] = { "L", "M", "H" };
    for(int v = 0; v < MAX_VOLUME; v++)
    {
        for(int q = 0; q < MAX_QUALITY; q++)
        {
            sprintf(bshName, "eOctreeRayCasterDVRFrag%d%s.bsh", v+1, q_prefix[q]); 
            myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>(vString(bshName), myOctreeRayCasterDVRFragTechnique[v][q]) ); 
            sprintf(bshName, "eOctreeRayCasterDVRRGBAFrag%d%s.bsh", v+1, q_prefix[q]); 
            myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>(vString(bshName), myOctreeRayCasterDVRRGBAFragTechnique[v][q]) ); 
            sprintf(bshName, "eOctreeRayCastIsosurfaceFrag%d%s.bsh", v+1, q_prefix[q]); 
            myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>(vString(bshName), myOctreeRayCasterIsosurfaceFragTechnique[v][q]) ); 
            sprintf(bshName, "eOctreeRayCastGradFrag%d%s.bsh", v+1, q_prefix[q]); 
            myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>(vString(bshName), myOctreeRayCasterGradFragTechnique[v][q]) ); 
        }
        sprintf(bshName, "eOctreeRayCastMipFrag%d.bsh", v+1);
        myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>(vString(bshName), myOctreeRayCasterMipFragTechnique[v]) ); 
        sprintf(bshName, "eOctreeRayCastMopFrag%d.bsh", v+1); 
        myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>(vString(bshName), myOctreeRayCasterMopFragTechnique[v]) ); 
        sprintf(bshName, "eOctreeRayCastMinIntProjFrag%d.bsh", v+1); 
        myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>(vString(bshName), myOctreeRayCasterMinIntProjFragTechnique[v]) ); 
        sprintf(bshName, "eOctreeRayCastAipFrag%d.bsh", v+1);
        myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>(vString(bshName), myOctreeRayCasterAipFragTechnique[v]) ); 
        sprintf(bshName, "eOctreeRayCastSipFrag%d.bsh", v+1); 
        myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>(vString(bshName), myOctreeRayCasterSipFragTechnique[v]) ); 
        sprintf(bshName, "eUpdateBrickTex%d.bsh", v+1); 
        myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>(vString(bshName), myUpdateBrickTexturePoolTechnique[v]) ); 
    }
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eOctreeRayCasterDVR.bsh",myOctreeRayCasterDVRTechnique) ); 
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eOctreeRayCasterGrad.bsh",myOctreeRayCasterGradTechnique) ); 
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eOctreeRayCasterMip.bsh",myOctreeRayCasterMipTechnique) ); 
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eOctreeRayCasterMop.bsh",myOctreeRayCasterMopTechnique) ); 
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eOctreeRayCasterIsosurface.bsh",myOctreeRayCasterIsosurfaceTechnique) ); 
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eOctreeRayCasterTsurf.bsh",myOctreeRayCasterTSurfTechnique) ); 
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eComputeEnvelope.bsh",myComputeEnvelopeTechnique) ); 
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eSinglePassDepthBound.bsh",mySinglePassDepthBoundTechnique) ); 
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eDrawEnvelope.bsh",myDrawEnvelopeTechnique) ); 
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eFullScreenCopy.bsh",myFullScreenCopyComputeTechnique) ); 
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eFullScreenCopyBasic.bsh",myFullScreenCopyBasicTechnique) ); 
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eFullScreenFBOCopy.bsh",myFullScreenFBOCopyTechnique) ); 
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eFullScreenCopyTex2d.bsh",myFullScreenCopyTex2dTechnique) ); 
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eRenderSlateBase.bsh",myRenderSlateBaseTechnique) ); 
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eRenderTraverseSlate.bsh",myRenderTraverseSlateBaseTechnique) ); 
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eDrawWellLogZPass.bsh",myDrawWellLogZPassTechnique) ); 
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eSobelEdgeDetection.bsh",mySobelEdgeDetectionTechnique) ); 
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eAmbientOcclusion.bsh",myAmbientOcclusionTechnique) ); 
    myGLSLTechHash.insert( std::make_pair<vString, const vlGLSLTechnique*>("eSSAOBlur.bsh",mySSAOBlurTechnique) );
    
    return checkError("initShader");
}

bool VolumeRayCasterAlgorithmImp::checkError( const char* title)
{
    int Error; 
    Error = glGetError();
    if( Error  != GL_NO_ERROR )
    {
        std :: string ErrorString; 
        switch( Error )
        {
            case GL_INVALID_ENUM:
                ErrorString = "GL_INVALID_ENUM"; 
                break; 
            case GL_INVALID_VALUE:
                ErrorString = "GL_INVALID_VALUE"; 
                break; 
            case GL_INVALID_OPERATION: 
                ErrorString = "GL_INVALID_OPERATION";
                break;
            case GL_INVALID_FRAMEBUFFER_OPERATION:
                ErrorString = "GL_INVALID_FRAMEBUFFER_OPERATION";
                break;
            case GL_OUT_OF_MEMORY:
                ErrorString = "GL_OUT_OF_MEMORY";
                break;
            default:
                ErrorString = "UNKNOWN"; 
                break ;
        }
        
        fprintf( stderr, "OPENGL Error(%s, %d): %s\n",  ErrorString.c_str(), Error, title); 
    }
    return Error == GL_NO_ERROR; 
}

bool VolumeRayCasterAlgorithmImp::initOctreeNodeBuffer()
{ 
    //initiate octree node buffer from svo 
    while(!checkError("before initOctreeNodeBuffer"))
    {
        continue;
    }
    if(!this ->myOctreeVol )
    {
        fprintf(stderr, "failed to initialize octree node buffer due to Null SVO\n");
        return false; 
    }
    
    const size_t nodeCount = myOctreeVol -> getNumNodes(); 
    const size_t numVolumes= myOctreeVol -> getNumVolumes(); 
    const size_t treeDepth = myOctreeVol ->getSparseTreeDepth(); 
   
    if(numVolumes < 0 || numVolumes > 4)
    {
        fprintf(stderr, "failed to initialize octree node buffer due to SVO contain invalid number of Volumes\n");
        return false; 
    }
    
    if( treeDepth >= 8 )
    {
        fprintf(stderr, "failed to init octreeNodeBuffer, too small brick dimension, please select larger brick dimension\n");
        return false;         
    }
      
    myNodeBufferSize = nodeCount;

    if( myNodeBuffer )
        delete[] myNodeBuffer; 
        
    if(myOctreeNodeInfos)
        delete[] myOctreeNodeInfos; 
    
    //fragment in memory, defragmentation optim
    myNodeBuffer = new uint64_t[myNodeBufferSize];     
    myOctreeNodeInfos = new OctreeNodeInfo[myNodeBufferSize];
    
    if(!myNodeBuffer || !myOctreeNodeInfos)
    {
        fprintf(stderr, "running out of memory: cannot create node buffer and octreenodeinfo\n");
        return false; 
    }
    
    //BFS tree traversal
    //size_t: offset in OctreeNodeBuffer
    typedef std::pair< const vlSparseVolumeOctreeNode*, size_t > QueuedOctreeNode; 
    std::queue<QueuedOctreeNode> OctreeNodeQueue; 
    
    uint16_t avgValues[4]; 
    bool useMaxValue = false; 
    
    const vlSparseVolumeOctreeNode* rootNode = this ->myOctreeVol->getSVORootNode(); 
    if( !rootNode )
    {
        fprintf(stderr, "failed to initialize octree node buffer, invalid SVO in memory\n");
        return false;        
    }
    
    for( size_t v = 0; v < numVolumes; v++)
        avgValues[v] = useMaxValue ? rootNode ->getMaxVoxelIntensity(v) : rootNode ->getAvgVoxelIntensity(v); 

    this ->myNodeBuffer[0] = this ->createOctreeNodeBufferEntry(rootNode ->isConstant(), false, 0, 0, avgValues, numVolumes); 
    this ->myOctreeNodeInfos[0].myOctreeNode = this ->myOctreeVol->getSVORootNode(); 
    this ->myOctreeNodeInfos[0].myLevel = treeDepth - 1; 
    this ->myOctreeNodeInfos[0].myNodeExists = true; 
     
    OctreeNodeQueue.push(QueuedOctreeNode(this ->myOctreeVol->getSVORootNode(), 0 )); //offset 0 
    
    //next free offset
    size_t curOffset = 1; 
    while( !OctreeNodeQueue.empty() )
    {
        const vlSparseVolumeOctreeNode* curOctreeNode = OctreeNodeQueue.front().first; 
        size_t curOctreeNodeOffset = OctreeNodeQueue.front().second; 
        
        if(curOctreeNodeOffset >= nodeCount)
        {
            fprintf(stderr, "OctreeNodeQueue, overflow index\n"); 
            return false; 
        }
        
        if(curOctreeNode != myOctreeNodeInfos[curOctreeNodeOffset].myOctreeNode )
        {
            fprintf(stderr, "error occur when build up node buffer\n"); 
            return false;            
        }
        
        if(myOctreeNodeInfos[curOctreeNodeOffset].myLevel >= treeDepth)
        {
            fprintf(stderr, "OctreeNode Level overflow index\n"); 
            return false;            
        }
        
        //leaf node's nodeLevel= 0;
        const size_t nodeLevel = myOctreeNodeInfos[curOctreeNodeOffset].myLevel ; 
        OctreeNodeQueue.pop(); 
        
        //sparse node, homogeneous 
        if( !curOctreeNode ->m_children[0] ){
            continue; 
        }
        
        if(curOctreeNodeOffset >= curOffset )
        {
            fprintf(stderr, "error: future node buffer slot been occupied\n"); 
            return false;             
        }
         
        if( curOffset + 8 > nodeCount ) //store 8 child consecutively
        {
            fprintf(stderr, "error: future node buffer overflow \n"); 
            return false;         
        }
        // beginning address of 8 child, consecutive in memory
        this ->updateOctreeNodeChildPointer(  myNodeBuffer[curOctreeNodeOffset],  curOffset );  
        if( ( (  myNodeBuffer[curOctreeNodeOffset] )  >> MASK_CHILD_SHIFT ) != curOffset  )
        {
            fprintf(stderr, "error: wrong child0 offset stored in parent node \n"); 
            return false; 
        }
        
        for( size_t childID = 0; childID < 8; childID++ )
        {
            const vlSparseVolumeOctreeNode* child = curOctreeNode ->m_children[childID]; 
            assert( child ); 
            size_t childOffset = curOffset + childID; //consecutive 
            assert( childOffset < nodeCount ); //overflow
            
            for( size_t v = 0; v < numVolumes; v++ )
                avgValues[v] = useMaxValue ? child ->getMaxVoxelIntensity(v) : child ->getAvgVoxelIntensity(v); 
            
            uint64_t childEntry = this ->createOctreeNodeBufferEntry(child ->isConstant(),false, 0, 0, avgValues, numVolumes ); 
            //test inbrickpool flag is false
            assert( ( ( childEntry  & MASK_INBRICKPOOL) >> MASK_INBRICKPOOL_SHIFT ) == 0 ); 
            //test homogeneity flag
            assert( ( ( childEntry  & MASK_HOMOGENEOUS) >> MASK_HOMOGENEOUS_SHIFT ) == (!child->hasBrick()) ); 
            //test child node starting address is uninitialzed here
            assert( ( ( childEntry  & MASK_CHILD ) >> MASK_CHILD_SHIFT ) == 0  );
            assert(  (( childEntry  & getAvgMask(0, numVolumes).MASK ) >> getAvgMask(0, numVolumes).SHIFT) == 
                     ( avgValues[0] >>  (16 - getAvgMask(0, numVolumes).NUMBITS ) ) ); 
            
            myNodeBuffer[childOffset] = childEntry; 
            assert( nodeLevel > 0 ); 
            myOctreeNodeInfos[childOffset].myNodeExists = true;
            myOctreeNodeInfos[childOffset].myOctreeNode = child; 
            myOctreeNodeInfos[childOffset].myParentNodeIndex = curOffset; 
            myOctreeNodeInfos[childOffset].myLevel = nodeLevel - 1;
            
            OctreeNodeQueue.push(QueuedOctreeNode(child, childOffset) );            
        }
        
        curOffset += 8; 
    }
    assert( curOffset == nodeCount ); 
    fprintf(stderr, "Octree Node Buffer Size: %s\n", OctreeUtils::formatMemorySize( nodeCount * sizeof( uint64_t) ).c_str() );   

#ifndef USE_PERSISTENT_NODEBUFFER    
    vlGLExt::glGenBuffers( 1, &myNodeBufferGL);
    vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, myNodeBufferGL);  
    vlGLExt::glBufferData( GL_SHADER_STORAGE_BUFFER, sizeof(uint64_t) * nodeCount, myNodeBuffer, GL_STREAM_DRAW) ; //OR STATIC 
    vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, 0);    
    this ->checkError("gl bind octree node buffer"); 
#else 
    
    //content of octree node buffer is frequently updated. therefore, use persistent mapped buffer to lower driver overhead. 
    if(myNodeBufferGL == 0) 
        vlGLExt::glGenBuffers( 1, &myNodeBufferGL); 
    vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, myNodeBufferGL);
    vlGLExt::glBufferStorage(GL_SHADER_STORAGE_BUFFER, sizeof(uint64_t) * nodeCount, 0, GL_MAP_WRITE_BIT|GL_MAP_READ_BIT|GL_MAP_PERSISTENT_BIT|GL_MAP_COHERENT_BIT); 
    myPersistentGLNodeBufferPtr = vlGLExt::glMapBufferRange(GL_SHADER_STORAGE_BUFFER, 0, 
            sizeof(uint64_t) * nodeCount, 
            GL_MAP_WRITE_BIT|GL_MAP_READ_BIT|GL_MAP_PERSISTENT_BIT|GL_MAP_COHERENT_BIT);  //GL_MAP_COHERENT_BIT: automatic sync to gpu
    if(!myPersistentGLNodeBufferPtr)
    {
        fprintf(stderr, "cannot map myPersistentGLNodeBufferPtr\n"); 
        return false;
    }
    //zero overhead upload to vram, graphics card will see it right after this. 
    memcpy( (uint64_t*)this ->myPersistentGLNodeBufferPtr, myNodeBuffer, sizeof(uint64_t) * nodeCount); 
    vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, 0);    
#endif     
    return checkError("after initOctreeNodeBuffer"); 
}

bool VolumeRayCasterAlgorithmImp::initOctreeBrickBuffer()
{
    //initialize octree brick buffer. 
    while(!checkError("before initOctreeBrickBuffer"))
    {
        continue;
    }
    
    if( !this ->myNodeBuffer )
    {
        fprintf(stderr, "invalid octree node buffer, cannot initialize octree brick pool\n"); 
        return false; 
    }
    
    const size_t nodeCount = this -> myNodeBufferSize; 
        
    this ->myBrickBufferSize = 0; 
    this ->myNumBrickBufferSlots = 0; 
    this ->myBrickUploadBufferSize = 0; 
    this ->myNumBrickUploadBufferSlots = 0; 

    if( myBrickUsageBuffer ){
        delete[] myBrickUsageBuffer; 
        myBrickUsageBuffer = NULL; 
    }
    
    this ->myLRUBricks = std::vector< std::list<LRUBrick> >( this ->myOctreeVol->getTreeDepth() ); 
    //this ->myLRUBricks = std::vector< std::list<LRUBrick> >( this ->myOctreeVol->getSparseTreeDepth() ); 
    
    //vram budget
    this ->myNumBrickBufferSlots = OctreeUtils::ifloor((double)(  ((size_t)this ->myVolRenderConfig->getSingleBrickBufferSizeMB()) << 20)/(float)(myOctreeVol
            -> getBrickSize() ) );
    this ->myNumBrickBufferSlots = std::min( myNumBrickBufferSlots, nodeCount ); //each node -> each brick , limited by vram 
    
    if( myNumBrickBufferSlots == 0 )
    {
        fprintf( stderr, "Brick buffer size ( %s ) smaller than memory size of a single brick (%s)\n ", 
                OctreeUtils::formatMemorySize(  this ->myVolRenderConfig->getSingleBrickBufferSizeMB() << 20 ).c_str(), 
                OctreeUtils::formatMemorySize(  myOctreeVol-> getBrickSize() ).c_str());
        return false; 
    }
    
    myBrickBufferSize = myNumBrickBufferSlots * (myOctreeVol-> getBrickSize() / sizeof(uint16_t)); 
    
    //how many brick can be uploaded per frame, streaming budget, critical to performance
    this ->myNumBrickUploadBufferSlots = std::min( ( this ->myVolRenderConfig->getBrickBufferUploadBudgetMB() << 20 ) / myOctreeVol -> getBrickSize()     
        , myNumBrickBufferSlots ); 
    
    if( myNumBrickUploadBufferSlots == 0 )
    {
        fprintf( stderr, "Brick upload buffer budget size ( %s ) smaller than memory size of a single brick (%s)\n ", 
                OctreeUtils::formatMemorySize(  this ->myVolRenderConfig->getBrickBufferUploadBudgetMB() << 20 ).c_str(), 
                OctreeUtils::formatMemorySize(  myOctreeVol-> getBrickSize() ).c_str());
        this ->myBrickBufferSize = 0; 
        this ->myNumBrickBufferSlots = 0; 
        return false; 
    }
    
    this ->myBrickUploadBufferSize = std::min( ( this ->myVolRenderConfig->getBrickBufferUploadBudgetMB() << 20 ) / sizeof( uint16_t),  
                                                this ->myBrickBufferSize );  
    
    this ->myBrickUsageBuffer = new uint8_t[nodeCount]; 
    memset( myBrickUsageBuffer, 0, nodeCount * sizeof(uint8_t) ); 
    
    Vect3i brickDim = myOctreeVol ->getBrickDimension(); 
    uint brickNumX, brickNumY, brickNumZ; 
    brickNumX = this ->myVolRenderConfig->getBrickTexDim()[0]/brickDim[0]; 
    brickNumY = this ->myVolRenderConfig->getBrickTexDim()[1]/brickDim[1];
    brickNumZ = (uint)ceil(  ((float)myNumBrickBufferSlots / float(brickNumX * brickNumY) ) );  
    Vect3i volTexDim( brickNumX * brickDim[0], brickNumY * brickDim[1],  brickNumZ * brickDim[2]);
    
    fprintf(stderr, "volTexDim: %d %d %d\n",volTexDim[0], volTexDim[1], volTexDim[2] ); 
    
    int align; 
    glGetIntegerv( GL_UNPACK_ALIGNMENT, &align);
    glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
    glPixelTransferi( GL_MAP_COLOR, 0 ); // turn off in case this was on
    
    if(myBrickVolTextureGL == 0 )
        glGenTextures( 1, &myBrickVolTextureGL); 
    
    glBindTexture( GL_TEXTURE_3D, myBrickVolTextureGL );    
    vlGLExt::glTextureParameteri( myBrickVolTextureGL, GL_TEXTURE_MAG_FILTER, GL_LINEAR ); 
    vlGLExt::glTextureParameteri( myBrickVolTextureGL, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); 
    vlGLExt::glTextureParameteri( myBrickVolTextureGL, GL_TEXTURE_BASE_LEVEL, 0 ); 
    vlGLExt::glTextureParameteri( myBrickVolTextureGL, GL_TEXTURE_MAX_LEVEL, 0); 
    vlGLExt::glTextureParameteri( myBrickVolTextureGL, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE ); 
    vlGLExt::glTextureParameteri( myBrickVolTextureGL, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
    vlGLExt::glTextureParameteri( myBrickVolTextureGL, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE );
    if(this->myOctreeVol->getNumVolumes() == 1)
        vlGLExt::glTexStorage3D( GL_TEXTURE_3D, 1, GL_R16UI, volTexDim[0], volTexDim[1], volTexDim[2]  ); 
    else if(this->myOctreeVol->getNumVolumes() == 2)
        vlGLExt::glTexStorage3D( GL_TEXTURE_3D, 1, GL_RG16UI, volTexDim[0], volTexDim[1], volTexDim[2]  ); 
    //OPENGL doesn't have  GL_RGB16UI, so use GL_RGBA16UI instead
    else if(this->myOctreeVol->getNumVolumes() == 3)
        vlGLExt::glTexStorage3D( GL_TEXTURE_3D, 1, GL_RGBA16UI, volTexDim[0], volTexDim[1], volTexDim[2]  ); 
    else if(this->myOctreeVol->getNumVolumes() == 4)
        vlGLExt::glTexStorage3D( GL_TEXTURE_3D, 1, GL_RGBA16UI, volTexDim[0], volTexDim[1], volTexDim[2]  ); 
    glBindTexture( GL_TEXTURE_3D, 0 ); 
    glPixelStorei(GL_UNPACK_ALIGNMENT, align);
    glPixelTransferi( GL_MAP_COLOR, 1 ); // turn off in case this was on
    
    checkError("after glTexStorage3D"); 

#ifdef USE_PERSISTENT_NODEBUFFER
    //MAX_SYNC_BUFFER_COUNT(triple) sized buffer for octree brick usage statistics each frame.  
    for(size_t i = 0; i < MAX_SYNC_BUFFER_COUNT; i++)
    {
        this ->myGLSyncRange[i].begin = i * nodeCount * sizeof(uint8_t); 
    }
 
    if(myBrickUsageBufferGL == 0 )
        vlGLExt::glGenBuffers( 1, &myBrickUsageBufferGL); 
    
    vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, myBrickUsageBufferGL);
    vlGLExt::glBufferStorage(GL_SHADER_STORAGE_BUFFER, sizeof(uint8_t) * nodeCount * MAX_SYNC_BUFFER_COUNT, 0, 
            GL_MAP_WRITE_BIT|GL_MAP_READ_BIT|GL_MAP_PERSISTENT_BIT|GL_MAP_COHERENT_BIT); 
    myPersistentBufferUsageMapPtr = vlGLExt::glMapBufferRange(GL_SHADER_STORAGE_BUFFER, 0, sizeof(uint8_t) * nodeCount * MAX_SYNC_BUFFER_COUNT, 
            GL_MAP_WRITE_BIT|GL_MAP_READ_BIT|GL_MAP_PERSISTENT_BIT|GL_MAP_COHERENT_BIT); 

    memset( (uint8_t*)this ->myPersistentBufferUsageMapPtr, 0, sizeof(uint8_t) * nodeCount * MAX_SYNC_BUFFER_COUNT ); 
    vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, 0);    
#else
    if(myBrickUsageBufferGL == 0 )
        vlGLExt::glGenBuffers( 1, &myBrickUsageBufferGL); 
    vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, myBrickUsageBufferGL);
    vlGLExt::glBufferData( GL_SHADER_STORAGE_BUFFER, sizeof(uint8_t) * nodeCount, NULL, GL_DYNAMIC_READ|GL_DYNAMIC_DRAW) ; 
    fprintf(stderr, "allocate usage buffer size: %d\n", sizeof(uint8_t) * nodeCount); 
    vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, 0); 
#endif
//    
//    fprintf( stderr, "Brick buffer size: %s/%d\n", OctreeUtils::formatMemorySize( myBrickBufferSize * sizeof(uint16_t) ).c_str(), 
//            myNumBrickBufferSlots ); 
//    fprintf( stderr, "Brick upload buffer size: %s/%d\n", OctreeUtils::formatMemorySize( myBrickUploadBufferSize * sizeof(uint16_t) ).c_str(), 
//            myNumBrickUploadBufferSlots ); 
//    fprintf( stderr, "Brick usage buffer size:%s\n", OctreeUtils::formatMemorySize(nodeCount * sizeof(uint8_t)).c_str() ); 

    return checkError("initOctreeBrickBuffer"); 
}

bool VolumeRayCasterAlgorithmImp::initVoxelPickBuffer()
{
    while(!checkError("before initVoxelPickBuffer"))
    {
        continue;
    }    
    
    if(myVoxelPickBuffer)
    {
        delete myVoxelPickBuffer; 
        myVoxelPickBuffer = 0; 
    }
    
    myVoxelPickBuffer = new VoxelInfo; 
    
#ifndef USE_PERSISTENT_NODEBUFFER    
    vlGLExt::glGenBuffers( 1, &myVoxelPickGL);
    vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, myVoxelPickGL);  
    uint sizeofvoxel = sizeof(VoxelInfo); 
    VoxelInfo* zeroVal = new VoxelInfo; 
    vlGLExt::glBufferData( GL_SHADER_STORAGE_BUFFER, sizeof(VoxelInfo) * 1, NULL, GL_DYNAMIC_READ|GL_DYNAMIC_DRAW) ; //OR STATIC 
    vlGLExt::glBufferSubData( GL_SHADER_STORAGE_BUFFER, 0, sizeof(VoxelInfo) * 1, zeroVal ) ; //OR STATIC 
    vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, 0);    
    this ->checkError("gl bind myVoxelPickGL buffer"); 
#else   
    if(myVoxelPickGL == 0 )
        vlGLExt::glGenBuffers( 1, &myVoxelPickGL); 
    
    vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, myVoxelPickGL);
    vlGLExt::glBufferStorage(GL_SHADER_STORAGE_BUFFER, sizeof(VoxelInfo) * 1, 0, GL_MAP_WRITE_BIT|GL_MAP_READ_BIT|GL_MAP_PERSISTENT_BIT|GL_MAP_COHERENT_BIT); 
    myPersistentPickVoxelBufferPtr = vlGLExt::glMapBufferRange(GL_SHADER_STORAGE_BUFFER, 0, 
            sizeof(VoxelInfo) * 1, 
            GL_MAP_WRITE_BIT|GL_MAP_READ_BIT|GL_MAP_PERSISTENT_BIT|GL_MAP_COHERENT_BIT); 
    
    if(!myPersistentPickVoxelBufferPtr){
        fprintf(stderr, "failed to map PersistentPickVoxelBuffer\n");
        return false; 
    }
    
    vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, 0);    
#endif  
    
    return checkError("initVoxelPickBuffer"); 
    
}

bool VolumeRayCasterAlgorithmImp::initUniformBuffer()
{
    //these uniform never changed each frame, therefore use uniform buffer 
    while(!checkError("before initUniformBuffer"))
    {
        continue;
    }
    
    if(!myOctreeVol)
        return false; 
    
    const size_t numVolumes = myOctreeVol->getNumVolumes(); 
    
    //uniform block buffer
    GLint UniformBlockSize = 0; 
    GLuint UniformBlockIndex; 
    
    {
        vlGLExt::glGenBuffers(1, &myOctreeParamsUniformBlockBuffer); 
        this ->myOctreeRayCasterDVRTechnique->getUniformBlockInfo("octreeparams", UniformBlockIndex, UniformBlockSize);
        vlGLExt::glBindBuffer(GL_UNIFORM_BUFFER, myOctreeParamsUniformBlockBuffer); 
              
        OctreeParamsMapping octreeParam[1] = 
        {
            (uint)myOctreeVol->getOctreeDimension()[0],
            (uint)myOctreeVol->getBrickDimension()[0], 
            (uint)myOctreeVol->getTreeDepth(),  
            (uint)myOctreeVol->getNumVolumes()
        };
        
        vlGLExt::glBufferData(GL_UNIFORM_BUFFER, UniformBlockSize, &octreeParam[0], GL_STATIC_DRAW); 
        vlGLExt::glBindBuffer(GL_UNIFORM_BUFFER, 0); 
        
        vlGLExt::glGenBuffers(1, &myMaskParamsUniformBlockBuffer); 
        this ->myOctreeRayCasterDVRTechnique->getUniformBlockInfo("maskparams", UniformBlockIndex, UniformBlockSize);
        vlGLExt::glBindBuffer(GL_UNIFORM_BUFFER, myMaskParamsUniformBlockBuffer); 
               
        vUtl::Vect4<uint64_t> mask_avg(getAvgMask(0, numVolumes).MASK, getAvgMask(1, numVolumes).MASK, getAvgMask(2, numVolumes).MASK, 
                        getAvgMask(3 , numVolumes).MASK); 
        
        vUtl::Vect4<uint> mask_avg_shift(getAvgMask(0, numVolumes).SHIFT, getAvgMask(1, numVolumes).SHIFT, getAvgMask(2, numVolumes).SHIFT, 
                        getAvgMask(3 , numVolumes).SHIFT); 
        
        vUtl::Vect4<uint> mask_avg_numbits(getAvgMask(0, numVolumes).NUMBITS, getAvgMask(1, numVolumes).NUMBITS, getAvgMask(2, numVolumes).NUMBITS, 
                        getAvgMask(3 , numVolumes).NUMBITS); 
        
        MaskParamsMapping maskParam[1] = 
        {
           MASK_HOMOGENEOUS, 
           MASK_HOMOGENEOUS_SHIFT, 
           MASK_HOMOGENEOUS_NUMBITS, 
           
           MASK_INBRICKPOOL, 
           MASK_INBRICKPOOL_SHIFT, 
           MASK_INBRICKPOOL_NUMBITS, 
           
           MASK_CHILD, 
           MASK_CHILD_SHIFT, 
           MASK_CHILD_NUMBITS, 
           
           MASK_BRICK, 
           MASK_BRICK_SHIFT, 
           MASK_BRICK_NUMBITS, 
           
           mask_avg, 
           mask_avg_shift, 
           mask_avg_numbits
        }; 
        
        
        vlGLExt::glBufferData(GL_UNIFORM_BUFFER, UniformBlockSize, &maskParam[0], GL_STATIC_DRAW); 
        vlGLExt::glBindBuffer(GL_UNIFORM_BUFFER, 0); 
        
        vlGLExt::glGenBuffers(1, &myBufferUsageUniformBlockBuffer); 
        
        this ->myOctreeRayCasterDVRTechnique->getUniformBlockInfo("bufferUsageParams", UniformBlockIndex, UniformBlockSize);
        vlGLExt::glBindBuffer(GL_UNIFORM_BUFFER, myBufferUsageUniformBlockBuffer); 
        
        BufferUsageParamsMapping bufferUsageParams[1]= 
        {
            MASK_BRICK_INUSE, 
            MASK_BRICK_REQUESTED, 
            MASK_NODE_TRAVERSED
        };
        vlGLExt::glBufferData(GL_UNIFORM_BUFFER, UniformBlockSize, bufferUsageParams, GL_STATIC_DRAW); 
        vlGLExt::glBindBuffer(GL_UNIFORM_BUFFER, 0); 
    }
    
    return checkError("initUniformBuffer"); 
}

void VolumeRayCasterAlgorithmImp::updateBoundingBoxRange( Vect3f min, Vect3f max)
{
    if( vertexBufferName <= 0 ) 
        return; 
    
    if( min == this ->m_bbMin && max == this ->m_bbMax )
        return; 
    
    this ->m_bbMin = min; 
    this ->m_bbMax = max;   
}

VolumeRayCasterAlgorithm :: VolumeRayCasterAlgorithm(VolumeOctreeConfig* defOctreeCfg, 
            VolumeRenderConfig* defVolRendCfg)
{
    myImp = new VolumeRayCasterAlgorithmImp(this, defOctreeCfg, defVolRendCfg);
}

VolumeRayCasterAlgorithm::~VolumeRayCasterAlgorithm()
{
     delete myImp;
}


void VolumeRayCasterAlgorithm::setCurrentOctreeVol(vlSparseVolumeOctreeBase* vol)
{
    myImp->myOctreeVol = vol;
    
}

void VolumeRayCasterAlgorithm::setCurrentOctreeConfig(
VolumeOctreeConfig* cfg)
{
    myImp->myVolOctreeConfig = cfg; 
}

void VolumeRayCasterAlgorithm::setCurrentVolumeRenderConfig(
VolumeRenderConfig* cfg)
{
    myImp->myVolRenderConfig = cfg; 
}

void VolumeRayCasterAlgorithm::setReferenceGeometry(Vect3f geomOrigin, Vect3i geomSize, Vect3f geomStep)
{
    myImp->myGeomOrigin = geomOrigin; 
    myImp->myGeomSize = geomSize;
    myImp->myGeomStep = geomStep; 
    myImp->myGeomDirty = false; 
}

void VolumeRayCasterAlgorithm::setActiveVolumeGeometry(Vect3f geomOrigin, Vect3i geomSize, Vect3f geomStep)
{
    myImp->myActiveVolumeOrigin = geomOrigin; 
    myImp->myActiveVolumeSize = geomSize; 
    myImp->myActiveVolumeStep = geomStep; 
    myImp->myActiveVolumeDirty = false; 
}

void VolumeRayCasterAlgorithm::setExtraVolumeGeometry(Vect3f geomOrigin, Vect3i geomSize, Vect3f geomStep)
{
    myImp->myExtraVolumeOrigin = geomOrigin; 
    myImp->myExtraVolumeSize = geomSize; 
    myImp->myExtraVolumeStep = geomStep; 
    myImp->myExtraVolumeDirty = false; 
}

void VolumeRayCasterAlgorithm::setCurrentHrzGeometry( int hid, Vect3f geomOrigin, Vect3i geomSize, Vect3f geomStep)
{
    myImp->myHrzOrigin[hid] = geomOrigin;
    myImp->myHrzSize[hid] = geomSize; 
    myImp->myHrzStep[hid] = geomStep; 
}

void VolumeRayCasterAlgorithm::setCurrentSeisGain(int gainType, Vect4f linearDivergenceGainParameter, 
                            float srate, Vect2f depthExtent)
{
    myImp->mySeisGainType = gainType; 
    myImp->myLinearDivergenceParams = linearDivergenceGainParameter; 
    myImp->mySrate = srate; 
    myImp->myDepthExtent = depthExtent; 
}
    

void VolumeRayCasterAlgorithm::resize(int x, int y)
{
    myImp->myWidth = x;
    myImp->myHeight = y; 
    myImp->myFboDirty = true; 
    myImp->mySVOFboDirty = true; 
}


bool VolumeRayCasterAlgorithm::preRenderLoop()
{
    if( !myImp->myOctreeVol)
    {
        return false; 
    }
    
    if(!myImp->myShaderInitialized)
    {
        if(!myImp->initShader() )
        {
            return false; 
        }
        myImp->myShaderInitialized = true;
    }
    
    if( myImp->m_primDirty )
    {
        if(!myImp->initBuffer())
            return false; 
        
        if(!myImp->initVertexArray())
            return false; 
        
        myImp->m_primDirty = false; 
    }
          
    if( myImp->myFboDirty )
    {
        if(!myImp ->initRenderTargets())
            return false; 
        myImp->myFboDirty = false; 
    }
    
    if(myImp->mySVOFboDirty)
    {
        if(!myImp ->initSVORenderTargets())
            return false; 
        myImp->mySVOFboDirty = false; 
    }
     
    if(myImp->myVoxelPickInvalid)
    {
        if(!myImp->initVoxelPickBuffer())
            return false; 
        myImp->myVoxelPickInvalid = false; 
    }
    
    if(myImp->myNodeBufferInvalid)
    {
        if(!myImp->initOctreeNodeBuffer())
            return false; 
        
        if(!myImp->initOctreeBrickBuffer())
            return false; 
        
        if(!myImp->initUniformBuffer())
            return false; 
        
        myImp->myNodeBufferInvalid = false; 
        myImp->myBrickBufferInvalid = false;    
    }

    if( myImp->myBrickBufferInvalid )
    {
        const size_t nodeCount = myImp->myOctreeVol -> getNumNodes(); 
        
        if(!myImp->initOctreeBrickBuffer())
            return false;                 

        if( myImp->myNodeBufferSize > 0 )
        {
            assert( myImp->myNodeBuffer); 
            assert( myImp->myOctreeNodeInfos ); 
            for( size_t i = 0; i < myImp->myNodeBufferSize; i++ )
            {
                if( myImp->myOctreeNodeInfos[i].myNodeExists )
                {
                    const vlSparseVolumeOctreeNode* node = myImp->myOctreeNodeInfos[i].myOctreeNode; 
                    assert( node ); 
                    //inbrick flag set false, use average instead
                    myImp->updateOctreeNodeBrickPointer(myImp->myNodeBuffer[i], false, 0, node->getAvgVoxelIntensities(), node ->getNumVolumes()  ); 
                }
            }
            //node buffer is dirty now, update it 
#ifndef USE_PERSISTENT_NODEBUFFER
            vlGLExt::glBindBuffer(GL_SHADER_STORAGE_BUFFER, myNodeBufferGL); 
            vlGLExt::glBufferData( GL_SHADER_STORAGE_BUFFER, sizeof(uint64_t) * nodeCount, myNodeBuffer, GL_STREAM_DRAW) ; //OR STATIC 
            /*void* ptr; 
            ptr = vlGLExt::glMapBufferRange(GL_SHADER_STORAGE_BUFFER, 0, sizeof(uint64_t) * nodeCount, GL_MAP_WRITE_BIT );
            memcpy( ptr, myNodeBuffer, sizeof(uint64_t) * nodeCount);
            vlGLExt::glUnmapBuffer(GL_SHADER_STORAGE_BUFFER); 
            */
            vlGLExt::glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);  
#else
           // vlGLExt::glBindBuffer(GL_SHADER_STORAGE_BUFFER, myNodeBufferGL); 
            size_t glNodeBufferByteSize = sizeof(uint64_t) * nodeCount;
            memcpy( (uint64_t*)myImp->myPersistentGLNodeBufferPtr, myImp->myNodeBuffer, glNodeBufferByteSize); 
           // vlGLExt::glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0); 
#endif
        }        
        myImp->myBrickBufferInvalid = false;   
    }

    if(myImp->myJitterInitialized == false)
    {
        if(!myImp->initJitteringTexture() )
            return false; 
        
        myImp->myJitterInitialized = true; 
    }
    
    if(myImp->mySamplerDirty == true)
    {
        myImp->initGLSampler(); 
        myImp->mySamplerDirty = false; 
    }
    
    if(!myImp->myTimeQueryInited)
    {
        if( myImp->initTimeQueries() ) 
            myImp->myTimeQueryInited = true; 
    }
    
    myImp->createCube(); 
       
    return true; 
}

void VolumeRayCasterAlgorithm::postRenderLoop(bool enablePick)
{ 
    //ray-guided brick usage statistics according to which advanced brick streaming scheme is designed
    myImp->updateOctreeBrickUsage(); 
    if(enablePick && myImp->myVoxelPickGL)
    { 
        size_t voxelPickBufferByteSize = sizeof(VoxelInfo) * 1;
        memcpy( myImp->myVoxelPickBuffer, (VoxelInfo*)myImp ->myPersistentPickVoxelBufferPtr, voxelPickBufferByteSize );  
    }   
#ifdef USE_PERSISTENT_NODEBUFFER     
    myImp->lockGLBuffer(myImp->myGLSyncRange[myImp->myCurrentGLSyncRangeIndex].sync); 
    myImp->myCurrentGLSyncRangeIndex = (myImp->myCurrentGLSyncRangeIndex + 1) % MAX_SYNC_BUFFER_COUNT;  
#endif  
}

void VolumeRayCasterAlgorithmImp::imageSpaceAO(const int currentReduction)
{
    //apply Ambient Occlusion on ray-casted framebuffer
    int coarsenessFactor = (int)pow((double)2, (double)currentReduction); 
    GLint viewport_bk[4];
    glGetIntegerv( GL_VIEWPORT, viewport_bk );
    Vect2i vpSize = Vect2i( myWidth/coarsenessFactor, myHeight/coarsenessFactor ); 
    
    glDisable(GL_BLEND); 
    //no depth attachement for ssao fbo, no need to set depth mask and depth bit, automatically ignore
    vlGLExt::glBindFramebufferEXT( GL_FRAMEBUFFER, mySSAOFBO[currentReduction] ); 
    glClear(GL_COLOR_BUFFER_BIT); 
    //critical. 
    glViewport(0, 0, vpSize[0], vpSize[1]); 
    
    myAmbientOcclusionTechnique->use(); 
    myAmbientOcclusionTechnique->setColorDepthTexUnitUniform(0); 
    myAmbientOcclusionTechnique->setSinglePassDepthTexUnit(1); 
    myAmbientOcclusionTechnique->setGMVPMatrix((float*)&myMVPMatrix.mat); 
    myAmbientOcclusionTechnique->setGMVMatrix((float*)&myVolumeTex2WorldMatrix.mat); 
    myAmbientOcclusionTechnique->setProjectionMatrix((float*)&myProjectionMatrix.mat);
    myAmbientOcclusionTechnique->setSampleRad(myVolumeRenderingQuality.getAOBlurRadius());
    myAmbientOcclusionTechnique->setKernelFactor(myVolumeRenderingQuality.getAOKernelScale()); 
    myAmbientOcclusionTechnique->setAOFactor(myVolumeRenderingQuality.getAOFactor());
    myAmbientOcclusionTechnique->release(); 
    
    myAmbientOcclusionTechnique->bindPipeline(); 
    glActiveTexture(GL_TEXTURE0); 
#ifdef USETEXTURE2DARRAY
    glBindTexture(GL_TEXTURE_2D_ARRAY, myRayCasterColorDepthTextureArray); 
#else
    glBindTexture(GL_TEXTURE_2D_ARRAY, myRayCasterColorDepthTextureArray[currentReduction]); 
#endif       
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, mySinglePassDepthRT.textureHandle); 
    vlGLExt::glBindVertexArray(0); 
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    glActiveTexture(GL_TEXTURE0); 
    glBindTexture(GL_TEXTURE_2D_ARRAY, 0); 
    myAmbientOcclusionTechnique->unbindPipeline(); 
    
    //gaussian filtering pass
    //may need a memory barrier. depends
    //vlGLExt::glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT|GL_TEXTURE_FETCH_BARRIER_BIT);    
    vlGLExt::glBindFramebufferEXT( GL_FRAMEBUFFER, mySSAOBlurredFBO[currentReduction] ); 
    glClear(GL_COLOR_BUFFER_BIT); 
    mySSAOBlurTechnique->use(); 
    mySSAOBlurTechnique->setSSAOTextureBindingUnit(4); 
    mySSAOBlurTechnique->setBlurTexelSize(4); 
    mySSAOBlurTechnique->release(); 
    
    mySSAOBlurTechnique->bindPipeline(); 
    glActiveTexture(GL_TEXTURE4);
    glBindTexture(GL_TEXTURE_2D, mySSAOTexture[currentReduction]); 
    vlGLExt::glBindVertexArray(0); 
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    glActiveTexture(GL_TEXTURE4);
    glBindTexture(GL_TEXTURE_2D, 0); 
    mySSAOBlurTechnique->unbindPipeline(); 
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, 0); 
    
    //reset to default state machine, or else will break normal gl rendering 
    glActiveTexture(GL_TEXTURE0);
    vlGLExt::glBindFramebufferEXT( GL_FRAMEBUFFER, 0 ); 
    glEnable(GL_BLEND); 
    glViewport(viewport_bk[0],viewport_bk[1], viewport_bk[2], viewport_bk[3]); 
}

void VolumeRayCasterAlgorithmImp::imageSpacePostProcessing(const int reduction)
{
    //a edge detection pass
    vlGLExt::glBindFramebufferEXT( GL_FRAMEBUFFER, 0 ); 
    int coarsenessFactor = (int)pow( (double)2, double(reduction) ); 
    GLint viewport_bk[4];
    glGetIntegerv( GL_VIEWPORT, viewport_bk );
    Vect2i vpSize = Vect2i( myWidth/coarsenessFactor, myHeight/coarsenessFactor ); 
        
    glDisable(GL_DEPTH_TEST);
    glDepthMask(GL_FALSE); 
    glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_FALSE); 
    glViewport(0, 0, vpSize[0], vpSize[1]); 
    
    mySobelEdgeDetectionTechnique->use(); 
    mySobelEdgeDetectionTechnique->setColorTexUnitUniform(0); 
    mySobelEdgeDetectionTechnique->setGMVPMatrix((float*)&myMVPMatrix.mat);
    mySobelEdgeDetectionTechnique->setEdgeColor(myVolumeRenderingQuality.getEdge2DColor());
    mySobelEdgeDetectionTechnique->setInnerEdgeThreshold(myVolumeRenderingQuality.getEdge2DInnerThreshold());
    mySobelEdgeDetectionTechnique->setOuterEdgeThreshold(myVolumeRenderingQuality.getEdge2DOuterThreshold());
    mySobelEdgeDetectionTechnique->setLogicOp(false); 
    mySobelEdgeDetectionTechnique->setEdgeDetectionMethod( myVolumeRenderingQuality.getEdge2DMethod()); 
    
    mySobelEdgeDetectionTechnique->release();
    mySobelEdgeDetectionTechnique->bindPipeline(); 
    glActiveTexture(GL_TEXTURE0); 
#ifdef USETEXTURE2DARRAY
    glBindTexture(GL_TEXTURE_2D_ARRAY, myRayCasterColorDepthTextureArray); 
#else
    glBindTexture(GL_TEXTURE_2D_ARRAY, myRayCasterColorDepthTextureArray[reduction]); 
#endif        
    vlGLExt::glBindVertexArray(0); 
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    glActiveTexture(GL_TEXTURE0); 
    glBindTexture(GL_TEXTURE_2D_ARRAY, 0); 
    mySobelEdgeDetectionTechnique->unbindPipeline(); 
    
    glEnable(GL_DEPTH_TEST); 
    glDepthMask(GL_TRUE); // Don't write to depth buffer
    glViewport(viewport_bk[0],viewport_bk[1], viewport_bk[2], viewport_bk[3]); 
}

void VolumeRayCasterAlgorithm::outputBackBuffer()
{
//    if(myImp->myVolumeRenderingQuality.isUseComputeShader())
//    {
//       myImp->rescaleRendering();
//    }
//    else
//    {
       myImp->rescaleRenderingFS(); 
    //}
}

bool VolumeRayCasterAlgorithm::checkEarlyExit()
{
    return myImp->isEarlyDiscardFromRenderingLoop();
}

void VolumeRayCasterAlgorithm::render(timeval t)
{
#ifdef USE_PERSISTENT_NODEBUFFER     
     myImp ->waitGLBuffer(myImp ->myGLSyncRange[myImp->myCurrentGLSyncRangeIndex].sync); 
#endif  
     
    if(myImp->myOutputPerformance)
        vlGLExt::glBeginQuery(GL_TIME_ELAPSED, myImp->myTimeQueries[1]); 
    
    //auto refinement mode
    if(myImp ->myVolRenderConfig->getInteractiveMode() == AUTO )
    {
        myImp -> psuedoVsgAdpRefinement(t); 
    }
    else
    {
        myImp ->inVoxelRender(t);
        glEnable(GL_CULL_FACE);
        glCullFace(GL_BACK);
        glEnable(GL_BLEND); 
        glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); 
        glEnable( GL_DEPTH_TEST); 
        glDepthFunc(GL_LESS); 
        if(myImp->myVolumeRenderingQuality.isUseAmbientOcclusion())
            myImp->imageSpaceAO(myImp->myVolRenderConfig->getScreenResolutionReduction()); 
        outputBackBuffer();
    }

    //edge detection, screen-space
    if(myImp->myVolumeRenderingQuality.isUseEdge2D())
        myImp->imageSpacePostProcessing(0);     
    if(myImp->myOutputPerformance)
        vlGLExt::glEndQuery(GL_TIME_ELAPSED);
    
    if(myImp->myOutputPerformance)
    {
       vlGLExt::glGetQueryObjectui64v(myImp->myTimeQueries[1], GL_QUERY_RESULT, &myImp->inVoxelRenderTime);
       myImp->myVRProfile.append(myImp->inVoxelRenderTime/1000000);
    }
}

void VolumeRayCasterAlgorithm::updateBoundingBoxRange(Vect3f minNormf, Vect3f maxNormf)
{
    this->myImp->updateBoundingBoxRange(minNormf, maxNormf); 
}
 
void VolumeRayCasterAlgorithm::renderSlices(Vect3f, Vect3i, Vect3f, Vect3f, Vect3i, Vect3f)
{
    //a test function for rendering slice by using shader
    if(myImp ->myOctreeVol == NULL)
        return; 
     
    glEnable(GL_BLEND); 
    glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); 
    
    //basic ortho slice, traverse slice and fence slice all belonging to orthoslice 
    vector<vlSceneGraphNode*> orthoSliceNode; 
    vlSceneGraphManager::getInstance()->getSceneGraphNodesByComponent(ORTHOSLICE, orthoSliceNode);
    for (vector<vlSceneGraphNode*>::const_iterator iterator = orthoSliceNode.begin(), end = orthoSliceNode.end(); iterator != end; ++iterator) 
    {
        OrthoSliceRenderable* renderer = dynamic_cast<OrthoSliceRenderable*>( (*iterator) -> getComponent(ORTHOSLICE) ); 
        if(renderer)
            renderer->updateGL();
    }
    
    vector<vlSceneGraphNode*> curvedSliceNode; 
    vlSceneGraphManager::getInstance()->getSceneGraphNodesByComponent(CURVESLICE, curvedSliceNode);
    for (vector<vlSceneGraphNode*>::const_iterator iterator = curvedSliceNode.begin(), end = curvedSliceNode.end(); iterator != end; ++iterator) 
    {
        CurvedSliceRenderable* renderer = dynamic_cast<CurvedSliceRenderable*>( (*iterator) -> getComponent(CURVESLICE) ); 
        if(renderer)
            renderer->updateGL();
    }
    
    myImp->myGLSync_TSBufferData = vlGLExt::glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0); 
    
    for (vector<vlSceneGraphNode*>::const_iterator iterator = orthoSliceNode.begin(), end = orthoSliceNode.end(); iterator != end; ++iterator) 
    {
        OrthoSliceRenderable* renderer = dynamic_cast<OrthoSliceRenderable*>( (*iterator) -> getComponent(ORTHOSLICE) ); 
        if(renderer)
            myImp->renderBasicSliceShadingPass(renderer);
    }
   
    for (vector<vlSceneGraphNode*>::const_iterator iterator = curvedSliceNode.begin(), end = curvedSliceNode.end(); iterator != end; ++iterator) 
    {
        CurvedSliceRenderable* renderer = dynamic_cast<CurvedSliceRenderable*>( (*iterator) -> getComponent(CURVESLICE) ); 
        if(renderer)
            myImp->renderCurvedFenceSliceShadingPass(renderer);
    }
   
        
    GLint64 MaxTimeout(2000); 
    GLenum Result = vlGLExt::glClientWaitSync(myImp->myGLSync_TSBufferData, GL_SYNC_FLUSH_COMMANDS_BIT, (GLuint64)MaxTimeout);  
}

Matrixf VolumeRayCasterAlgorithm::getViewProjectionMatrix() const
{
    return  myImp->myMVPMatrix; 
}

void VolumeRayCasterAlgorithm::updateMatrix(timeval cur_t, 
        Matrixf& mvpMat, 
#ifdef USE_DOUBLEPRECISION
        Matrixd& mvpMatd, 
#endif
        Matrixf& mvMat, 
        Matrixf& prjMat, 
        Matrixf& imvpMat, 
        Matrixf& imvMat, 
        Matrixf& iprjMat, 
        double& width, double& height, double& depth)
{
    myImp->myViewVolume = Vect3f(width,  height, depth); 
    bool mvpChanged = false; 
    Matrixf oldMVPMatrix = myImp->myMVPMatrix; 
    
    myImp->myMVPMatrix  =  mvpMat;
#ifdef USE_DOUBLEPRECISION
    myImp ->myMVPMatrixd = mvpMatd; 
#endif
    myImp->myMVPMatrixInverse = mvpMat;
            //imvpMat;
    myImp->myMVMatrixInverse = imvMat; 
    myImp->myProjMatrixInverse = iprjMat;
    myImp->myVolumeTex2WorldMatrix = mvMat;
    myImp->myProjectionMatrix = prjMat; 
    
    for( int i = 0; i < 16; i++)
    {
        if(oldMVPMatrix[i] != myImp->myMVPMatrix[i])
        {
            mvpChanged = true; 
            break; 
        }
    }
    //once modelviewprojectoion has changed, need to switch to begin of interaction under auto mode
    if(mvpChanged)
    {
        myImp ->resetRenderState(); 
        myImp->myVolRenderConfig->endStopInteraction(cur_t); 
    }
    else
    {
        myImp->myVolRenderConfig->startStopInteraction(cur_t);
    }

}

void VolumeRayCasterAlgorithm::setBasicSliceVis(int axis, bool flag)
{
    char key[128]; 
    sprintf(key, "Ortho_%d", axis); 
    
    vector<vlSceneGraphNode*> nodes;
    vlSceneGraphManager::getInstance()-> getSceneGraphNodesByName(vString(key), nodes);    
    for(int i = 0; i < nodes.size(); i++)
    {
        OrthoSliceRenderable* ortho = dynamic_cast<OrthoSliceRenderable*>( nodes[i]->getComponent(ORTHOSLICE ) ); 
        assert(ortho); 
        ortho->setVisible(flag); 
    }
}

void VolumeRayCasterAlgorithm::setAllShowSeismic(bool flag)
{
    vector<vlSceneGraphNode*> orthoSliceNode; 
    vlSceneGraphManager::getInstance()->getSceneGraphNodesByComponent(ORTHOSLICE, orthoSliceNode);
    for (vector<vlSceneGraphNode*>::const_iterator iterator = orthoSliceNode.begin(), end = orthoSliceNode.end(); iterator != end; ++iterator) 
    {
        OrthoSliceRenderable* renderer = dynamic_cast<OrthoSliceRenderable*>( (*iterator) -> getComponent(ORTHOSLICE) ); 
        if(renderer)
            renderer->setShowSeismicChannel( flag ); 
    }
    vector<vlSceneGraphNode*> curvedSliceNode; 
    vlSceneGraphManager::getInstance()->getSceneGraphNodesByComponent(CURVESLICE, curvedSliceNode);
    for (vector<vlSceneGraphNode*>::const_iterator iterator = curvedSliceNode.begin(), end = curvedSliceNode.end(); iterator != end; ++iterator) 
    {
        CurvedSliceRenderable* renderer = dynamic_cast<CurvedSliceRenderable*>( (*iterator) -> getComponent(CURVESLICE) ); 
        if(renderer)
            renderer->setShowSeismicChannel( flag ); 
    }
    
}
void VolumeRayCasterAlgorithm::setAllShowAttribute(bool flag)
{
    vector<vlSceneGraphNode*> orthoSliceNode; 
    vlSceneGraphManager::getInstance()->getSceneGraphNodesByComponent(ORTHOSLICE, orthoSliceNode);
    for (vector<vlSceneGraphNode*>::const_iterator iterator = orthoSliceNode.begin(), end = orthoSliceNode.end(); iterator != end; ++iterator) 
    {
        OrthoSliceRenderable* renderer = dynamic_cast<OrthoSliceRenderable*>( (*iterator) -> getComponent(ORTHOSLICE) ); 
        if(renderer)
            renderer->setShowAttributeChannel( flag ); 
    }
    vector<vlSceneGraphNode*> curvedSliceNode; 
    vlSceneGraphManager::getInstance()->getSceneGraphNodesByComponent(CURVESLICE, curvedSliceNode);
    for (vector<vlSceneGraphNode*>::const_iterator iterator = curvedSliceNode.begin(), end = curvedSliceNode.end(); iterator != end; ++iterator) 
    {
        CurvedSliceRenderable* renderer = dynamic_cast<CurvedSliceRenderable*>( (*iterator) -> getComponent(CURVESLICE) ); 
        if(renderer)
            renderer->setShowAttributeChannel( flag ); 
    }
}

void VolumeRayCasterAlgorithm::updateBasicSliceNode(int id, int type, Vect4d bgn, Vect4d end, float* texture, Vect2i texSize, bool visibility, 
        bool isShowSeis, bool isShowAttr)
{
    myImp->updateBasicSliceNodeImp(id, type, bgn, end, texture, texSize, visibility, isShowSeis, isShowAttr); 
}

void VolumeRayCasterAlgorithm::updateTraverseSliceNode(int id, int type, Vect4d bgn, Vect4d end, float* texture, Vect2i texSize, bool visibility, 
        bool isShowSeis, bool isShowAttr)
{
    myImp->updateTraverseSliceNodeImp(id, type, bgn, end, texture, texSize, visibility, isShowSeis, isShowAttr); 
}

void VolumeRayCasterAlgorithm::updateFenceSliceNode(int setid, int id, int type, Vect4d bgn, Vect4d end, float* texture, Vect2i texSize, bool visibility, 
        bool isShowSeis, bool isShowAttr)
{
    myImp->updateFenceSliceNodeImp(setid, id, type, bgn, end, texture, texSize, visibility, isShowSeis, isShowAttr); 
}

void VolumeRayCasterAlgorithm::updateCurrentFenceSet(int curSetId)
{
    myImp->updateCurrentFenceSetImp(curSetId);
}

void VolumeRayCasterAlgorithm::updateCurvedFenceSliceNode(int id, int type, vector<Vect4d>& pts, vector<float*>& traces, 
        double zOrig, double zStep, int numZSamples, Matrixd l2g, bool visibility, bool isShowSeis, bool isShowAttr )
{
    myImp->updateCurvedFenceSliceNodeImp(id, type, pts, traces, zOrig, zStep, numZSamples, l2g, visibility, isShowSeis, isShowAttr); 
}

void VolumeRayCasterAlgorithm::attachBasicSliceNodeExtraVolChannel(int id, bool f)
{
    char key[128]; 
    sprintf(key, "Ortho_%d", id); 
    
    vector<vlSceneGraphNode*> nodes;
    vlSceneGraphManager::getInstance()-> getSceneGraphNodesByName(vString(key), nodes);    
    assert(nodes.size() == 1); 
    OrthoSliceRenderable* ortho = dynamic_cast<OrthoSliceRenderable*>( nodes[0]->getComponent(ORTHOSLICE ) ); 
    ortho->setHasExtraVolComponent(f);  
    
}

void VolumeRayCasterAlgorithm::attachTraverseSliceNodeExtraVolChannel(int id, bool f)
{
    char key[128]; 
    sprintf(key, "Traverse_%d", id); 
    
    vector<vlSceneGraphNode*> nodes;
    vlSceneGraphManager::getInstance()-> getSceneGraphNodesByName(vString(key), nodes);    
    assert(nodes.size() == 1); 
    OrthoSliceRenderable* ortho = dynamic_cast<OrthoSliceRenderable*>( nodes[0]->getComponent(ORTHOSLICE ) ); 
    ortho->setHasExtraVolComponent(f);
}

void VolumeRayCasterAlgorithm::attachFenceSliceNodeExtraVolChannel(int setId , int id, bool f)
{
    char key[128]; 
    sprintf(key, "Fence_%d_%d", setId, id); 
    
    vector<vlSceneGraphNode*> nodes;
    vlSceneGraphManager::getInstance()-> getSceneGraphNodesByName(vString(key), nodes);    
    assert(nodes.size() == 1); 
    OrthoSliceRenderable* ortho = dynamic_cast<OrthoSliceRenderable*>( nodes[0]->getComponent(ORTHOSLICE ) ); 
    ortho->setHasExtraVolComponent(f);
}

void VolumeRayCasterAlgorithm::attachCurvedFenceNodeExtraVolChannel(int id, bool f)
{
    char key[128]; 
    sprintf(key, "CurvedFence_%d", id); 
    
    vector<vlSceneGraphNode*> nodes;
    vlSceneGraphManager::getInstance()-> getSceneGraphNodesByName(vString(key), nodes);    
    assert(nodes.size() == 1); 
    CurvedSliceRenderable* curve = dynamic_cast<CurvedSliceRenderable*>( nodes[0]->getComponent(CURVESLICE ) ); 
    assert(curve); 
    curve->setHasExtraVolComponent(f);
}


void VolumeRayCasterAlgorithm::deleteCurvedFenceSliceNode(int id)
{
    myImp->deleteCurvedFenceSliceNodeImp(id); 
}
void VolumeRayCasterAlgorithm::deleteBasicSliceNode(int id)
{
    //tornado never delete three basic ortho slice?
}
void VolumeRayCasterAlgorithm::deleteTraverseSliceNode(int id)
{
    myImp->deleteTraverseSliceNodeImp(id); 
}

void VolumeRayCasterAlgorithm::deleteFenceSliceNode(int setId)
{
    myImp->deleteFenceSliceNodeImp(setId); 
}

void VolumeRayCasterAlgorithmImp::updateBasicSliceNodeImp(int id, int type, Vect4d bgn, Vect4d end, float* texture, Vect2i texSize, bool visibility, 
             bool isShowSeis, bool isShowAttr)
{
    char key[128]; 
    sprintf(key, "Ortho_%d", id); 
    
    vector<vlSceneGraphNode*> nodes;
    vlSceneGraphManager::getInstance()-> getSceneGraphNodesByName(vString(key), nodes); 
     
    assert(nodes.size() == 1); 
    OrthoSliceRenderable* ortho = dynamic_cast<OrthoSliceRenderable*>( nodes[0]->getComponent(ORTHOSLICE ) ); 
    ortho->update(type, bgn, end, texture, texSize, visibility, isShowSeis, isShowAttr);
}

void VolumeRayCasterAlgorithmImp::updateTraverseSliceNodeImp(int id, int type, Vect4d bgn, Vect4d end, float* texture, Vect2i texSize, bool visibility, 
             bool isShowSeis, bool isShowAttr)
{
    char key[128]; 
    sprintf(key, "Traverse_%d", id); 
    
    vector<vlSceneGraphNode*> nodes;
    vlSceneGraphManager::getInstance()-> getSceneGraphNodesByName(vString(key), nodes); 
     
    assert(nodes.size() == 1); 
    OrthoSliceRenderable* ortho = dynamic_cast<OrthoSliceRenderable*>( nodes[0]->getComponent(ORTHOSLICE ) ); 
    ortho->update(type, bgn, end, texture, texSize, visibility, isShowSeis, isShowAttr);

}

void VolumeRayCasterAlgorithmImp::updateFenceSliceNodeImp(int setid, int id, int type, Vect4d bgn, Vect4d end, float* texture, Vect2i texSize, bool visibility, 
             bool isShowSeis, bool isShowAttr)
{
    char key[128]; 
    sprintf(key, "Fence_%d_%d", setid, id); 
    
    vector<vlSceneGraphNode*> nodes;
    vlSceneGraphManager::getInstance()-> getSceneGraphNodesByName(vString(key), nodes); 
     
    assert(nodes.size() == 1); 
    OrthoSliceRenderable* ortho = dynamic_cast<OrthoSliceRenderable*>( nodes[0]->getComponent(ORTHOSLICE ) ); 
    ortho->update(type, bgn, end, texture, texSize, visibility, isShowSeis, isShowAttr);
}

void VolumeRayCasterAlgorithmImp::updateCurrentFenceSetImp( int curSetId )
{
    vector<vlSceneGraphNode*> nodes;
    vlSceneGraphManager::getInstance()-> getSceneGraphNodesByNamePrefix(vString("Fence"), nodes); 
    for(vector<vlSceneGraphNode*>::iterator itr = nodes.begin(); itr!= nodes.end(); ++itr)
    {
        int fenceId = -1;
        int setId = -1; 
        sscanf ( (*itr)->getName().c_str(), "Fence_%d_%d", &setId, &fenceId);
        assert(fenceId >= 0 && setId >= 0); 
       
        OrthoSliceRenderable* ortho = dynamic_cast<OrthoSliceRenderable*>(( *itr )->getComponent(ORTHOSLICE ) ); 
        assert(ortho);      
        ortho-> setVisible(setId == curSetId); 
    }
}

void VolumeRayCasterAlgorithmImp::updateCurvedFenceSliceNodeImp(int id, int type, vector<Vect4d>& pts, vector<float*>& traces, 
                                                                double zOrig, double zStep, int numZSamples, Matrixd l2g, 
                                                                bool visibility, bool isShowSeis, bool isShowAttr)
{
    
    char key[128]; 
    sprintf(key, "CurvedFence_%d", id); 
    
    vector<vlSceneGraphNode*> nodes;
    vlSceneGraphManager::getInstance()-> getSceneGraphNodesByName(vString(key), nodes); 
     
    assert(nodes.size() == 1); 
    CurvedSliceRenderable* curved = dynamic_cast<CurvedSliceRenderable*>( nodes[0]->getComponent(CURVESLICE ) ); 
    assert(curved); 
    curved->update(type, pts, traces, zOrig, zStep, numZSamples, l2g, visibility, isShowSeis, isShowAttr);
}

void VolumeRayCasterAlgorithmImp::deleteTraverseSliceNodeImp(int id)
{
    char key[128]; 
    sprintf(key, "Traverse_%d", id); 
    vector<vlSceneGraphNode*> nodes;
    vlSceneGraphManager::getInstance()-> getSceneGraphNodesByName(vString(key), nodes); 
    if(nodes.size() > 0)
    {
        assert(nodes.size() == 1); 
        delete nodes[0]; 
        nodes.resize(0); 
        vlSceneGraphManager::getInstance()-> getSceneGraphNodesByNamePrefix(vString("Traverse"), nodes); 

        for(vector<vlSceneGraphNode*>::iterator itr = nodes.begin(); itr!= nodes.end(); ++itr)
        {
            int TraverseId = -1;
            sscanf ( (*itr)->getName().c_str(), "Traverse_%d", &TraverseId);
            assert(TraverseId >= 0); 

            if(TraverseId > id)
            {
                sprintf(key, "Traverse_%d", TraverseId - 1); 
                vString name(key); 
                (*itr)->setName(name); 
            }
        }
    }
}

void VolumeRayCasterAlgorithmImp::deleteFenceSliceNodeImp(int setId)
{
    char key[128]; 
    sprintf(key, "Fence_%d", setId); 
    
    vector<vlSceneGraphNode*> nodes;
    vlSceneGraphManager::getInstance()-> getSceneGraphNodesByNamePrefix(vString(key), nodes); 
    for(vector<vlSceneGraphNode*>::iterator itr = nodes.begin(); itr!= nodes.end(); ++itr)
    {
        delete *itr; 
    }
}

void VolumeRayCasterAlgorithmImp::deleteCurvedFenceSliceNodeImp(int id)
{
    char key[128]; 
    sprintf(key, "CurvedFence_%d", id); 
    vector<vlSceneGraphNode*> nodes;
    vlSceneGraphManager::getInstance()-> getSceneGraphNodesByName(vString(key), nodes); 
    if(nodes.size() > 0)
    {
        assert(nodes.size() == 1); 
        delete nodes[0]; 
        nodes.resize(0); 
        vlSceneGraphManager::getInstance()-> getSceneGraphNodesByNamePrefix(vString("CurvedFence"), nodes); 

        for(vector<vlSceneGraphNode*>::iterator itr = nodes.begin(); itr!= nodes.end(); ++itr)
        {
            int CurvedFenceId = -1;
            sscanf ( (*itr)->getName().c_str(), "CurvedFence_%d", &CurvedFenceId);
            assert(CurvedFenceId >= 0); 

            if(CurvedFenceId > id)
            {
                sprintf(key, "CurvedFence_%d", CurvedFenceId - 1); 
                vString name(key); 
                (*itr)->setName(name); 
            }
        }
    }
}

void VolumeRayCasterAlgorithm::updateCameraEye(Vect3f eyePos, Vect3f lightPos)
{
    myImp->myCameraEyePosition = eyePos; 
    myImp->myLightPosition = lightPos; 
}


GLuint& VolumeRayCasterAlgorithm :: getExtraTransferFunctionTexture()
{
    return myImp->getExtraTransferFunctionTexture(); 
}

GLuint& VolumeRayCasterAlgorithm::getTransferFunctionTextureArray( ) 
{
    return myImp->getTransferFunctionTextureArray(); 
}

GLuint& VolumeRayCasterAlgorithm::getOpacitySATArray()
{
    return myImp->getOpacitySATArray(); 
}

RenderTargetTextureWrapper& VolumeRayCasterAlgorithm::getSinglePassDepthRT()
{
    return myImp->mySinglePassDepthRT;
}

void VolumeRayCasterAlgorithm::setExtraVolDataTFRange( Vect2f tfRange, 
        Vect2f dataRange ) 
{
    myImp->myTfRangeExtraVol = tfRange; 
    myImp->myDataRangeExtraVol = dataRange; 
}

void VolumeRayCasterAlgorithm::setSeisVolDataTFRange( Vect2f tfRange, 
        Vect2f dataRange ) 
{
    myImp->myTfRangeSeismic = tfRange; 
    myImp->myDataRangeSeismic = dataRange; 
}

void VolumeRayCasterAlgorithm::setAttrVolDataTFRange( Vect2f tfRange, 
        Vect2f dataRange ) 
{
    myImp->myTfRangeAttribute = tfRange; 
    myImp->myDataRangeAttribute = dataRange; 
}

void VolumeRayCasterAlgorithm::setEnvelopeDirty(bool flag)
{
    myImp->myEnvelopeIsDirty = flag ; 
}

GLuint& VolumeRayCasterAlgorithm::getClippingHrzTex2D(int hid)
{
    if(myImp->myClippingHrzTex2D[hid] == 0)
        vlGLExt::glGenTextures(1, &myImp->myClippingHrzTex2D[hid]); 

    return myImp->myClippingHrzTex2D[hid]; 
}
 
GLuint& VolumeRayCasterAlgorithm::getSSAOTex2D(const int reduction)
{
    return myImp->mySSAOTexture[reduction]; 
}
GLuint& VolumeRayCasterAlgorithm::getSSAOBlurredTex2D(const int reduction)
{
    return myImp->mySSAOBlurredTexture[reduction]; 
}

void  VolumeRayCasterAlgorithm::setSSAOUseBlurredPass(bool f)
{
    myImp->myUseAOBlurPass = f; 
}

bool  VolumeRayCasterAlgorithm::isSSAOUseBlurredPass() const
{
    return myImp->myUseAOBlurPass;
}
 
 void VolumeRayCasterAlgorithm::invalidateNodeBuffer()
 {
     myImp->invalidateNodeBuffer();
 }
 
 void VolumeRayCasterAlgorithm::invalidateBrickBuffer()
 {
     myImp->invalidateBrickBuffer(); 
 }
 
 void VolumeRayCasterAlgorithm::resetRenderState()
 {
     myImp->resetRenderState(); 
 } 

 void VolumeRayCasterAlgorithm::invalidateStreamSliceTexture()
 {
    //myImp->invalidateStreamSliceTexture(); 
 }
 void VolumeRayCasterAlgorithm::invalidateExtraVolTransferFunction()
 {
     myImp->invalidateExtraVolTransferFunction(); 
 }
 void VolumeRayCasterAlgorithm::setPerformanceOutput(bool flag)
 { 
     myImp->myOutputPerformance = flag; 
 }
 
 bool VolumeRayCasterAlgorithm::isPerformanceOutput() const
 {
     return myImp->myOutputPerformance; 
 }
 
 GLuint& VolumeRayCasterAlgorithm::getVoxelPickGL() const
 {
     return myImp->myVoxelPickGL;
 }
 
VoxelInfo* VolumeRayCasterAlgorithm::getVoxelPickBuffer() const
{
    return myImp->myVoxelPickBuffer;
}
 
void VolumeRayCasterAlgorithm::setLightProperty(Vect4f a, Vect4f d, Vect4f s)
{
    myImp->myVolumeRenderingQuality.setLightAmbientColor(a); 
    myImp->myVolumeRenderingQuality.setLightDiffuseColor(d);       
    myImp->myVolumeRenderingQuality.setLightSpecularColor(s);   
}

vlVolumeRenderingQuality& VolumeRayCasterAlgorithm::getVolRendQuality()
{
    return myImp->myVolumeRenderingQuality; 
}
 
vlGLSLTechnique* VolumeRayCasterAlgorithm::getFullScreenCopyTex2dTechnique()
{
    return myImp->myFullScreenCopyTex2dTechnique; 
}
  
vlGLSLTechnique* VolumeRayCasterAlgorithm::getDrawWellLogZPassTechnique()
{
    return myImp->myDrawWellLogZPassTechnique; 
}

void VolumeRayCasterAlgorithm::initializeGridBuffer()
{
    myImp->initializeGridBuffer(); 
}

void VolumeRayCasterAlgorithm::initializeGridDimension()
{
    myImp->initializeGridDimension(); 
}

Vect3i VolumeRayCasterAlgorithm::getGridDim() const
{
    return myImp->myGridDim;
}

Vect3i VolumeRayCasterAlgorithm::getVoxelsPerCell() const
{
    return myImp->myVoxelsPerCell;
}

void VolumeRayCasterAlgorithm::updateGridTexture(GLuint texHandle)
{
    myImp->myGridTexture3D = texHandle; 
}

void VolumeRayCasterAlgorithm::createProxyCube()
{
    myImp->createCube(); 
}

bool VolumeRayCasterAlgorithm::exportBinaryShader()
{
    return myImp->exportBinaryShader(); 
}

void VolumeRayCasterAlgorithm::logVolRendProfile()
{
    return myImp->logVolRendProfile(); 
}

void VolumeRayCasterAlgorithm::setRGBAMode(bool f)
{
    myImp->myIsRGBAMode =  f; 
}

void VolumeRayCasterAlgorithmImp::updateOctreeBrickUsage()
{
    //downloading octree node usage information back to app side. 
    int tmpIdx;  
    tmpIdx = (myCurrentGLSyncRangeIndex + MAX_SYNC_BUFFER_COUNT - 1 ) % MAX_SYNC_BUFFER_COUNT;
        
#ifdef USE_PERSISTENT_NODEBUFFER
    if(myBrickUsageBufferGL)
    {     
        size_t usageBufferByteSize = sizeof(uint8_t) * this ->myOctreeVol->getNumNodes();   
        size_t offset = tmpIdx * usageBufferByteSize;  
        memcpy( myBrickUsageBuffer, (uint8_t*)this ->myPersistentBufferUsageMapPtr +  offset, usageBufferByteSize );           
    }
#else
    if(myBrickUsageBufferGL)
    { 
        vlGLExt::glBindBuffer(GL_SHADER_STORAGE_BUFFER, myBrickUsageBufferGL);  
        size_t usageBufferByteSize = sizeof(uint8_t) * this ->myOctreeVol->getNumNodes();
        void* brickUsageBufferPtr = vlGLExt::glMapBufferRange( GL_SHADER_STORAGE_BUFFER, 0, usageBufferByteSize, GL_MAP_READ_BIT); 
        memcpy( myBrickUsageBuffer, brickUsageBufferPtr, usageBufferByteSize ); 
        /*
        for(int j = 0; j < this ->myOctreeVol->getNumNodes(); j++)
        {
            //if( *(myBrickUsageBuffer + j) > 0)
           // fprintf(stderr, "nodeId: %d, usage:%d\n", j,  *(myBrickUsageBuffer + j)  );
        }*/
        vlGLExt::glUnmapBuffer(GL_SHADER_STORAGE_BUFFER); 
        vlGLExt::glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);     
        checkError( " download brickUsageBufferGL "); 
    }       
#endif 
}

//streaming octree brick pool at frame i based on brick pool usage information at frame i-1
size_t VolumeRayCasterAlgorithmImp::updateOctreeBrickPools(size_t lodNodeLevel)
{
    //upload bricks   
    size_t numBricksUsed = 0; 
    size_t numBricksRequested = 0; 
    size_t numBricksUploaded = 0; 
    size_t numSlotOccupied = 0; 
    
    if(  (myRenderState > RENDER_STATE_FIRST_INTERACTION_FRAME ) && (myRenderState > RENDER_STATE_INTERACTION_FRAME  || (myVolRenderConfig->isUploadBrickDuringInteraction() == true ) ))
    {
        //
        int keepLevel = -1;  //
        //keep interaction 
        if(  myVolRenderConfig->isKeepInteractionBricks() )
        {
            keepLevel = (int)myOctreeVol->getTreeDepth() - 1 - (int)(lodNodeLevel) ; // low level bricks need to keep , 
            //keepLevel = (int)myOctreeVol->getSparseTreeDepth() -1 - (int)(nodeLevel) ;
            while( keepLevel < myOctreeVol -> getTreeDepth() )
            //while( keepLevel < myOctreeVol -> getSparseTreeDepth() )
            {
                size_t numBricksKept = 0; 
                
                for( size_t level = keepLevel; level < myOctreeVol->getTreeDepth(); level++ )
                //for( size_t level = keepLevel; level < myOctreeVol->getSparseTreeDepth(); level++ )
                {
                    assert( level < this ->myLRUBricks.size() ); 
                    numBricksKept += this ->myLRUBricks.at(level).size(); 
                }
                if(numBricksKept <= (this ->myNumBrickBufferSlots / 2 )) 
                    break; 
                else 
                    keepLevel++; 
            }
            
            assert( keepLevel >= 0 && keepLevel <= (int)myOctreeVol->getTreeDepth() ); 
           // assert( keepLevel >= 0 && keepLevel <= (int)myOctreeVol->getSparseTreeDepth() ); 
        }     
        this ->updateOctreeBrickBuffer(keepLevel, numBricksUsed, numBricksRequested, numBricksUploaded, numSlotOccupied);
    }
    
    size_t numLRU = 0; 
    for( size_t i = 0; i < this ->myLRUBricks.size(); i++ )
    {
        numLRU += myLRUBricks.at(i).size() ; 
    }
    
    if(numBricksUploaded > 0)
    {
        fprintf(stderr, "Num Tile Requested:%d, Uploaded: %d\n",numBricksRequested, numBricksUploaded);
    }
    
    return numBricksUploaded; 
}

void VolumeRayCasterAlgorithmImp::updateRenderState(const size_t& numBricksUploaded, RenderState& curState,
                            RenderState& nextState, DisplayMode& displayMode)
{
    nextState = curState;
    if( curState == RENDER_STATE_FIRST_INTERACTION_FRAME )
    {
        displayMode = FULL_FRAME; 
        nextState = RENDER_STATE_INTERACTION_FRAME; 
    }
    
    if( curState == RENDER_STATE_INTERACTION_FRAME )
    {
        displayMode = FULL_FRAME;   
    }
    
    if( curState == RENDER_STATE_FIRST_FULL_FRAME)
    {
        displayMode = FULL_FRAME; 
        nextState = RENDER_STATE_FULL_FRAME; 
    }
    
    if( curState == RENDER_STATE_FULL_FRAME )
    {
        if( numBricksUploaded == 0 )
        {
            //todo 
            if(myVolRenderConfig->isUseIterativeRefinement() )
                curState = RENDER_STATE_FIRST_ITERATIVE_FRAME; 
            else
                curState = RENDER_STATE_FINISHED;
        }
        else
        {
            displayMode = FULL_FRAME; 
        }
    }
    
    if( curState == RENDER_STATE_FIRST_ITERATIVE_FRAME )
    {
        displayMode = REFINEMENT; 
        nextState = RENDER_STATE_ITERATIVE_FRAME; 
    }
    
    if( curState == RENDER_STATE_ITERATIVE_FRAME )
    {
        if( numBricksUploaded == 0 ){
            //todo 
            curState = RENDER_STATE_FINISHED; 
        }
        else
        {
            displayMode = REFINEMENT; 
        }
    }
}

void VolumeRayCasterAlgorithm::preRenderTornadoOpaque()
{
    myImp->preRenderTornadoOpaque(); 
}

void VolumeRayCasterAlgorithm::postRenderTornadoOpaque()
{
    myImp->postRenderTornadoOpaque(); 
}

void VolumeRayCasterAlgorithmImp::preRenderTornadoOpaque()
{
    if(myEnvelopeIsDirty && myVolRenderConfig->isUseGrid())
        computeEnvelope(); 
    
    if(!mySinglePassDepthBoundTechnique)
        return; 

    renderDualDepthPeel(); 

//    //stream 
//    for (std::list<OrthoSliceRenderable*>::const_iterator iterator = myBasicSliceList.begin(), end = myBasicSliceList.end(); iterator != end; ++iterator) 
//    {
//        (*iterator) -> updateGL();
//    } 
//    for (std::list<OrthoSliceRenderable*>::const_iterator iterator = myTraverseSliceList.begin(), end = myTraverseSliceList.end(); iterator != end; ++iterator) 
//    {
//        (*iterator) -> updateGL();
//    }   
//    for (std::list<OrthoSliceRenderable*>::const_iterator iterator = myFenceSliceList.begin(), end = myFenceSliceList.end(); iterator != end; ++iterator) 
//    {
//        (*iterator) -> updateGL();
//    }  
//    for (std::list<CurvedSliceRenderable*>::const_iterator iterator = myCurvedSliceList.begin(), end = myCurvedSliceList.end(); iterator != end; ++iterator) 
//    {
//        (*iterator) -> updateGL();
//    }     
    vector<vlSceneGraphNode*> orthoSliceNode; 
    vlSceneGraphManager::getInstance()->getSceneGraphNodesByComponent(ORTHOSLICE, orthoSliceNode);
    for (vector<vlSceneGraphNode*>::const_iterator iterator = orthoSliceNode.begin(), end = orthoSliceNode.end(); iterator != end; ++iterator) 
    {
        OrthoSliceRenderable* renderer = dynamic_cast<OrthoSliceRenderable*>( (*iterator) -> getComponent(ORTHOSLICE) ); 
        if(renderer)
            renderer->updateGL();
    }
    vector<vlSceneGraphNode*> curvedSliceNode; 
    vlSceneGraphManager::getInstance()->getSceneGraphNodesByComponent(CURVESLICE, curvedSliceNode);
    for (vector<vlSceneGraphNode*>::const_iterator iterator = curvedSliceNode.begin(), end = curvedSliceNode.end(); iterator != end; ++iterator) 
    {
        CurvedSliceRenderable* renderer = dynamic_cast<CurvedSliceRenderable*>( (*iterator) -> getComponent(CURVESLICE) ); 
        if(renderer)
            renderer->updateGL();
    }
    
    myGLSync_TSBufferData = vlGLExt::glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0); 
    
    for (vector<vlSceneGraphNode*>::const_iterator iterator = orthoSliceNode.begin(), end = orthoSliceNode.end(); iterator != end; ++iterator) 
    {
        OrthoSliceRenderable* renderer = dynamic_cast<OrthoSliceRenderable*>( (*iterator) -> getComponent(ORTHOSLICE) ); 
        if(renderer)
            renderBasicSlicePreZPass(renderer);
    }
   
    for (vector<vlSceneGraphNode*>::const_iterator iterator = curvedSliceNode.begin(), end = curvedSliceNode.end(); iterator != end; ++iterator) 
    {
        CurvedSliceRenderable* renderer = dynamic_cast<CurvedSliceRenderable*>( (*iterator) -> getComponent(CURVESLICE) ); 
        if(renderer)
            renderCurvedFenceSlicePreZPass(renderer);
    }
    
//    for (std::list<OrthoSliceRenderable*>::const_iterator iterator = myBasicSliceList.begin(), end = myBasicSliceList.end(); iterator != end; ++iterator) 
//    {
//        this->renderBasicSlicePreZPass(*iterator);
//    }    
//    for (std::list<OrthoSliceRenderable*>::const_iterator iterator = myTraverseSliceList.begin(), end = myTraverseSliceList.end(); iterator != end; ++iterator) 
//    {
//        this->renderBasicSlicePreZPass(*iterator);
//    }   
//    for (std::list<OrthoSliceRenderable*>::const_iterator iterator = myFenceSliceList.begin(), end = myFenceSliceList.end(); iterator != end; ++iterator) 
//    {
//        this->renderBasicSlicePreZPass(*iterator);
//    }  
//    for (std::list<CurvedSliceRenderable*>::const_iterator iterator = myCurvedSliceList.begin(), end = myCurvedSliceList.end(); iterator != end; ++iterator) 
//    {
//        renderCurvedFenceSlicePreZPass(*iterator);
//    } 
    GLint64 MaxTimeout(2000); 
    GLenum Result = vlGLExt::glClientWaitSync(myGLSync_TSBufferData, GL_SYNC_FLUSH_COMMANDS_BIT, (GLuint64)MaxTimeout);
}

void VolumeRayCasterAlgorithmImp::postRenderTornadoOpaque()
{
    //actually render to entry/exit buffer. 
    renderEnvelopeBrick(); 
    
    myGeomDirty = true; 
    myActiveVolumeDirty = true; 
    myExtraVolumeDirty = true; 
}

void VolumeRayCasterAlgorithmImp::psuedoVsgAdpRefinement(timeval t)
{
    //detect current refinement state: 1. interactive(MOVE/DELAY)  2.refinement 
    // reset state: if is in the process of refinement and rendertarget resolution changed 
    // choose node level of detail reduction,   
    // upload bricks that is missing 
    // update state: 1. interactive: full frame no iteration 
    //               2. refinement: if no resultion change happens, it could be a interactive. 
    //                              if resolution changes, reuse previous 
    //   
    
    // if current state is finished , quality mode, return 
    // in interactive mode, it never early exit, each frame will be rerender
    
    // clear brick usage, render frame fs. 
    // full screen upsampling:  1. interactve, interactive level texture sampling. 
    //                          2. refinement,  check the current refinment level, speed matters 
    
    //suppose under quality mode
    
    if( !myOctreeVol )
        return; 
    
    if( myNodeBufferGL <= 0 || myBrickVolTextureGL <= 0 || myBrickUsageBufferGL <= 0 || myVoxelPickGL <= 0 )
        return ; 
    
    static REFINE_STATE prevRefineState; 
    REFINE_STATE curRefineState = this->myVolRenderConfig -> logInteractiveComplexity(t);
    static int prevScreenReduction = INT_MAX; 
    
    //get the current resolution 
    int currentScreenResReduction = this ->myVolRenderConfig->getScreenResolutionReduction(t);  
    int coarsenessFactor = (int)pow( (double)2, (double)currentScreenResReduction ); 
    Vect2i internalRenderSize( myWidth/coarsenessFactor, myHeight/coarsenessFactor ); 
    if( internalRenderSize != this ->myDownsampledRenderSize )
        myDownsampledRenderSize = internalRenderSize; 
    
    if( myRenderState >= RENDER_STATE_FIRST_ITERATIVE_FRAME && myRayBufferDim != myDownsampledRenderSize)
    {
        //AUTO MODE, refinement the progressiveness, we had better reuse the previous result
        this ->resetRenderState();
        myRayBufferDim = myDownsampledRenderSize; 
    }
    int currentNodeLevelReduction = this ->myVolRenderConfig->getOctreeNodeLevelReduction(t); 
    float currentSamplingRate = this ->myVolRenderConfig->getCurrentSamplingRate(t); 
    int avgDim = OctreeUtils::hadd( this ->myOctreeVol ->getVolumeDimension()) / 3; 
    float samplingStepSize = 1.f/(float)(avgDim * currentSamplingRate ); 
    
    // level of detail for the whole volume : nodeLevel larger, more detail 
    size_t nodeLevel = OctreeUtils::computeNodeLevel( Vect3f(0.5f, 0.5f, 0.5f), myOctreeVol ->getVolumeDimension(), myVolumeTex2WorldMatrix,  
            myOctreeVol ->getTreeDepth(), myCameraPos, myProjectionMatrix, Vect2i( myWidth, myHeight )); 
    
    nodeLevel -= std::min( (size_t)currentNodeLevelReduction, nodeLevel  ); 
    
    bool currentUseLinearFilter = this ->myVolRenderConfig->getTextureFilterMode(t); 
    bool currentUseAdpativeSampling = this ->myVolRenderConfig->isAdaptiveSampling(t); 
    bool currentUseCubicSpline = this ->myVolRenderConfig->isUseCubicSplineInterpolation(t); 
    bool currentUseHardware = this ->myVolRenderConfig->isUseHardwareTextureFiltering(t); 
    bool currentUseLighting = this ->myVolRenderConfig->isUseLighting(t); 
    bool currentUseJittering = this ->myVolRenderConfig->isUseJittering(t); 
    bool isLowestGradient = this -> myVolRenderConfig->isUseLowestGradient(t); 
    int  currentGradientQuality = isLowestGradient? 0 : myVolumeRenderingQuality.getGradientQuality() ; 
           

    size_t numBricksUploaded =  updateOctreeBrickPools(nodeLevel);
    DisplayMode displayMode = (DisplayMode)-1;
    RenderState nextRenderState = this ->myRenderState; 
    updateRenderState(numBricksUploaded, myRenderState, nextRenderState, displayMode);
    if( myRenderState == RENDER_STATE_FINISHED )
    {
        prevScreenReduction = currentScreenResReduction;
        return ; 
    }
    this ->clearOctreeBrickUsageBuffer(this ->myNodeBufferSize, displayMode == FULL_FRAME, myCurrentGLSyncRangeIndex); 
    if(curRefineState != STILL )
    {
        this ->renderFrameFS( currentScreenResReduction,nodeLevel ,samplingStepSize, currentUseLinearFilter, currentUseAdpativeSampling,
                currentUseCubicSpline, currentUseHardware, currentUseLighting, currentUseJittering, currentGradientQuality, 
                displayMode, myVolRenderConfig->isUseBricks(), myCurrentGLSyncRangeIndex); 
    }
    else
    {
        if(prevRefineState != STILL)
        {
            this ->renderFrameFS( currentScreenResReduction,nodeLevel ,samplingStepSize, currentUseLinearFilter, currentUseAdpativeSampling,
                currentUseCubicSpline, currentUseHardware, currentUseLighting, currentUseJittering, currentGradientQuality, 
                displayMode, myVolRenderConfig->isUseBricks(), myCurrentGLSyncRangeIndex); 
            postRenderEdgeDetection( currentScreenResReduction );
        }
        else
        {
            if(prevScreenReduction != currentScreenResReduction)
            {
                glEnable(GL_STENCIL_TEST);
                vlGLExt::glStencilFuncSeparate(GL_FRONT, GL_EQUAL, 1, 0xFF); // Set any stencil to 1
                vlGLExt::glStencilFuncSeparate(GL_BACK, GL_EQUAL, 1, 0xFF); // Set any stencil to 1
                glStencilMask(0x00); // Don't write anything to stencil buffer
                glDepthMask(GL_TRUE); // Write to depth buffer
                glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE); 

                this ->renderFrameFS( currentScreenResReduction,nodeLevel ,samplingStepSize, currentUseLinearFilter, currentUseAdpativeSampling,
                currentUseCubicSpline, currentUseHardware, currentUseLighting, currentUseJittering, currentGradientQuality, 
                displayMode, myVolRenderConfig->isUseBricks(), myCurrentGLSyncRangeIndex); 

                glDisable(GL_STENCIL_TEST);
                vlGLExt::glBindFramebufferEXT( GL_FRAMEBUFFER, 0 );  
                glStencilMask(0xFF); 

                combineCurrentRefinement( currentScreenResReduction );
                postRenderEdgeDetection( currentScreenResReduction );
            }
        }
    }
    myRenderState = nextRenderState;
    //updateOctreeBrickUsage(); 
//    
    {
        glEnable(GL_CULL_FACE);
        glCullFace(GL_BACK);
        glEnable(GL_BLEND); 
        glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); 
        glEnable( GL_DEPTH_TEST); 
        //glDepthFunc(GL_LEQUAL); 
        glDepthFunc(GL_LESS); 
    }

    if(myVolumeRenderingQuality.isUseAmbientOcclusion())
        imageSpaceAO(currentScreenResReduction); 
    
    vlGLExt::glBindFramebufferEXT( GL_FRAMEBUFFER, 0 );  
    glDrawBuffer(GL_BACK); 
    myFullScreenCopyBasicTechnique->use(); 
    myFullScreenCopyBasicTechnique->setGMVPMatrix((float*)&myMVPMatrix.mat);
    myFullScreenCopyBasicTechnique->setUseAO( myVolumeRenderingQuality.isUseAmbientOcclusion()); 
    myFullScreenCopyBasicTechnique->release();
    myFullScreenCopyBasicTechnique->bindPipeline(); 
    glActiveTexture(GL_TEXTURE0); 
#ifdef USETEXTURE2DARRAY
    glBindTexture(GL_TEXTURE_2D_ARRAY, myRayCasterColorDepthTextureArray); 
#else
    glBindTexture(GL_TEXTURE_2D_ARRAY, myRayCasterColorDepthTextureArray[ currentScreenResReduction]); 
#endif 
    glActiveTexture(GL_TEXTURE4); 
    glBindTexture(GL_TEXTURE_2D, this->myUseAOBlurPass? this->mySSAOBlurredTexture[currentScreenResReduction] : mySSAOTexture[currentScreenResReduction]);    
    vlGLExt::glBindVertexArray(0); 
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    glActiveTexture(GL_TEXTURE4); 
    glBindTexture(GL_TEXTURE_2D, 0);   
    glActiveTexture(GL_TEXTURE0); 
    glBindTexture(GL_TEXTURE_2D_ARRAY, 0); 
    myFullScreenCopyBasicTechnique->unbindPipeline();   
    
    prevRefineState = curRefineState;
    prevScreenReduction = currentScreenResReduction;
}

void VolumeRayCasterAlgorithmImp::postRenderEdgeDetection(const int currentReduction)
{
    while(!checkError("before postRenderEdgeDetection"))
    {
        continue;
    }
    if(currentReduction == 0 )
        return ; 
    
    const int targetReduction = max( currentReduction - 1, 0 ); 
    Vect2i vpSize;
    GLint viewport_bk[4];
    glGetIntegerv( GL_VIEWPORT, viewport_bk );
    
    {
        vlGLExt::glBindFramebufferEXT( GL_FRAMEBUFFER,  myIntermiateFBO[targetReduction] ); 
        int coarsenessFactor = (int)pow( (double)2, double(targetReduction) ); 
        vpSize = Vect2i( myWidth/coarsenessFactor, myHeight/coarsenessFactor ); 
        
        glDisable(GL_DEPTH_TEST);
        glDepthMask(GL_TRUE); // Don't write to depth buffer
        glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE); 
        glStencilMask(0xFF);
        glClearColor(0,0,0,0); 
        glClearDepth ( 1.0 );
        glClearStencil( 0 );
        glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
        glViewport(0, 0, vpSize[0], vpSize[1]); 
        
        glEnable(GL_STENCIL_TEST);
        vlGLExt::glStencilFuncSeparate(GL_FRONT, GL_ALWAYS, 1, 0xFF); // Set any stencil to 1
        vlGLExt::glStencilFuncSeparate(GL_BACK, GL_ALWAYS, 1, 0xFF); // Set any stencil to 1
        glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
        glStencilMask(0xFF); // Write to stencil buffer         
        glDepthMask(GL_FALSE); // Don't write to depth buffer
        glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE); 
        
        mySobelEdgeDetectionTechnique ->use(); 
        mySobelEdgeDetectionTechnique->setColorTexUnitUniform(0); 
        mySobelEdgeDetectionTechnique->setGMVPMatrix((float*)&myMVPMatrix.mat);
        mySobelEdgeDetectionTechnique->setEdgeColor(this->myVolumeRenderingQuality.getEdge2DColor());
        mySobelEdgeDetectionTechnique->setInnerEdgeThreshold(0.1f);
        mySobelEdgeDetectionTechnique->setOuterEdgeThreshold(0.1f);
        mySobelEdgeDetectionTechnique->setLogicOp(true); 
        mySobelEdgeDetectionTechnique->setEdgeDetectionMethod(LUMINANCE|DEPTH); 
        mySobelEdgeDetectionTechnique->release();


        mySobelEdgeDetectionTechnique->bindPipeline(); 
        glActiveTexture(GL_TEXTURE0); 
        glBindTexture(GL_TEXTURE_2D_ARRAY, myRayCasterColorDepthTextureArray[currentReduction]); 

        vlGLExt::glBindVertexArray(0); 
        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
        glActiveTexture(GL_TEXTURE0); 
        glBindTexture(GL_TEXTURE_2D_ARRAY, 0); 
        mySobelEdgeDetectionTechnique->unbindPipeline(); 
        
        glDisable(GL_STENCIL_TEST);
        glEnable(GL_DEPTH_TEST);
        vlGLExt::glBindFramebufferEXT( GL_FRAMEBUFFER, 0 );     
        glDepthMask(GL_TRUE); // Don't write to depth buffer
        glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE); 
    }
    
    glViewport(viewport_bk[0],viewport_bk[1], viewport_bk[2], viewport_bk[3]); 
}

void VolumeRayCasterAlgorithmImp::combineCurrentRefinement(const int currentReduction)
{
    if(currentReduction == MAX_MIPMAP_LEVELS - 1)
        return; 
    
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);   
    glEnable( GL_DEPTH_TEST); 
    glEnable(GL_STENCIL_TEST);
    
    int coarsenessFactor = (int)pow((double)2, (double)currentReduction); 
    
    Vect2i vpSize;
    vpSize = Vect2i( myWidth/coarsenessFactor, myHeight/coarsenessFactor ); 
    GLint viewport_bk[4];
    glGetIntegerv( GL_VIEWPORT, viewport_bk );
    
    glViewport(0, 0, vpSize[0], vpSize[1]); 
    glStencilMask(0x00); // Write to stencil buffer   
    vlGLExt::glBindFramebufferEXT( GL_FRAMEBUFFER,  myIntermiateFBO[currentReduction] ); 
    GLenum DrawBuffers[2]; 
    DrawBuffers[0] = GL_COLOR_ATTACHMENT0; 
    DrawBuffers[1] = GL_COLOR_ATTACHMENT1; 
    vlGLExt::glDrawBuffers(2, DrawBuffers);
    vlGLExt::glStencilFuncSeparate(GL_FRONT, GL_EQUAL, 0, 0xFF); // Set any stencil to 1
    vlGLExt::glStencilFuncSeparate(GL_BACK, GL_EQUAL, 0, 0xFF); // Set any stencil to 1
    myFullScreenFBOCopyTechnique ->use(); 
    myFullScreenFBOCopyTechnique->setGMVPMatrix((float*)&myMVPMatrix.mat);
    myFullScreenFBOCopyTechnique->release();
    myFullScreenFBOCopyTechnique->bindPipeline(); 
    glActiveTexture(GL_TEXTURE0); 
#ifdef USETEXTURE2DARRAY
    glBindTexture(GL_TEXTURE_2D_ARRAY, myRayCasterColorDepthTextureArray); 
#else
    glBindTexture(GL_TEXTURE_2D_ARRAY, myRayCasterColorDepthTextureArray[currentReduction + 1 ]); 
#endif 

    vlGLExt::glBindVertexArray(0); 
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    glActiveTexture(GL_TEXTURE0); 
    glBindTexture(GL_TEXTURE_2D_ARRAY, 0); 
    myFullScreenFBOCopyTechnique->unbindPipeline();   
    
    glStencilMask(0xFF);
    glDisable(GL_STENCIL_TEST);
    
    glViewport(viewport_bk[0],viewport_bk[1], viewport_bk[2], viewport_bk[3]); 
}

void VolumeRayCasterAlgorithmImp::inVoxelRender(timeval t)
{   
    if( !myOctreeVol )
        return; 
    
    if( myNodeBufferGL <= 0 || myBrickVolTextureGL <= 0 || myBrickUsageBufferGL <= 0 || myVoxelPickGL <= 0 )
        return ; 
    
#ifdef POWER_REDUCTION  
    int coarsenessFactor = (int)pow( (double)2, double(this ->myVolRenderConfig->getScreenResolutionReduction()) ); 
#else
    int coarsenessFactor = myVolRenderConfig->getScreenResolutionReduction() + 1; 
#endif 
    
    Vect2i internalRenderSize( myWidth/coarsenessFactor, myHeight/coarsenessFactor ); 
    if( internalRenderSize != this ->myDownsampledRenderSize )
        myDownsampledRenderSize = internalRenderSize; 
    
    if( myRenderState >= RENDER_STATE_FIRST_ITERATIVE_FRAME && myRayBufferDim != myDownsampledRenderSize)
    {
        //AUTO MODE, refinement the progressiveness, we had better reuse the previous result
        this ->resetRenderState();
        myRayBufferDim = myDownsampledRenderSize; 
    }
    
    float samplingRate = this ->myVolRenderConfig->getCurrentSamplingRate(t); 
    int avgDim = OctreeUtils::hadd( this ->myOctreeVol ->getVolumeDimension()) / 3; 
    float samplingStepSize = 1.f/(float)(avgDim * samplingRate ); 
    
    // level of detail for the whole volume : nodeLevel larger, more detail 
    size_t nodeLevel = OctreeUtils::computeNodeLevel( Vect3f(0.5f, 0.5f, 0.5f), myOctreeVol ->getVolumeDimension(), myVolumeTex2WorldMatrix,  
            myOctreeVol ->getTreeDepth(), myCameraPos, myProjectionMatrix, Vect2i( myWidth, myHeight )); 
    
    int nodeLevelReduction = this ->myVolRenderConfig->getOctreeNodeLevelReduction(); 
    nodeLevel -= std::min( (size_t)nodeLevelReduction, nodeLevel  ); 
    
    size_t numBricksUploaded =  updateOctreeBrickPools(nodeLevel);
   
    bool currentUseLinearFilter = this ->myVolRenderConfig->getTextureFilterMode(); 
    bool currentUseAdpativeSampling = this ->myVolRenderConfig->isAdaptiveSampling(); 
    bool currentUseCubicSpline = this ->myVolRenderConfig->isUseCubicSplineInterpolation(); 
    bool currentUseHardware = this ->myVolRenderConfig->isUseHardwareTextureFiltering(); 
    bool currentUseLighting = this ->myVolRenderConfig->isUseLighting(); 
    bool currentUseJittering = this ->myVolRenderConfig->isUseJittering(); 
    int  currentGradientQuality =  myVolumeRenderingQuality.getGradientQuality() ; 
           
    //
    DisplayMode displayMode = (DisplayMode)-1;
    RenderState nextRenderState = this ->myRenderState; 
    //update myRenderState and nextRenderState
    updateRenderState(numBricksUploaded, myRenderState, nextRenderState, displayMode);
    
    if( myRenderState == RENDER_STATE_FINISHED )
    {
          return ; 
    }
     
    this ->clearOctreeBrickUsageBuffer(this ->myNodeBufferSize, displayMode == FULL_FRAME, myCurrentGLSyncRangeIndex); 
    //if(!myVolumeRenderingQuality.isUseComputeShader())
        this ->renderFrameFS( this ->myVolRenderConfig->getScreenResolutionReduction() ,nodeLevel ,samplingStepSize, currentUseLinearFilter, currentUseAdpativeSampling,
                currentUseCubicSpline, currentUseHardware, currentUseLighting, currentUseJittering, currentGradientQuality, 
                displayMode, myVolRenderConfig->isUseBricks(), myCurrentGLSyncRangeIndex); 
//    else
//        this ->renderFrame( displayMode, samplingStepSize, nodeLevel, myVolRenderConfig->isUseBricks(), myCurrentGLSyncRangeIndex, false);
    myRenderState = nextRenderState; 
}

void VolumeRayCasterAlgorithmImp::initializeGridDimension()
{
    if(this ->myOctreeVol == NULL)
        return ; 
    
    //initializeDimention 
    Vect3i volumeDim = this ->myOctreeVol->getVolumeDimension();
    int maxVolDim = max(volumeDim[0], max(volumeDim[1],volumeDim[2])); 
    int maxGridDim = 16; 
   
    myGridDim[0] = max(1,  volumeDim[0]/(maxVolDim / maxGridDim) );
    myGridDim[1] = max(1,  volumeDim[1]/(maxVolDim / maxGridDim) );
    myGridDim[2] = max(1,  volumeDim[2]/(maxVolDim / maxGridDim) );

    myVoxelsPerCell[0] = (int)ceil( (float)volumeDim[0]/myGridDim[0]  );
    myVoxelsPerCell[1] = (int)ceil( (float)volumeDim[1]/myGridDim[1]  );
    myVoxelsPerCell[2] = (int)ceil( (float)volumeDim[2]/myGridDim[2]  );
    
    myMaxGridPos[0] = (float)volumeDim[0]/myVoxelsPerCell[0]; 
    myMaxGridPos[1] = (float)volumeDim[1]/myVoxelsPerCell[1];
    myMaxGridPos[2] = (float)volumeDim[2]/myVoxelsPerCell[2];
    
//    Vect3f voxel2world = Vect3f(1.0f/maxVolDim, 1.f/maxVolDim, 1.f/maxVolDim); 
//    Vect3f voxeltexcoord2world = voxel2world * Vect3f(volumeDim[0], volumeDim[1], volumeDim[2]); 
//   Vect3f grid2world = voxel2world * Vect3f(myVoxelsPerCell[0], myVoxelsPerCell[1], myVoxelsPerCell[2]); 
               
//    fprintf(stderr, "gridDim= %d %d %d\n", myGridDim[0], myGridDim[1], myGridDim[2]); 
//    fprintf(stderr, "max grid pos= %f %f %f\n", myMaxGridPos[0], myMaxGridPos[1], myMaxGridPos[2]); 
//    fprintf(stderr, "grid2world= %f %f %f\n", grid2world[0], grid2world[1], grid2world[2]);   
}

void VolumeRayCasterAlgorithmImp::initializeGridBuffer()
{
    while(!checkError("before initializeGridBuffer"))
    {
        continue;
    }
    if( this ->myDummyPointsVboId == 0 )
    {
        vlGLExt::glGenBuffers(1, &myDummyPointsVboId);
        float positions[] = {1.0f}; 
        vlGLExt::glBindBuffer(GL_ARRAY_BUFFER, myDummyPointsVboId);
        vlGLExt::glBufferData(GL_ARRAY_BUFFER, sizeof(positions), positions, GL_STATIC_DRAW); 
        vlGLExt::glBindBuffer(GL_ARRAY_BUFFER, 0);
    }
    
    if( this ->myDummyPointsVaoId == 0 )
    {
        vlGLExt::glGenVertexArrays(1, &myDummyPointsVaoId); 
    }
    
    int numGridVoxels = myGridDim[0] * myGridDim[1] * myGridDim[2]; 
    int maxGridDim = OctreeUtils::maxComponent(myGridDim); 
    int maxNumTris = 2 * maxGridDim * maxGridDim * (6 + 100 * 8) ; 
    myMaxEnvelopeNumTriangles = maxNumTris;
    int maxNumVertices = maxNumTris * 3; 
    int maxNumBytes = maxNumVertices * sizeof(int); 
    
    if(this ->myEnvelopeVboId == 0 )
         vlGLExt::glGenBuffers(1, &myEnvelopeVboId);
    vlGLExt::glBindBuffer(GL_ARRAY_BUFFER, myEnvelopeVboId);
    vlGLExt::glBufferData(GL_ARRAY_BUFFER, maxNumBytes, NULL, GL_STATIC_DRAW); 
    vlGLExt::glBindBuffer(GL_ARRAY_BUFFER, 0);
    
    if( this ->myEnvelopeVaoId == 0 )
        vlGLExt::glGenVertexArrays(1, &myEnvelopeVaoId);   
    vlGLExt::glBindVertexArray(myEnvelopeVaoId);
    vlGLExt::glEnableVertexAttribArray(0);  
    vlGLExt::glBindBuffer(GL_ARRAY_BUFFER, myEnvelopeVboId);  //for feedback
    vlGLExt::glVertexAttribPointer(0, 4, GL_UNSIGNED_INT_2_10_10_10_REV, GL_FALSE, 0, NULL); 
    vlGLExt::glBindVertexArray(0);
    checkError("after initializeGridBuffer");
}

void VolumeRayCasterAlgorithmImp::computeEnvelope()
{
    while(!checkError("before computeEnvelope"))
    {
        continue;
    }

    myComputeEnvelopeTechnique->use();
    myComputeEnvelopeTechnique->setGridDimension(myGridDim); 
    myComputeEnvelopeTechnique->setGridVolumeTextureUnit(2); 
    myComputeEnvelopeTechnique->setGridIsoValue(myVolRenderConfig->getIsoValue()); 
    myComputeEnvelopeTechnique->setNumIsoValues(myVolRenderConfig->getIsoValueNum());
    myComputeEnvelopeTechnique->setOpacitySATTextureUnit(4); 
    myComputeEnvelopeTechnique->setOpacityTFTextureUnit(3); 
    myComputeEnvelopeTechnique->setIsIsosurfaceRendering(myVolRenderConfig ->getVolumeRenderingTech() == (int)ISO_MODE ? 1 : 0); 
    myComputeEnvelopeTechnique->setGridVolumeSeisDataTFRange(Vect4f( myDataRangeSeismic[0], myDataRangeSeismic[1], myTfRangeSeismic[0], myTfRangeSeismic[1])); 
    myComputeEnvelopeTechnique->setGridVolumeAttrDataTFRange(Vect4f( myDataRangeAttribute[0], myDataRangeAttribute[1], myTfRangeAttribute[0], myTfRangeAttribute[1])); 
    myComputeEnvelopeTechnique->setMultiVolRendMode((uint)myVolRenderConfig->getMultipleVolumeRenderingMode()); 
    myComputeEnvelopeTechnique->setNumVolumes((uint)this ->myOctreeVol ->getNumVolumes());
    myComputeEnvelopeTechnique->release();    
    
    myComputeEnvelopeTechnique->bindPipeline(); 

    GLuint qid; 
    vlGLExt::glGenQueries(1, &qid); 
    vlGLExt::glBeginQuery(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, qid); 
    
    vlGLExt::glBindVertexArray(myDummyPointsVaoId); 
    vlGLExt::glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, 0, myEnvelopeVboId);
    glActiveTexture(GL_TEXTURE2);
    glBindTexture(GL_TEXTURE_3D, myGridTexture3D);
    glActiveTexture(GL_TEXTURE3); 
    glBindTexture( GL_TEXTURE_1D_ARRAY, this ->getTransferFunctionTextureArray() );
    
    glActiveTexture(GL_TEXTURE4); 
    glBindTexture( GL_TEXTURE_1D_ARRAY, this ->getOpacitySATArray() );
    glEnable(GL_RASTERIZER_DISCARD); 
    vlGLExt::glBeginTransformFeedback(GL_TRIANGLES); 
    size_t instanceCount = myGridDim[0] * myGridDim[1] * myGridDim[2]; 
    vlGLExt::glDrawArraysInstanced(GL_POINTS, 0, 1, instanceCount); 
    vlGLExt::glEndTransformFeedback(); 
    glDisable(GL_RASTERIZER_DISCARD);
    
    vlGLExt::glEndQuery(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN); 
    vlGLExt::glGetQueryObjectuiv(qid, GL_QUERY_RESULT, &myEnvelopeNumTriangles); 
 //   int numBytes = myEnvelopeNumTriangles * 3 * sizeof(int); 
//    fprintf(stderr, "triangles generated: %d, %d bytes\n", myEnvelopeNumTriangles, numBytes); 
    
    myComputeEnvelopeTechnique->unbindPipeline(); 
    
    glActiveTexture(GL_TEXTURE2);
    glBindTexture(GL_TEXTURE_3D, 0);
    glActiveTexture(GL_TEXTURE4); 
    glBindTexture( GL_TEXTURE_1D_ARRAY, 0 );
    glActiveTexture(GL_TEXTURE0);
    this ->myEnvelopeIsDirty = false; 
    
    checkError("after computeEnvelope");
}

void VolumeRayCasterAlgorithmImp :: renderEnvelopeBrick( )
{
    if( myGeomDirty || myActiveVolumeDirty )
    {
        fprintf(stderr, "renderEnvelopeBrick: dirty geometry info\n"); 
        return ; 
    }
    
    while(!checkError("before renderEnvelopeBrick"))
    {
        continue;
    }
  
    vlGLExt::glClearTexSubImage(myEntryExitBound.textureArray, 0, 0, 0, 0, myWidth, myHeight, 2,  GL_RGBA, GL_FLOAT, &Vect4f(0.0f)[0] ); 
    vlGLExt::glBindFramebufferEXT( GL_FRAMEBUFFER, 0 );
    glDrawBuffer(GL_NONE);
    glDepthFunc(GL_LESS); 
    glEnable(GL_CULL_FACE); 
    glDisable(GL_DEPTH_TEST);
    glCullFace(this ->myZNearCanIntersectVolume ? GL_FRONT : GL_FRONT);
    glDisable(GL_BLEND); 
    
    bool useGrid = this ->myVolRenderConfig->isUseGrid() ;  

    myDrawEnvelopeTechnique->use(); 
#ifndef USE_DOUBLEPRECISION
    myDrawEnvelopeTechnique->setCubeToClipMatrixf((float*)&myMVPMatrix.mat);
#else
    myDrawEnvelopeTechnique->setCubeToClipMatrixd((double*)&myMVPMatrixd.mat);
#endif    
    if(useGrid)
        myDrawEnvelopeTechnique->setMaxGridPos(myMaxGridPos); 
    else
        myDrawEnvelopeTechnique->setMaxGridPos(Vect3f(0.998f, 0.997f, 0.991f)); 
        //myDrawEnvelopeTechnique->setMaxGridPos(Vect3f(1.f, 1.f, 1.f)); 
    Vect3i volumeDim = this ->myOctreeVol->getVolumeDimension();
    myDrawEnvelopeTechnique->setVolumeDim(volumeDim); 
    myDrawEnvelopeTechnique->setVoxelsPerCell(myVoxelsPerCell);
    myDrawEnvelopeTechnique->setIsUseGrid(useGrid);
    myDrawEnvelopeTechnique->setIsUseROI(myVolRenderConfig->isRenderROIOnly());
    myDrawEnvelopeTechnique->setMinBoundingCorner(myVolRenderConfig->isRenderROIExclusive()? Vect3f(0) :  m_bbMin);
    myDrawEnvelopeTechnique->setMaxBoundingCorner(myVolRenderConfig->isRenderROIExclusive()? Vect3f(0.998f, 0.997f, 0.991f):m_bbMax);
    
    myDrawEnvelopeTechnique->setReferenceOrigin(myGeomOrigin);
    myDrawEnvelopeTechnique->setReferenceNum(myGeomSize); 
    myDrawEnvelopeTechnique->setReferenceStep(myGeomStep);
    myDrawEnvelopeTechnique ->setVolOrigin(myActiveVolumeOrigin);
    myDrawEnvelopeTechnique ->setVolNum(myActiveVolumeSize);
    myDrawEnvelopeTechnique ->setVolStep(myActiveVolumeStep);
   
    myDrawEnvelopeTechnique->setScreenDimRCP(Vect2f(1.0f/myWidth, 1.0f/myHeight));
    myDrawEnvelopeTechnique->setFarNearPlane( Vect2f(-0.5 * myViewVolume[2] , 0.5 * myViewVolume[2]) ); 
    myDrawEnvelopeTechnique->setZNearCanIntersectFustrum(myZNearCanIntersectVolume); 
    myDrawEnvelopeTechnique->setShowCubeBackSides(myShowCubeBackSides); 
    myDrawEnvelopeTechnique->setInverseMVPMatrix((float*)&myMVPMatrixInverse.mat);
    myDrawEnvelopeTechnique->setDepthTexUnitUniform(2);
    myDrawEnvelopeTechnique->release(); 
    myDrawEnvelopeTechnique->bindPipeline();  
    
    glActiveTexture(GL_TEXTURE2);
    glBindTexture(GL_TEXTURE_2D, mySinglePassDepthRT.textureHandle);
    //write into extry exit bound, 
    
    vlGLExt::glBindImageTexture( 3, myEntryExitBound.textureArray, 0, GL_TRUE, 0, GL_WRITE_ONLY, GL_RGBA32F); 
    
    if(useGrid)
    {
        this ->drawEnvelope(); 
    }
    else
    {
        this -> drawCube(); 
    }
    glBindTexture(GL_TEXTURE_2D, 0);
    myDrawEnvelopeTechnique->unbindPipeline();
    
    glActiveTexture(GL_TEXTURE0);
    glDrawBuffer(GL_BACK); 
    glEnable(GL_DEPTH_TEST);
    vlGLExt::glBindImageTexture( 3, 0, 0, GL_TRUE, 0, GL_WRITE_ONLY, GL_RGBA32F); 
    glCullFace( GL_BACK);
    checkError("after renderEnvelopeBrick");
}


void VolumeRayCasterAlgorithmImp::renderDualDepthPeel()
{
    if( myGeomDirty || myActiveVolumeDirty )
    {
        fprintf(stderr, "RenderDualDepthPeel: dirty geometry info\n"); 
        return ; 
    }
    
    while(!checkError("before renderDualDepthPeel"))
    {
        continue;
    }
    
    //First Pass: Dual Depth pEEL 
    vlGLExt::glBindFramebufferEXT(GL_FRAMEBUFFER, mySinglePassDepthRT.fboHandle); 
    //vlGLExt::glBindFramebufferEXT( GL_FRAMEBUFFER, 0 );
    glDrawBuffer(GL_COLOR_ATTACHMENT0); 
    glClearColor(1,1,1,0);
    glClear (GL_COLOR_BUFFER_BIT ); 
    glDisable(GL_DEPTH_TEST); 
    glDisable(GL_CULL_FACE); 
    glEnable(GL_BLEND); 
    glBlendEquation(GL_MIN); 
    
    bool useGrid =  this ->myVolRenderConfig->isUseGrid() ;    
    mySinglePassDepthBoundTechnique ->use(); 
#ifndef USE_DOUBLEPRECISION
    mySinglePassDepthBoundTechnique ->setCubeToClipMatrixf( (float*)&myMVPMatrix.mat ); 
#else
    mySinglePassDepthBoundTechnique ->setCubeToClipMatrixd( (double*)&myMVPMatrixd.mat ); 
#endif
    if(useGrid)
        mySinglePassDepthBoundTechnique ->setMaxGridPos(myMaxGridPos);
    else
        mySinglePassDepthBoundTechnique ->setMaxGridPos(Vect3f(0.998f, 0.997f, 0.991f)); 
    mySinglePassDepthBoundTechnique->setVolumeDim(myOctreeVol->getVolumeDimension());
    mySinglePassDepthBoundTechnique->setVoxelsPerCell(myVoxelsPerCell);
    mySinglePassDepthBoundTechnique->setIsUseGrid( useGrid );
    mySinglePassDepthBoundTechnique->setIsUseROI(myVolRenderConfig->isRenderROIOnly());
    mySinglePassDepthBoundTechnique->setMinBoundingCorner(myVolRenderConfig->isRenderROIExclusive()? Vect3f(0) :  m_bbMin);
    mySinglePassDepthBoundTechnique->setMaxBoundingCorner(myVolRenderConfig->isRenderROIExclusive()? Vect3f(0.998f, 0.997f, 0.991f) :m_bbMax);
    mySinglePassDepthBoundTechnique->setZNearCanIntersectFustrum(myZNearCanIntersectVolume);
   
    mySinglePassDepthBoundTechnique->setReferenceOrigin(myGeomOrigin);
    mySinglePassDepthBoundTechnique->setReferenceNum( myGeomSize ); 
    mySinglePassDepthBoundTechnique->setReferenceStep( myGeomStep );
    mySinglePassDepthBoundTechnique->setVolOrigin( myActiveVolumeOrigin  );
    mySinglePassDepthBoundTechnique->setVolNum( myActiveVolumeSize );
    mySinglePassDepthBoundTechnique->setVolStep( myActiveVolumeStep );
   
    mySinglePassDepthBoundTechnique->release();
    mySinglePassDepthBoundTechnique->bindPipeline();
    if(useGrid)
    {
        this ->drawEnvelope(); 
    }
    else
    {
        this ->drawCube(); 
    }
    mySinglePassDepthBoundTechnique->unbindPipeline(); 

    vlGLExt::glBindFramebufferEXT( GL_FRAMEBUFFER, 0 );
    glEnable(GL_DEPTH_TEST); 
    glEnable(GL_CULL_FACE); 
    glEnable(GL_BLEND); 
    glBlendEquation(GL_FUNC_ADD); 
    checkError("after renderDualDepthPeel");
}

void VolumeRayCasterAlgorithmImp::renderBasicSlicePreZPass(OrthoSliceRenderable* node)
{
    if( myGeomDirty || myActiveVolumeDirty )
    {
        fprintf(stderr, "renderBasicSlicePreZPass: dirty geometry info\n"); 
        return ; 
    }
    
    while(!checkError("before renderBasicSlicePreZPass"))
    {
        continue;
    }
    
    if(!node->isVisible())
    {
        return ; 
    }
    
    vlGLExt::glBindFramebufferEXT(GL_FRAMEBUFFER, mySinglePassDepthRT.fboHandle); 
    glDrawBuffer(GL_COLOR_ATTACHMENT0); 
    glEnable(GL_DEPTH_TEST);  
    glDepthFunc(GL_LEQUAL); 
    glDisable(GL_CULL_FACE); 
    glEnable(GL_BLEND); 
    glBlendEquation(GL_MAX); 
    glColorMask(false, true, false, false);

    //    
    myRenderTraverseSlateBaseTechnique->use();    
#ifndef USE_DOUBLEPRECISION
    myRenderTraverseSlateBaseTechnique->setMVPMatrixf((float*)&myMVPMatrix.mat);
#else
     myRenderTraverseSlateBaseTechnique->setMVPMatrixd((float*)&myMVPMatrixd.mat);
#endif 
    myRenderTraverseSlateBaseTechnique->setLargeSliceTexUnit(1);  
    myRenderTraverseSlateBaseTechnique->setLargeSliceTexUnit2(3); 
    myRenderTraverseSlateBaseTechnique->setTransferFunctionTexUnit(2); 
    myRenderTraverseSlateBaseTechnique->setSeisDataTFRange(Vect4f(myDataRangeSeismic[0], myDataRangeSeismic[1],
                myTfRangeSeismic[0], myTfRangeSeismic[1]));
    myRenderTraverseSlateBaseTechnique->setAttrDataTFRange(Vect4f(myDataRangeAttribute[0], myDataRangeAttribute[1],
                myTfRangeAttribute[0], myTfRangeAttribute[1])); 

    myRenderTraverseSlateBaseTechnique->setMultiVolumeMode((uint)myVolRenderConfig->getMultipleVolumeRenderingMode());
    myRenderTraverseSlateBaseTechnique->setVolumeNum((uint)this ->myOctreeVol ->getNumVolumes());
    myRenderTraverseSlateBaseTechnique->setUseZWrite(true); 
    myRenderTraverseSlateBaseTechnique->setLineDraw(false); 
    myRenderTraverseSlateBaseTechnique->setShowSeisAttrOnSlate(node->isShowSeismicChannel(), node->isShowAttributeChannel());
    
    myRenderTraverseSlateBaseTechnique->setReferenceOrigin(myGeomOrigin);
    myRenderTraverseSlateBaseTechnique->setReferenceNum(myGeomSize ); 
    myRenderTraverseSlateBaseTechnique->setReferenceStep(myGeomStep);
    myRenderTraverseSlateBaseTechnique->setVolOrigin(myActiveVolumeOrigin);
    myRenderTraverseSlateBaseTechnique->setVolSliceNum(myActiveVolumeSize);
    myRenderTraverseSlateBaseTechnique->setVolStep(myActiveVolumeStep);
    myRenderTraverseSlateBaseTechnique->setIsDrawExtraVol(false); 
    myRenderTraverseSlateBaseTechnique->release(); 
    
    myRenderTraverseSlateBaseTechnique->bindPipeline();
    glActiveTexture(GL_TEXTURE2);
    glBindTexture(GL_TEXTURE_1D_ARRAY, this->getTransferFunctionTextureArray());  
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, node->getTextureHandle(0) ); 
    glActiveTexture(GL_TEXTURE3);
    glBindTexture(GL_TEXTURE_2D, node->getTextureHandle(1));
    node->render(0); 
       
//    if(node->hasExtraVolComponent())
//    {
        myRenderTraverseSlateBaseTechnique->use();  
        myRenderTraverseSlateBaseTechnique -> setExtraTransferFunctionTexUnit(4); 
        myRenderTraverseSlateBaseTechnique -> setExtraVolDataTFRange(Vect4f(myDataRangeExtraVol[0], myDataRangeExtraVol[1],myTfRangeExtraVol[0], myTfRangeExtraVol[1]));
        myRenderTraverseSlateBaseTechnique -> setVolOrigin(this->myExtraVolumeOrigin);
        myRenderTraverseSlateBaseTechnique -> setVolSliceNum(this->myExtraVolumeSize);
        myRenderTraverseSlateBaseTechnique -> setVolStep(this->myExtraVolumeStep);
        myRenderTraverseSlateBaseTechnique -> setIsDrawExtraVol(true); 
        myRenderTraverseSlateBaseTechnique -> release(); 
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, node->getTextureHandle(2));
        glActiveTexture(GL_TEXTURE4);
        glBindTexture(GL_TEXTURE_1D, this->getExtraTransferFunctionTexture());
        node->render(2); 
        glActiveTexture(GL_TEXTURE4);
        glBindTexture(GL_TEXTURE_1D, 0);
   // }  
    
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, 0);
    glActiveTexture(GL_TEXTURE2);
    glBindTexture(GL_TEXTURE_1D_ARRAY, 0);
    glActiveTexture(GL_TEXTURE3);
    glBindTexture(GL_TEXTURE_2D, 0);
    myRenderTraverseSlateBaseTechnique->unbindPipeline(); 
    glActiveTexture(GL_TEXTURE0);
    
    vlGLExt::glBindFramebufferEXT(GL_FRAMEBUFFER, 0); 
    glEnable(GL_DEPTH_TEST); 
    glEnable(GL_CULL_FACE); 
    glEnable(GL_BLEND); 
    glBlendEquation(GL_FUNC_ADD); 
    glColorMask(true, true, true, true);  
    checkError("after renderBasicSlicePreZPass");
}

void VolumeRayCasterAlgorithmImp::renderBasicSliceShadingPass(OrthoSliceRenderable* node)
{
    while(!checkError("before renderBasicSliceShadingPass"))
    {
        continue;
    }
    if(!node->isVisible())
    {
        return ; 
    }
    
    vlGLExt::glBindFramebufferEXT( GL_FRAMEBUFFER, 0 ); 
    glEnable(GL_DEPTH_TEST); 
    glDepthFunc(GL_LEQUAL); 
    
    myRenderTraverseSlateBaseTechnique->use();  
#ifndef USE_DOUBLEPRECISION
    myRenderTraverseSlateBaseTechnique->setMVPMatrixf((float*)&myMVPMatrix.mat);
#else
     myRenderTraverseSlateBaseTechnique->setMVPMatrixd((float*)&myMVPMatrixd.mat);
#endif    
    myRenderTraverseSlateBaseTechnique->setLargeSliceTexUnit(1);  
    myRenderTraverseSlateBaseTechnique->setLargeSliceTexUnit2(3); 
    myRenderTraverseSlateBaseTechnique->setTransferFunctionTexUnit(2); 
    myRenderTraverseSlateBaseTechnique->setSeisDataTFRange(Vect4f(myDataRangeSeismic[0], myDataRangeSeismic[1],
                myTfRangeSeismic[0], myTfRangeSeismic[1]));
    myRenderTraverseSlateBaseTechnique->setAttrDataTFRange(Vect4f(myDataRangeAttribute[0], myDataRangeAttribute[1],
                myTfRangeAttribute[0], myTfRangeAttribute[1])); 
    myRenderTraverseSlateBaseTechnique->setMultiVolumeMode((uint)myVolRenderConfig->getMultipleVolumeRenderingMode());
    myRenderTraverseSlateBaseTechnique->setVolumeNum((uint)this ->myOctreeVol ->getNumVolumes());
    myRenderTraverseSlateBaseTechnique->setUseZWrite(false); 
    myRenderTraverseSlateBaseTechnique->setLineDraw(false); 
    myRenderTraverseSlateBaseTechnique->setShowSeisAttrOnSlate(node->isShowSeismicChannel(), node->isShowAttributeChannel());
    
    myRenderTraverseSlateBaseTechnique->setReferenceOrigin(myGeomOrigin);
    myRenderTraverseSlateBaseTechnique->setReferenceNum(myGeomSize ); 
    myRenderTraverseSlateBaseTechnique->setReferenceStep(myGeomStep);
    myRenderTraverseSlateBaseTechnique ->setVolOrigin(myActiveVolumeOrigin);
    myRenderTraverseSlateBaseTechnique ->setVolSliceNum(myActiveVolumeSize);
    myRenderTraverseSlateBaseTechnique ->setVolStep(myActiveVolumeStep);
    myRenderTraverseSlateBaseTechnique -> setIsDrawExtraVol(false); 
    myRenderTraverseSlateBaseTechnique->release(); 
    
    myRenderTraverseSlateBaseTechnique->bindPipeline(); 
    glActiveTexture(GL_TEXTURE2);
    glBindTexture(GL_TEXTURE_1D_ARRAY, this->getTransferFunctionTextureArray());  
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, node->getTextureHandle(0));
    glActiveTexture(GL_TEXTURE3);
    glBindTexture(GL_TEXTURE_2D, node->getTextureHandle(1) );
    node->render(0);

//    if(node->hasExtraVolComponent())
//    {   
        myRenderTraverseSlateBaseTechnique->use();  
        myRenderTraverseSlateBaseTechnique -> setExtraTransferFunctionTexUnit(4); 
        myRenderTraverseSlateBaseTechnique -> setExtraVolDataTFRange(Vect4f(myDataRangeExtraVol[0], myDataRangeExtraVol[1],myTfRangeExtraVol[0], myTfRangeExtraVol[1]));
        myRenderTraverseSlateBaseTechnique -> setVolOrigin(this->myExtraVolumeOrigin);
        myRenderTraverseSlateBaseTechnique -> setVolSliceNum(this->myExtraVolumeSize);
        myRenderTraverseSlateBaseTechnique -> setVolStep(this->myExtraVolumeStep);
        myRenderTraverseSlateBaseTechnique -> setIsDrawExtraVol(true); 
        myRenderTraverseSlateBaseTechnique -> release(); 
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, node->getTextureHandle(2) );
        glActiveTexture(GL_TEXTURE4);
        glBindTexture(GL_TEXTURE_1D, this ->getExtraTransferFunctionTexture());
        node->render(2);  
        glActiveTexture(GL_TEXTURE4);
        glBindTexture(GL_TEXTURE_1D, 0);
    //}  
    
    myRenderTraverseSlateBaseTechnique->use();  
    myRenderTraverseSlateBaseTechnique->setLineDraw(true); 
    myRenderTraverseSlateBaseTechnique->release(); 
    
   // this ->drawOrthoSlicesBorder(align); 
   
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, 0);
    glActiveTexture(GL_TEXTURE2);
    glBindTexture(GL_TEXTURE_1D_ARRAY, 0);
    glActiveTexture(GL_TEXTURE3);
    glBindTexture(GL_TEXTURE_2D, 0);
    myRenderTraverseSlateBaseTechnique->unbindPipeline(); 
    glActiveTexture(GL_TEXTURE0);

    glDepthFunc( GL_LESS );
    checkError("after renderFenceSliceShadingPass");
}

void VolumeRayCasterAlgorithmImp::renderCurvedFenceSlicePreZPass( CurvedSliceRenderable* node)
{
    if(!node->isVisible())
    {
        return ; 
    }
    
    if( myGeomDirty || myActiveVolumeDirty )
    {
        fprintf(stderr, "renderCurvedFencePreZPass: dirty geometry info\n"); 
        return ; 
    }
    
    while(!checkError("before renderCurvedFencePreZPass"))
    {
        continue;
    }
    
    vlGLExt::glBindFramebufferEXT(GL_FRAMEBUFFER, mySinglePassDepthRT.fboHandle); 
    glDrawBuffer(GL_COLOR_ATTACHMENT0); 
    glEnable(GL_DEPTH_TEST);  
    glDepthFunc(GL_LEQUAL); 
    glDisable(GL_CULL_FACE); 
    glEnable(GL_BLEND); 
    glBlendEquation(GL_MAX); 
    glColorMask(false, true, false, false);

    //    
    myRenderTraverseSlateBaseTechnique->use();    
#ifndef USE_DOUBLEPRECISION
    myRenderTraverseSlateBaseTechnique->setMVPMatrixf((float*)&myMVPMatrix.mat);
#else
     myRenderTraverseSlateBaseTechnique->setMVPMatrixd((float*)&myMVPMatrixd.mat);
#endif 
    myRenderTraverseSlateBaseTechnique->setLargeSliceTexUnit(1);  
    myRenderTraverseSlateBaseTechnique->setLargeSliceTexUnit2(3); 
    myRenderTraverseSlateBaseTechnique->setTransferFunctionTexUnit(2); 
    myRenderTraverseSlateBaseTechnique->setSeisDataTFRange(Vect4f(myDataRangeSeismic[0], myDataRangeSeismic[1],
                myTfRangeSeismic[0], myTfRangeSeismic[1]));
    myRenderTraverseSlateBaseTechnique->setAttrDataTFRange(Vect4f(myDataRangeAttribute[0], myDataRangeAttribute[1],
                myTfRangeAttribute[0], myTfRangeAttribute[1])); 

    myRenderTraverseSlateBaseTechnique->setMultiVolumeMode((uint)myVolRenderConfig->getMultipleVolumeRenderingMode());
    myRenderTraverseSlateBaseTechnique->setVolumeNum((uint)this ->myOctreeVol ->getNumVolumes());
    myRenderTraverseSlateBaseTechnique->setUseZWrite(true); 
    myRenderTraverseSlateBaseTechnique->setLineDraw(false); 
    myRenderTraverseSlateBaseTechnique->setShowSeisAttrOnSlate(node->isShowSeismicChannel(), node->isShowAttributeChannel());
  
    
    myRenderTraverseSlateBaseTechnique->setReferenceOrigin(myGeomOrigin);
    myRenderTraverseSlateBaseTechnique->setReferenceNum(myGeomSize ); 
    myRenderTraverseSlateBaseTechnique->setReferenceStep(myGeomStep);
    myRenderTraverseSlateBaseTechnique->setVolOrigin(myActiveVolumeOrigin);
    myRenderTraverseSlateBaseTechnique->setVolSliceNum(myActiveVolumeSize);
    myRenderTraverseSlateBaseTechnique->setVolStep(myActiveVolumeStep);
    myRenderTraverseSlateBaseTechnique->setIsDrawExtraVol(false); 
    myRenderTraverseSlateBaseTechnique->release(); 
    
    myRenderTraverseSlateBaseTechnique->bindPipeline();
    glActiveTexture(GL_TEXTURE2);
    glBindTexture(GL_TEXTURE_1D_ARRAY, this->getTransferFunctionTextureArray());  
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, node->getTextureHandle(0) ); 
    glActiveTexture(GL_TEXTURE3);
    glBindTexture(GL_TEXTURE_2D, node->getTextureHandle(1));
    node->render(0); 
   //this ->drawFenceSlice(fs, 0); 
       
//    if(node->hasExtraVolComponent())
//    {
        myRenderTraverseSlateBaseTechnique->use();  
        myRenderTraverseSlateBaseTechnique -> setExtraTransferFunctionTexUnit(4); 
        myRenderTraverseSlateBaseTechnique -> setExtraVolDataTFRange(Vect4f(myDataRangeExtraVol[0], myDataRangeExtraVol[1],myTfRangeExtraVol[0], myTfRangeExtraVol[1]));
        myRenderTraverseSlateBaseTechnique -> setVolOrigin(this->myExtraVolumeOrigin);
        myRenderTraverseSlateBaseTechnique -> setVolSliceNum(this->myExtraVolumeSize);
        myRenderTraverseSlateBaseTechnique -> setVolStep(this->myExtraVolumeStep);
        myRenderTraverseSlateBaseTechnique -> setIsDrawExtraVol(true); 
        myRenderTraverseSlateBaseTechnique -> release(); 
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, node->getTextureHandle(2));
        glActiveTexture(GL_TEXTURE4);
        glBindTexture(GL_TEXTURE_1D, this->getExtraTransferFunctionTexture());
       // this ->drawFenceSlice(fs, 2); 
        node->render(2); 
        glActiveTexture(GL_TEXTURE4);
        glBindTexture(GL_TEXTURE_1D, 0);
    //}  
    
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, 0);
    glActiveTexture(GL_TEXTURE2);
    glBindTexture(GL_TEXTURE_1D_ARRAY, 0);
    glActiveTexture(GL_TEXTURE3);
    glBindTexture(GL_TEXTURE_2D, 0);
    myRenderTraverseSlateBaseTechnique->unbindPipeline(); 
    glActiveTexture(GL_TEXTURE0);
    
    vlGLExt::glBindFramebufferEXT(GL_FRAMEBUFFER, 0); 
    glEnable(GL_DEPTH_TEST); 
    glEnable(GL_CULL_FACE); 
    glEnable(GL_BLEND); 
    glBlendEquation(GL_FUNC_ADD); 
    glColorMask(true, true, true, true);  
    checkError("after renderFenceSlicePreZPass");
} 
 
void VolumeRayCasterAlgorithmImp::renderCurvedFenceSliceShadingPass( CurvedSliceRenderable* node)
{
    while(!checkError("before renderCurvedFenceSliceShadingPass"))
    {
        continue;
    }
    if(!node->isVisible())
    {
        return ; 
    }
    
    vlGLExt::glBindFramebufferEXT( GL_FRAMEBUFFER, 0 ); 
    glEnable(GL_DEPTH_TEST); 
    glDepthFunc(GL_LEQUAL); 
    
    myRenderTraverseSlateBaseTechnique->use();  
#ifndef USE_DOUBLEPRECISION
    myRenderTraverseSlateBaseTechnique->setMVPMatrixf((float*)&myMVPMatrix.mat);
#else
     myRenderTraverseSlateBaseTechnique->setMVPMatrixd((float*)&myMVPMatrixd.mat);
#endif    
    myRenderTraverseSlateBaseTechnique->setLargeSliceTexUnit(1);  
    myRenderTraverseSlateBaseTechnique->setLargeSliceTexUnit2(3); 
    myRenderTraverseSlateBaseTechnique->setTransferFunctionTexUnit(2); 
    myRenderTraverseSlateBaseTechnique->setSeisDataTFRange(Vect4f(myDataRangeSeismic[0], myDataRangeSeismic[1],
                myTfRangeSeismic[0], myTfRangeSeismic[1]));
    myRenderTraverseSlateBaseTechnique->setAttrDataTFRange(Vect4f(myDataRangeAttribute[0], myDataRangeAttribute[1],
                myTfRangeAttribute[0], myTfRangeAttribute[1])); 
    myRenderTraverseSlateBaseTechnique->setMultiVolumeMode((uint)myVolRenderConfig->getMultipleVolumeRenderingMode());
    myRenderTraverseSlateBaseTechnique->setVolumeNum((uint)this ->myOctreeVol ->getNumVolumes());
    myRenderTraverseSlateBaseTechnique->setUseZWrite(false); 
    myRenderTraverseSlateBaseTechnique->setLineDraw(false); 
    myRenderTraverseSlateBaseTechnique->setShowSeisAttrOnSlate(node->isShowSeismicChannel(), node->isShowAttributeChannel());

    
    myRenderTraverseSlateBaseTechnique->setReferenceOrigin(myGeomOrigin);
    myRenderTraverseSlateBaseTechnique->setReferenceNum(myGeomSize ); 
    myRenderTraverseSlateBaseTechnique->setReferenceStep(myGeomStep);
    myRenderTraverseSlateBaseTechnique ->setVolOrigin(myActiveVolumeOrigin);
    myRenderTraverseSlateBaseTechnique ->setVolSliceNum(myActiveVolumeSize);
    myRenderTraverseSlateBaseTechnique ->setVolStep(myActiveVolumeStep);
    myRenderTraverseSlateBaseTechnique -> setIsDrawExtraVol(false); 
    myRenderTraverseSlateBaseTechnique->release(); 
    
    myRenderTraverseSlateBaseTechnique->bindPipeline(); 
    glActiveTexture(GL_TEXTURE2);
    glBindTexture(GL_TEXTURE_1D_ARRAY, this->getTransferFunctionTextureArray());  
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, node->getTextureHandle(0));
    glActiveTexture(GL_TEXTURE3);
    glBindTexture(GL_TEXTURE_2D, node->getTextureHandle(1) );
    node->render(0);
    //this ->drawFenceSlice(fs, 0); 
    
    
//    if(node->hasExtraVolComponent())
//    {   
        myRenderTraverseSlateBaseTechnique->use();  
        myRenderTraverseSlateBaseTechnique -> setExtraTransferFunctionTexUnit(4); 
        myRenderTraverseSlateBaseTechnique -> setExtraVolDataTFRange(Vect4f(myDataRangeExtraVol[0], myDataRangeExtraVol[1],myTfRangeExtraVol[0], myTfRangeExtraVol[1]));
        myRenderTraverseSlateBaseTechnique -> setVolOrigin(this->myExtraVolumeOrigin);
        myRenderTraverseSlateBaseTechnique -> setVolSliceNum(this->myExtraVolumeSize);
        myRenderTraverseSlateBaseTechnique -> setVolStep(this->myExtraVolumeStep);
        myRenderTraverseSlateBaseTechnique -> setIsDrawExtraVol(true); 
        myRenderTraverseSlateBaseTechnique -> release(); 
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, node->getTextureHandle(2) );
        glActiveTexture(GL_TEXTURE4);
        glBindTexture(GL_TEXTURE_1D, this ->getExtraTransferFunctionTexture());
        node->render(2);  
        glActiveTexture(GL_TEXTURE4);
        glBindTexture(GL_TEXTURE_1D, 0);
    //}  
    
    myRenderTraverseSlateBaseTechnique->use();  
    myRenderTraverseSlateBaseTechnique->setLineDraw(true); 
    myRenderTraverseSlateBaseTechnique->release(); 
    
   // this ->drawOrthoSlicesBorder(align); 
   
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, 0);
    glActiveTexture(GL_TEXTURE2);
    glBindTexture(GL_TEXTURE_1D_ARRAY, 0);
    glActiveTexture(GL_TEXTURE3);
    glBindTexture(GL_TEXTURE_2D, 0);
    myRenderTraverseSlateBaseTechnique->unbindPipeline(); 
    glActiveTexture(GL_TEXTURE0);

    glDepthFunc( GL_LESS );
    checkError("after renderCurvedFenceSliceShadingPass");
}

GLuint &VolumeRayCasterAlgorithmImp::getExtraTransferFunctionTexture()
{
    if(myExtraTransFuncTexture == 0)
    {
        vlGLExt::glGenTextures(1, &myExtraTransFuncTexture); 
        glBindTexture( GL_TEXTURE_1D, myExtraTransFuncTexture);
        glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_CLAMP);
        glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_T, GL_CLAMP);
        vlGLExt::glTexStorage1D(GL_TEXTURE_1D, GLint(1), GL_RGBA16F, NUM_GRADE );
        glBindTexture(GL_TEXTURE_1D_ARRAY, 0); 
    }
    return myExtraTransFuncTexture; 
 }

GLuint &VolumeRayCasterAlgorithmImp::getTransferFunctionTextureArray( )
{
    if(myTransFuncTextureArray == 0)
    {
        vlGLExt::glGenTextures(1, &myTransFuncTextureArray); 
        glBindTexture( GL_TEXTURE_1D_ARRAY, myTransFuncTextureArray);
        glTexParameteri(GL_TEXTURE_1D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_1D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_1D_ARRAY, GL_TEXTURE_WRAP_S, GL_CLAMP);
        glTexParameteri(GL_TEXTURE_1D_ARRAY, GL_TEXTURE_WRAP_T, GL_CLAMP);
        vlGLExt::glTexStorage2D(GL_TEXTURE_1D_ARRAY, GLint(1), GL_RGBA16F, NUM_GRADE, MAX_TRANSFERFUNCTIONS );
        glBindTexture(GL_TEXTURE_1D_ARRAY, 0); 
    }
    return myTransFuncTextureArray; 
}

GLuint &VolumeRayCasterAlgorithmImp::getOpacitySATArray() 
{
    if(myOpacitySATTextureArray == 0)
    {
        vlGLExt::glGenTextures(1, &myOpacitySATTextureArray); 
        glBindTexture( GL_TEXTURE_1D_ARRAY, myOpacitySATTextureArray);
        glTexParameteri(GL_TEXTURE_1D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_1D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_1D_ARRAY, GL_TEXTURE_WRAP_S, GL_CLAMP);
        glTexParameteri(GL_TEXTURE_1D_ARRAY, GL_TEXTURE_WRAP_T, GL_CLAMP);
        vlGLExt::glTexStorage2D(GL_TEXTURE_1D_ARRAY, GLint(1), GL_R16F, NUM_GRADE, MAX_TRANSFERFUNCTIONS );
        glBindTexture(GL_TEXTURE_1D_ARRAY, 0); 
    }
    return myOpacitySATTextureArray; 
}

GLuint &VolumeRayCasterAlgorithmImp::getJitteringTexture( )
{
    if(myJitteringTexture == 0)
    {
        initJitteringTexture(); 
    }
    return myJitteringTexture; 
}

bool VolumeRayCasterAlgorithmImp::initJitteringTexture()
{  
    while(!checkError("before initJitteringTexture"))
    {
        continue;
    }
    
    int size = 32; 
    unsigned char* buffer = new unsigned char[size*size]; 
    srand((unsigned)time(NULL)); 
    for(int i = 0; i < (size*size); i++)
      buffer[i] = (unsigned char)(255.f * rand()/(float)RAND_MAX); 

    GLint align; 
    glGetIntegerv( GL_UNPACK_ALIGNMENT, &align);
    glPixelStorei (GL_UNPACK_ALIGNMENT, 1);
    glPixelTransferi( GL_MAP_COLOR, 0 ); // turn off in case this was on
    vlGLExt::glGenTextures(1, &myJitteringTexture); 
    glBindTexture( GL_TEXTURE_2D, myJitteringTexture);    
    vlGLExt::glTexStorage2D(GL_TEXTURE_2D, GLint(1), GL_R8, size, size);
    glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, size, size, GL_RED, GL_UNSIGNED_BYTE, buffer);
    
    //caution: driver don't like this following api 
//   glTexImage2D(GL_TEXTURE_2D, GLint(0), GL_R16F, size, size, 0, GL_RED, GL_FLOAT, buffer);      
    glBindTexture(GL_TEXTURE_2D, 0); 
    glPixelTransferi( GL_MAP_COLOR, 1 ); 
    glPixelStorei (GL_UNPACK_ALIGNMENT, align);
    delete[] buffer; 
    
    return checkError("initJitteringTexture");
}

void VolumeRayCasterAlgorithmImp::createCube()
{
    if(this->myCubeCreated)
        return; 
    
    while(!checkError("before createCube"))
    {
        continue;
    }
    const int vertexPositions[] = 
    {
       0, 0, 0, 
       1, 0, 0, 
       0, 1, 0, 
       1, 1, 0, 
       0, 0, 1, 
       1, 0, 1, 
       0, 1, 1, 
       1, 1, 1, 
    }; 
    
#define QUAD(a,b,c,d) a, c, b, d, c, a
    int indices[] = 
    {
        QUAD(4, 6, 7, 5), 
        QUAD(6, 2, 3, 7),
        QUAD(3, 2, 0, 1), 
        QUAD(1, 0, 4, 5), 
        QUAD(0, 2, 6, 4), 
        QUAD(7, 3, 1, 5),
    }; 
#undef QUAD
    
    this ->myNumCubeIndices = sizeof(indices) / sizeof(int); 
    for(int i = 0; i < myNumCubeIndices; i++)
    {
        indices[i] = vertexPositions[ 3 *  indices[i]] + 1024 * vertexPositions[ 3 *  indices[i] + 1] + 
                     1024 * 1024 * vertexPositions[ 3 *  indices[i] + 2]; 
    }
    
    vlGLExt::glGenBuffers(1, &this ->myCubeIndicesVboId); 
    vlGLExt::glBindBuffer(GL_ARRAY_BUFFER, myCubeIndicesVboId);
    vlGLExt::glBufferData(GL_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW ); 
    vlGLExt::glGenVertexArrays(1, &this ->myCubeVaoId); 
    vlGLExt::glBindVertexArray(myCubeVaoId);
    vlGLExt::glEnableVertexAttribArray(0); 
    vlGLExt::glBindBuffer(GL_ARRAY_BUFFER, myCubeIndicesVboId); 
    vlGLExt::glVertexAttribPointer(0, 4, GL_UNSIGNED_INT_2_10_10_10_REV, GL_FALSE, 0, 0); 
    vlGLExt::glBindVertexArray(0);
    vlGLExt::glBindBuffer(GL_ARRAY_BUFFER, 0); 
    
    myCubeCreated = checkError("after create cube");  
}
void VolumeRayCasterAlgorithmImp::drawCube()
{
   // glPolygonOffset( 4, 4); 
    vlGLExt::glBindVertexArray(this ->myCubeVaoId); 
    glDrawArrays(GL_TRIANGLES, 0, 3 *myNumCubeIndices); 
    vlGLExt::glBindVertexArray(0);    
   // glPolygonOffset( 0, 0 ); 
}

void VolumeRayCasterAlgorithmImp::drawEnvelope()
{
   // glPolygonOffset( 4, 4); 
    vlGLExt::glBindVertexArray(this ->myEnvelopeVaoId); 
    glDrawArrays(GL_TRIANGLES, 0, 3 *myEnvelopeNumTriangles); 
    vlGLExt::glBindVertexArray(0); 
   // glPolygonOffset( 0, 0 ); 
}

void VolumeRayCasterAlgorithmImp::logVolRendProfile()
{
    this->myVRProfile.print(); 
}

//octree
 uint64_t VolumeRayCasterAlgorithmImp::createOctreeNodeBufferEntry( bool homogeneous, bool inPool, size_t childPointer, size_t brickAddress, 
                                                        const uint16_t* avgValues, size_t numChannels)
 {
     //return the 64 bit mask 
     uint64_t result = 0; 
     //long long 64 bit
     result |= ( homogeneous ? 1LL : 0LL)  << MASK_HOMOGENEOUS_SHIFT; 
     result |= ( inPool ? 1LL:0LL ) << MASK_INBRICKPOOL_SHIFT; 
     result |= ( (uint64_t)childPointer << MASK_CHILD_SHIFT) & MASK_CHILD; 
     
     if( inPool ) 
     {
         result |= ( (uint64_t)brickAddress  << MASK_BRICK_SHIFT ) & MASK_BRICK;
     }
     else
     {
         assert( avgValues ); 
         for( size_t c= 0; c < numChannels; c++ )
         {
             result &= ~getAvgMask( c, numChannels ).MASK;  // all channel mask set 0
             uint16_t avgScaled = avgValues[c] >> ( 16 - getAvgMask( c, numChannels).NUMBITS ); // lose some precision if needed
             result |= ( (uint64_t)avgScaled << getAvgMask( c, numChannels ).SHIFT ) & getAvgMask(c, numChannels).MASK ;                     
         }
     }
     return result;   
 }
 
 void VolumeRayCasterAlgorithmImp::extractOctreeNodeValues( const uint64_t nodeEntry, bool& inPool, bool& homogeous, size_t& childPointer, uint16_t& avgValue, 
            size_t& brickPointer )
 {
     homogeous = ( (nodeEntry & MASK_HOMOGENEOUS ) >> MASK_HOMOGENEOUS_SHIFT ) == 1 ; 
     inPool = ( (nodeEntry & MASK_INBRICKPOOL ) >> MASK_INBRICKPOOL_SHIFT ) == 1 ; 
     childPointer = static_cast<size_t>( ( nodeEntry & MASK_CHILD) >> MASK_CHILD_SHIFT );
     
     if( inPool )
     {
         brickPointer = static_cast< size_t>( ( nodeEntry & MASK_BRICK ) >> MASK_BRICK_SHIFT  ); 
     }
     else
     {
         //4 channel ? 
         avgValue = static_cast< uint16_t >( ( nodeEntry & getAvgMask(0, 1).MASK )>> getAvgMask(0, 1).SHIFT );
     }
 }
 
 void VolumeRayCasterAlgorithmImp::updateOctreeNodeChildPointer( uint64_t& nodeEntry, size_t childPointer )
 {
     nodeEntry &= ~MASK_CHILD; 
     nodeEntry |= (  ( (uint64_t)childPointer ) << MASK_CHILD_SHIFT ) & MASK_CHILD; 
 }
 
 size_t VolumeRayCasterAlgorithmImp::getOctreeNodeChildPointer( uint64_t& nodeEntry ) const 
 {
     return static_cast<size_t>(  (nodeEntry & MASK_CHILD) >> MASK_CHILD_SHIFT ); 
 }
 
void VolumeRayCasterAlgorithmImp::updateOctreeNodeBrickPointer( uint64_t& nodeEntry, bool hasBrick, size_t brickPointer, 
            const uint16_t* avgValues, size_t numChannels)
 {
     nodeEntry &= ~MASK_INBRICKPOOL; 
     nodeEntry |= ( ( (uint64_t)(hasBrick ? 1 : 0) ) << MASK_INBRICKPOOL_SHIFT ) & MASK_INBRICKPOOL; 
     
     if( hasBrick ) {
         nodeEntry &= ~MASK_BRICK; 
         nodeEntry |= ( ( (uint64_t)brickPointer) << MASK_BRICK_SHIFT ) & MASK_BRICK; 
         
         assert(hasOctreeNodeBrick(nodeEntry)); 
     }
     else{
         assert( avgValues ); 
         for( size_t c = 0; c < numChannels; c++ )
         {
             nodeEntry &= ~getAvgMask( c, numChannels ).MASK; 
             uint16_t avgScaled = avgValues[c] >> ( 16 - getAvgMask(c, numChannels).NUMBITS );
             nodeEntry |= (  (uint64_t)avgScaled << getAvgMask( c, numChannels).SHIFT ) & getAvgMask( c, numChannels ).MASK; 
         }
     }
 }
 
 size_t VolumeRayCasterAlgorithmImp::getOctreeNodeBrickPointer( uint64_t& nodeEntry ) const 
 {
     return static_cast<size_t>(  (nodeEntry & MASK_BRICK) >> MASK_BRICK_SHIFT ); 
 }
 
void VolumeRayCasterAlgorithmImp::updateOctreeBrickBuffer( int keepLevel, size_t& numUsedInLastPass, size_t& numRequested, size_t& numBricksUploaded, 
         size_t& slotOccupied)
 {
     //keep level is according to original full tree depth 
     numUsedInLastPass = 0; 
     numRequested = 0; 
     numBricksUploaded= 0 ; 
     slotOccupied = 0; 
     
     if( this ->myBrickVolTextureGL <= 0 )
         return ; 
     
     assert( this ->myNodeBuffer ); 
     assert(  this ->myBrickVolTextureGL ); 
     assert( this ->myBrickBufferSize); 
     assert( this ->myNumBrickBufferSlots ); 
     assert( this ->myBrickUploadBufferSize ); 
     assert( this ->myNumBrickUploadBufferSlots ); 
     assert( this ->myNumBrickUploadBufferSlots <= this ->myNumBrickBufferSlots ); 
     assert( this ->myBrickUsageBuffer ); 
     assert( this ->myOctreeNodeInfos ); 
     
     const size_t treeSparseDepth = this ->myOctreeVol ->getSparseTreeDepth(); 
     const size_t treeFullDepth = this ->myOctreeVol ->getTreeDepth(); 
     const size_t deltaDepth = treeFullDepth - treeSparseDepth; 
     const size_t numNodes = this ->myNodeBufferSize ; 
     const size_t numChannels = this ->myOctreeVol ->getNumVolumes(); 
     const size_t brickMemorySize = this ->myOctreeVol ->getBrickSize(); 
     
     assert( this ->myLRUBricks.size() == treeFullDepth ); 
     
    // Timer updateOctreeBrickTimer; 
    // updateOctreeBrickTimer.start(); 
     
     double currentCPUTime = 0;
     double currentElapsedTime = 0;
     //1. update LRU LIST, 
     //this part could be done pure on GPU  in future  
#ifdef USE_PERF
    // Timer lruTimer("lruTimer"); 
    // lruTimer.start(); 
#endif
     //count how many brick is used in last rendering pass
     numUsedInLastPass = 0; 
     //for( size_t level = 0; level < treeSparseDepth; level++ )
     for( size_t level = 0; level < treeFullDepth; level++ )   
     {
         std::list<LRUBrick>& levelLRU = this ->myLRUBricks.at(level ); 
         for( std::list<LRUBrick>::iterator it = levelLRU.begin(); it!= levelLRU.end(); )
         {
             LRUBrick& brick = *it ; 
             assert( brick.myNodeID < numNodes ); // octree node the brick attached 
             assert( this ->myOctreeNodeInfos[brick.myNodeID ].myLevel == (level - deltaDepth)  ); 
             if( this ->hasOctreeBrickBeenUsed(this ->myBrickUsageBuffer[brick.myNodeID] ) )
             {
                numUsedInLastPass++; 
                LRUBrick frontBrick( brick ); 
                it = levelLRU.erase(it); 
                frontBrick.myLastUsed = 0; //clear time stamp to fresh
                levelLRU.push_front(frontBrick); //move the used brick to head
             }
             else
             {
                 brick.myLastUsed++; 
                 ++it; 
             }
         }
     }
    
     //2. determine requested bricks, 
     //why use full depth not sparse depth ? because requestedbricks need to compare with keep level. 
     std::vector< std::list<size_t> > requestedBricks( myOctreeVol ->getTreeDepth() );    
     numRequested = 0; 
     for( size_t nodeID = 0; nodeID < numNodes; nodeID++ )
     {
         if( this ->isOctreeBrickRequested( this ->myBrickUsageBuffer[nodeID] ) 
                    &&  !this ->hasOctreeNodeBrick(this ->myNodeBuffer[nodeID]) )
                 //&& !isOctreeNodeHomogeneous(this ->myNodeBuffer[nodeID]))
         {
             numRequested++;
             requestedBricks.at( this ->myOctreeNodeInfos[nodeID].myLevel + deltaDepth   ).push_back(nodeID); 
         }
     }
     
     if( numRequested == 0 )
     {
         //no cache miss
        return ; 
     }

     //request should not exceed the tolerance of the system 
     size_t numBricksToUpload = std::min( numRequested, this ->myNumBrickUploadBufferSlots ); 
     
     //3 . 
     bool* brickSlotUsed = new bool[this ->myNumBrickBufferSlots ];
     memset( brickSlotUsed, 0, myNumBrickBufferSlots); 
     size_t numSlotsOccupied = 0; 
     for( size_t nodeID = 0; nodeID < numNodes; nodeID++ )
     {
         if( this ->hasOctreeNodeBrick(this ->myNodeBuffer[nodeID]) )
         {
             size_t brickID = this ->getOctreeNodeBrickPointer( myNodeBuffer[nodeID]  ); //address cache
             assert( brickID < this ->myNumBrickBufferSlots ); 
             brickSlotUsed[brickID] = true ; 
             numSlotsOccupied++; 
         }
     }
     
     size_t numLRU = 0; 
     for( size_t i = 0; i < this ->myLRUBricks.size(); i++ )
     {
         numLRU += myLRUBricks.at(i).size() ; 
     }
     
     fprintf(stderr, "numLRU: %d, slotOccu:%d\n", numLRU,numSlotsOccupied );
     assert( numSlotsOccupied == numLRU ); 
     assert( numSlotsOccupied >= numUsedInLastPass ); 
     slotOccupied = numSlotsOccupied; 
      
     //4. 
     size_t numFreeBrickSlots = this ->myNumBrickBufferSlots - numSlotsOccupied; 
     std::vector< std::list< std::pair< size_t, size_t > > > brickKickOutList( this->myOctreeVol ->getTreeDepth() ); 
     size_t numToKickOut = 0; 
     
     if( numBricksToUpload > numFreeBrickSlots )
     {
         //need to streamout bricks
         std::vector<std::list<LRUBrick> > tempLRUList( this ->myLRUBricks ); 
         const size_t additionalSlotsNeeded = numBricksToUpload - numFreeBrickSlots ; 
         const size_t numUnusedSlotsInLastPass = numSlotsOccupied - numUsedInLastPass; 
         
         //a) remove bricks occupied vram but not used in previous frame ordered from high resoultion 0 to low resolution 
         for( size_t level = 0; numToKickOut < additionalSlotsNeeded;  )
         {
             //valid level, no lru, all used last frame
             
             //while( (level < treeDepth ) && ( tempLRUList.at(level).empty() || tempLRUList.at(level).back().myLastUsed == 0  ) ) 
             //tempLRUList.at(level).back().myLastUsed == 0 means used in latest frame. cannot be stream out
             while( (level < treeFullDepth ) && ( tempLRUList.at(level).empty() || tempLRUList.at(level).back().myLastUsed == 0  ) ) 
                 level++; 
             if( level == treeFullDepth )
                 break ; 
             
             // higher stay 
             if( keepLevel >= 0 && level >= keepLevel )
                 break; 
             
             assert( level < treeFullDepth ); 
             assert( !tempLRUList.at(level).empty() ); 
             
             const LRUBrick oldestBrick = tempLRUList.at(level).back(); 
             tempLRUList.at(level).pop_back(); 
             
             size_t brickID = this ->getOctreeNodeBrickPointer( this ->myNodeBuffer[oldestBrick.myNodeID] );//
             assert( brickID < this ->myNumBrickBufferSlots); 
             assert( brickSlotUsed[brickID] );
             
             brickKickOutList.at(level).push_back(std::make_pair( oldestBrick.myNodeID, brickID )) ; 
             numToKickOut++; 
         }
         
         assert( numToKickOut <= additionalSlotsNeeded);
         
         //b) 
         if( (numToKickOut < additionalSlotsNeeded) )// not enough by a
         {
             assert( numFreeBrickSlots + numToKickOut < numBricksToUpload); 
             
             //these requests can be satisfied: coarse resolution bricks satisfied first
             int curRequestedLevel = static_cast<int>(this ->myOctreeVol->getTreeDepth() - 1);
             for( size_t i = 0; i < numFreeBrickSlots + numToKickOut; i++)
             {
                 while( requestedBricks.at(curRequestedLevel).empty() )
                 {
                     assert( curRequestedLevel > 0 ); 
                     curRequestedLevel--; 
                 }
                 requestedBricks.at(curRequestedLevel).pop_back(); //when insert from the end 
             }
             
             //
             size_t forceRemoved = 0; 
             size_t currentLRULevel = 0; // highest resolution
             while( numToKickOut < additionalSlotsNeeded )
             {
                 assert( numFreeBrickSlots + numToKickOut < numBricksToUpload); 
                 
                 //find the candidate level of brick that could potentially released to save spot for new bricks. 
                 while( currentLRULevel < treeFullDepth && tempLRUList.at(currentLRULevel).empty() )
                     currentLRULevel++; 
                 
                 //find the level of request to be satisfied, coarse resolution bricks
                 while( requestedBricks.at(curRequestedLevel).empty() )
                 {
                     assert( curRequestedLevel > 0 ); 
                     curRequestedLevel--; 
                 }
                 
                 if( curRequestedLevel <= (int)currentLRULevel )
                 {
                     //requested level is even more high resultion than LRU one, no need to be satisfied any more
                     break; 
                 }
                 
                 // these bricks need to be kept 
                 if( keepLevel >= 0 && currentLRULevel >= keepLevel )
                     break; 
                 
                 assert( !tempLRUList.at(currentLRULevel).empty() ); 
                 const LRUBrick oldestBrick = tempLRUList.at(currentLRULevel).back(); 
                 tempLRUList.at(currentLRULevel).pop_back(); 
                 
                 size_t parentIndex = myOctreeNodeInfos[oldestBrick.myNodeID].myParentNodeIndex; 
                 assert(parentIndex < numNodes );
                 size_t grandParentIndex = myOctreeNodeInfos[parentIndex].myParentNodeIndex; 
                 assert(grandParentIndex < numNodes); 
                 //only remove lower-level brick is ancestor brick is present on THE gpu ,AVOID CRACK
                 if(!hasOctreeNodeBrick(myNodeBuffer[parentIndex]) && (!hasOctreeNodeBrick(myNodeBuffer[grandParentIndex])) )
                     continue; 
                 
                 size_t brickID = this ->getOctreeNodeBrickPointer( this ->myNodeBuffer [oldestBrick.myNodeID] ); 
                 assert(brickID < this ->myNumBrickBufferSlots ); 
                 assert(brickSlotUsed[brickID]); 
                 
                 brickKickOutList.at(currentLRULevel).push_back(std::make_pair( oldestBrick.myNodeID, brickID )) ; 
                 numToKickOut++; 
                 requestedBricks.at(curRequestedLevel).pop_back(); 
             }
         }
     }
     
     //actually remove marked bricks 
     bool useMaxValue = false ; 
     uint16_t avgValues[4]; 
     for( size_t level = 0; level < treeFullDepth ; level++ )
     {
         //starting from high resolution
         std::list< std::pair<size_t, size_t> >& currentLevelList = brickKickOutList.at(level );  // popback starting from the tail
         std::list<LRUBrick>& currentLRUList = this ->myLRUBricks.at(level); 
         
         std::list<LRUBrick>::reverse_iterator lruIter = currentLRUList.rbegin(); // popback starting from the tail
         while( !currentLevelList.empty() )
         {
             size_t nodeID = currentLevelList.front().first; 
             size_t brickID = currentLevelList.front().second; 
             currentLevelList.pop_front(); 
             
             assert( lruIter!= currentLRUList.rend()); 
             //search 
             while( lruIter != currentLRUList.rend() && lruIter->myNodeID != nodeID )
             {
                 lruIter++; 
                 assert( lruIter!= currentLRUList.rend()); 
             }
             
             assert( brickID < this ->myNumBrickBufferSlots ); 
             assert( brickSlotUsed[brickID]); 
             //this node will by deleted 
             const vlSparseVolumeOctreeNode* node = this ->myOctreeNodeInfos[nodeID].myOctreeNode; 
             for( size_t v = 0; v < myOctreeVol->getNumVolumes(); v++)
             {
                 avgValues[v] = useMaxValue ? node ->getMaxVoxelIntensity(v) : node ->getAvgVoxelIntensity(v); 
             }
             //mark brick non-exist
             this ->updateOctreeNodeBrickPointer(this ->myNodeBuffer[nodeID], false, 0, avgValues, myOctreeVol->getNumVolumes() ); 
             brickSlotUsed[brickID] = false; 
             numFreeBrickSlots++; 
             numSlotsOccupied--;         
             lruIter =  std::list<LRUBrick>::reverse_iterator( currentLRUList.erase(--lruIter.base())); 
         }
     }     
     assert( numFreeBrickSlots + numSlotsOccupied == myNumBrickBufferSlots ); 
     //
     if( numFreeBrickSlots == 0 )
     {
         numBricksToUpload = 0; 
         delete[] brickSlotUsed; 
         fprintf(stderr, "no free Brick SLOTS, cache set too small, or volume size too big\n"); 
         return ; 
     }
     
     //5. 
     numBricksToUpload = std::min( numBricksToUpload, numFreeBrickSlots ); 
     std::map<uint64_t, size_t> brickAddressToNodeIDMap;  // virtual address
     size_t numInserted = 0; 
     
     for( size_t nodeID = 0; nodeID < numNodes && numInserted < numBricksToUpload; nodeID++ )
     {
         const uint8_t brickUsage = this ->myBrickUsageBuffer[nodeID]; 
         
         if( this ->isOctreeBrickRequested( brickUsage ) 
                 &&  !this ->hasOctreeNodeBrick(this ->myNodeBuffer[nodeID])  )
         {
             assert( this ->myOctreeNodeInfos[nodeID].myOctreeNode && myOctreeNodeInfos[nodeID].myLevel < treeSparseDepth ); 
             const vlSparseVolumeOctreeNode* node = myOctreeNodeInfos[nodeID].myOctreeNode ; 
             const size_t nodeLevel = myOctreeNodeInfos[nodeID].myLevel; 
             
             if( node ->hasBrick() ) 
             {
                 brickAddressToNodeIDMap.insert( std::make_pair( node ->getBrickVMAddress(), nodeID ) ); 
                 numInserted++; 
                 assert( brickAddressToNodeIDMap.size() == numInserted ); 
             }
             else
             {
                //sparse brick node
                fprintf(stderr, "None existing brick has been requested by GPU: nodeID = %d\n", nodeID); 
                const vlSparseVolumeOctreeNode* node = this ->myOctreeNodeInfos[nodeID].myOctreeNode; 
                for( size_t v = 0; v < myOctreeVol->getNumVolumes(); v++)
                {
                    avgValues[v] = useMaxValue ? node ->getMaxVoxelIntensity(v) : node ->getAvgVoxelIntensity(v); 
                }
                this ->updateOctreeNodeBrickPointer(this ->myNodeBuffer[nodeID], false, 0, avgValues, myOctreeVol->getNumVolumes() ); 
             }
         }
     }
     
     assert( brickAddressToNodeIDMap.size() == numBricksToUpload );           
     //6 pack all streaming needed brick into a large buffer
     uint16_t* brickUpdateBuffer = new uint16_t[ numBricksToUpload * (  brickMemorySize/sizeof(uint16_t) ) ]; 
     uint32_t* brickUpdateAddressBuffer = new uint32_t[numBricksToUpload]; 
     
     // 
     size_t updateBufferPos = 0; 
     size_t nextFreeSlot = 0; 
     numBricksUploaded = 0; 
     size_t lastRuntime = 0; 
     
     for( std::map<uint64_t, size_t>::iterator it = brickAddressToNodeIDMap.begin(); it != brickAddressToNodeIDMap.end(); ++it )
     {
        // updateOctreeBrickTimer.start();          
         const uint64_t brickAddress = it ->first; 
         const size_t nodeID = it->second; 
         
         assert( brickAddress < (size_t )-1); 
         assert( nodeID < numNodes ); 
         const OctreeNodeInfo nodeInfo = this ->myOctreeNodeInfos[nodeID]; 
         const vlSparseVolumeOctreeNode* node = nodeInfo.myOctreeNode; 
         assert( node ); 
         assert( nodeInfo.myLevel < treeSparseDepth ); 
         
         //find the first free slot
         while( brickSlotUsed[nextFreeSlot] )
             nextFreeSlot++; 
         assert( updateBufferPos < numBricksToUpload );
         assert( nextFreeSlot < myNumBrickBufferSlots ); 
         
         //retrieve brik 
         const uint16_t* brick = 0; 
         brick = this ->myOctreeVol->getSVOBrick(nodeInfo.myOctreeNode); 
         assert(brick); 

         memcpy( brickUpdateBuffer + updateBufferPos * (brickMemorySize/sizeof(uint16_t) ), brick, brickMemorySize ); 
         brickUpdateAddressBuffer[updateBufferPos] = static_cast<uint32_t>(nextFreeSlot);         
         //update node brick pointer
         this ->updateOctreeNodeBrickPointer( this ->myNodeBuffer[nodeID], true, nextFreeSlot, 0, numChannels ); 
         assert( this ->getOctreeNodeBrickPointer(this ->myNodeBuffer[nodeID]) == nextFreeSlot ); 
         
         //add brick to LRU list
         this ->myLRUBricks.at(nodeInfo.myLevel + deltaDepth).push_front(LRUBrick(nodeID)); 
         
         updateBufferPos++; 
         brickSlotUsed[nextFreeSlot ] = true; 
         numSlotsOccupied++; 
         numBricksUploaded++; 
          
         //auto-count ptr for svo brick
         this ->myOctreeVol->releaseSVOBrick(node); //count--
     }
    
     assert( numBricksUploaded <= numBricksToUpload ); // < because of time limit
     assert( numSlotsOccupied <= myNumBrickBufferSlots); 
     
     //7: update buffer TO TEXTURE 3d COMPUTER SHADER
     {
        //Timer updateBrickBufferTimer; 
        //updateBrickBufferTimer.start();        
        if( numBricksUploaded > 0  )//last frame had requested
        {
            assert(numBricksUploaded <= myNumBrickUploadBufferSlots ); //each frame there is a limit to upload
            
            if(myBrickUpdateBufferGL == 0)           
                vlGLExt::glGenBuffers( 1, &myBrickUpdateBufferGL);      
            vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, myBrickUpdateBufferGL);  
            vlGLExt::glBufferData( GL_SHADER_STORAGE_BUFFER,  numBricksUploaded * brickMemorySize, brickUpdateBuffer, GL_STREAM_DRAW) ; //OR STATIC 
            vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, 0);  
            
            if(myBrickUpdateAddressGL == 0 )
                vlGLExt::glGenBuffers( 1, &myBrickUpdateAddressGL);
            vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, myBrickUpdateAddressGL);  
            vlGLExt::glBufferData( GL_SHADER_STORAGE_BUFFER,  numBricksUploaded * sizeof(uint32_t), brickUpdateAddressBuffer, GL_STREAM_DRAW) ; //OR STATIC 
     
            myUpdateBrickTexturePoolTechnique[myOctreeVol ->getNumVolumes() - 1] -> use(); 
            myUpdateBrickTexturePoolTechnique[myOctreeVol ->getNumVolumes() - 1 ]->setNumUpdateBrick(numBricksUploaded);
            myUpdateBrickTexturePoolTechnique[myOctreeVol ->getNumVolumes() - 1]->setIsIntertwinedBrick(myOctreeVol->isIntertwineMemoryLayout());
            myUpdateBrickTexturePoolTechnique[myOctreeVol ->getNumVolumes() - 1] ->release(); 
            myUpdateBrickTexturePoolTechnique[myOctreeVol ->getNumVolumes() - 1]->bindPipeline(); 
            if(this->myOctreeVol->getNumVolumes() == 1)
                vlGLExt::glBindImageTexture( OCTREEBRICKTEXPOOLIMAGEBINDING_POINT, myBrickVolTextureGL, 0, GL_TRUE, 0, 
                                         GL_READ_WRITE, GL_R16UI); 
            else if(this->myOctreeVol->getNumVolumes() == 2)
                vlGLExt::glBindImageTexture( OCTREEBRICKTEXPOOLIMAGEBINDING_POINT, myBrickVolTextureGL, 0, GL_TRUE, 0, 
                                         GL_READ_WRITE, GL_RG16UI);                 
            else if(this->myOctreeVol->getNumVolumes() == 3)
                vlGLExt::glBindImageTexture( OCTREEBRICKTEXPOOLIMAGEBINDING_POINT, myBrickVolTextureGL, 0, GL_TRUE, 0, 
                                         GL_READ_WRITE, GL_RGBA16UI);  
            else if(this->myOctreeVol->getNumVolumes() == 4)
                vlGLExt::glBindImageTexture( OCTREEBRICKTEXPOOLIMAGEBINDING_POINT, myBrickVolTextureGL, 0, GL_TRUE, 0, 
                                         GL_READ_WRITE, GL_RGBA16UI);  
            vlGLExt::glBindBufferBase(GL_SHADER_STORAGE_BUFFER, UPDATEOCTREEBRICKBUFFERBINDING_POINT, myBrickUpdateBufferGL);
            vlGLExt::glBindBufferBase(GL_SHADER_STORAGE_BUFFER, UPDATEOCTREEBRICKADDRESSBINDING_POINT, myBrickUpdateAddressGL);
            vlGLExt::glBindBufferBase(GL_UNIFORM_BUFFER, OCTREEPARAM, myOctreeParamsUniformBlockBuffer );
        
            //here i hard coded 32 threads number as a general granurity. could be changed , make sure it matched the thread number in
            //updateBrickTexturePool.cs.glsl   
            GLuint threadGroupNumX = (GLuint)(numBricksUploaded * 32);  
            vlGLExt::glDispatchCompute( threadGroupNumX,  1,  1 );           
            vlGLExt::glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);        

            //some reset to make driver happy
            if(this->myOctreeVol->getNumVolumes() == 1)
                vlGLExt::glBindImageTexture( OCTREEBRICKTEXPOOLIMAGEBINDING_POINT, 0, 0, GL_TRUE, 0, 
                                         GL_READ_WRITE, GL_R16UI); 
            else if(this->myOctreeVol->getNumVolumes() == 2)
                vlGLExt::glBindImageTexture( OCTREEBRICKTEXPOOLIMAGEBINDING_POINT, 0, 0, GL_TRUE, 0, 
                                         GL_READ_WRITE, GL_RG16UI);                 
            else if(this->myOctreeVol->getNumVolumes() == 3)
                vlGLExt::glBindImageTexture( OCTREEBRICKTEXPOOLIMAGEBINDING_POINT, 0, 0, GL_TRUE, 0, 
                                         GL_READ_WRITE, GL_RGBA16UI);  
            else if(this->myOctreeVol->getNumVolumes() == 4)
                vlGLExt::glBindImageTexture( OCTREEBRICKTEXPOOLIMAGEBINDING_POINT, 0, 0, GL_TRUE, 0, 
                                         GL_READ_WRITE, GL_RGBA16UI);  
            
            vlGLExt::glBindBufferBase(GL_SHADER_STORAGE_BUFFER, UPDATEOCTREEBRICKBUFFERBINDING_POINT, 0);
            vlGLExt::glBindBufferBase(GL_SHADER_STORAGE_BUFFER, UPDATEOCTREEBRICKADDRESSBINDING_POINT, 0);
            vlGLExt::glBindBufferBase(GL_UNIFORM_BUFFER, OCTREEPARAM, 0 );
            myUpdateBrickTexturePoolTechnique[myOctreeVol ->getNumVolumes() - 1]->unbindPipeline();  
        }   
     }
   
     // update node buffer
     /*PERFORMACE 1 OR 2*/
     //Timer updateOctreeNodeTimer; 
    // updateOctreeNodeTimer.start();     
#ifndef USE_PERSISTENT_NODEBUFFER    
     const size_t nodeCount = myOctreeVol -> getNumNodes(); 
     vlGLExt::glBindBuffer(GL_SHADER_STORAGE_BUFFER, myNodeBufferGL); 
     //orphaning
     vlGLExt::glBufferData( GL_SHADER_STORAGE_BUFFER, sizeof(uint64_t) * nodeCount, NULL, GL_STREAM_DRAW) ; 
     //vlGLExt::glBufferData( GL_SHADER_STORAGE_BUFFER, sizeof(uint64_t) * nodeCount, myNodeBuffer, GL_STREAM_DRAW) ; //OR STATIC   
     
     void* ptr; 
     ptr = vlGLExt::glMapBufferRange(GL_SHADER_STORAGE_BUFFER, 0, sizeof(uint64_t) * numNodes, 
             GL_MAP_WRITE_BIT|GL_MAP_INVALIDATE_BUFFER_BIT /*|GL_MAP_UNSYNCHRONIZED_BIT*/ );
     memcpy( ptr, myNodeBuffer, sizeof(uint64_t) * numNodes);
     vlGLExt::glUnmapBuffer(GL_SHADER_STORAGE_BUFFER);    
     vlGLExt::glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);    
#else
     //global persistent mapped octree node buffer
     //update octree node buffer with least driver overhead
     assert(myPersistentGLNodeBufferPtr);
     const size_t nodeCount = myOctreeVol -> getNumNodes(); 
     const size_t glNodeBufferByteSize = sizeof(uint64_t) * nodeCount; 
     memcpy( (uint64_t*)this ->myPersistentGLNodeBufferPtr, myNodeBuffer, glNodeBufferByteSize); 
#endif     
    
    
     delete[] brickUpdateBuffer; 
     delete[] brickUpdateAddressBuffer; 
     delete[] brickSlotUsed; 
 } 
    
void VolumeRayCasterAlgorithmImp::analyzeOctreeBrickUsageBuffer(size_t& numTraversed, size_t& numUsed, size_t& numRequested) const
{
    assert( this ->myOctreeVol); 
    assert( this ->myBrickUsageBuffer ); 

    const size_t numNodes = this ->myNodeBufferSize ; 

    numTraversed = 0; 
    numUsed = 0; 
    numRequested = 0; 

    for( size_t nodeID = 0; nodeID < numNodes; nodeID++ )
    {
        uint8_t nodeFlag = this ->myBrickUsageBuffer[nodeID]; 
        if( this ->hasOctreeNodeBeenTraversed(nodeFlag) )
            numTraversed++; 
        if( this ->hasOctreeBrickBeenUsed(nodeFlag))
            numUsed++; 
        if( this ->isOctreeBrickRequested(nodeFlag))
            numRequested++; 
    }
}

//each frame before ray casting,  clear usage buffer
void VolumeRayCasterAlgorithmImp::clearOctreeBrickUsageBuffer(size_t numNodes, bool clearTraversed, GLuint currGLSyncIndex)
{  
#ifdef USE_PERSISTENT_NODEBUFFER     
     this ->waitGLBuffer(this ->myGLSyncRange[currGLSyncIndex].sync); 
#endif       
 
     assert( this ->myBrickUsageBuffer && this ->myBrickUsageBufferGL); 
     if( clearTraversed )
     {
         //reset entire buffer
         memset( this ->myBrickUsageBuffer, 0, numNodes); 
     }
     else
     {
         for( size_t i = 0; i < numNodes; i++ )
             myBrickUsageBuffer[i] &= ~(MASK_BRICK_INUSE|MASK_BRICK_REQUESTED); 
     }
     //
     //vlGLExt::glBindBuffer(GL_SHADER_STORAGE_BUFFER, myBrickUsageBufferGL);  
#ifndef USE_PERSISTENT_NODEBUFFER
     //orphanning
    //vlGLExt::glBufferData( GL_SHADER_STORAGE_BUFFER, sizeof(uint8_t) * numNodes, NULL, GL_DYNAMIC_DRAW) ; //OR STATIC  
    void* ptr; 
    ptr = vlGLExt::glMapBufferRange(GL_SHADER_STORAGE_BUFFER, 0, sizeof(uint8_t) * numNodes, 
             GL_MAP_WRITE_BIT|GL_MAP_INVALIDATE_BUFFER_BIT/*|GL_MAP_UNSYNCHRONIZED_BIT*/  );
    memcpy( ptr, myBrickUsageBuffer, sizeof(uint8_t) * numNodes); 
    vlGLExt::glUnmapBuffer(GL_SHADER_STORAGE_BUFFER); 
#else     
    //keep in mind usage buffer is a triple-sized buffer, for performance purpose. 
    size_t offset = this ->myGLSyncRange[currGLSyncIndex].begin; 
    memcpy( (uint8_t*)this ->myPersistentBufferUsageMapPtr + offset  , myBrickUsageBuffer, sizeof(uint8_t) * numNodes); 
#endif    
}
  
void VolumeRayCasterAlgorithmImp::clearVoxelPickBuffer()
{
#ifdef USE_PERSISTENT_NODEBUFFER
    assert(myPersistentPickVoxelBufferPtr); 
#endif
    
    assert( myVoxelPickGL); 
    memset( myVoxelPickBuffer, 0, sizeof(VoxelInfo)); 
    memcpy( myPersistentPickVoxelBufferPtr , myVoxelPickBuffer, sizeof(VoxelInfo) );  
}

void VolumeRayCasterAlgorithmImp::renderFrameFS( 
                        const int screenResolutionReduction,  // rendertarget (framebufferobject )resolution
                        size_t nodeLevel, // any nodel level of detail applied
                        float sampleingStepSize, // 1/sampling rate
                        bool isLinearFilter, // use trilinear filtering
                        bool isAdaptiveSampling, // use brick size adaptive sampling
                        bool isCubicSpline, // use cupic interpolation
                        bool isHardwareSampling, // use hardware
                        bool isUseLighting, // use lighting
                        bool isUseJittering, // use jittering
                        int gradientQuality, // which gradient quality
                        DisplayMode displayMode, // full frame / refine frame: full frame means final result to screen, refine frame: intermediate result 
                        bool useBricks, 
                        GLuint currGLSyncIndex)
 {
     
    checkError("before renderFrameFS"); 
     
    assert( this ->myNodeBufferGL && this ->myBrickVolTextureGL&& myBrickUsageBufferGL );

    const uint32_t coarsnessFactor = (uint32_t)pow((double)2.f, (double)screenResolutionReduction); 
     
     assert( this ->myRayBufferGL[screenResolutionReduction]  ); 
     
     Vect2i internalRenderSize( myWidth/coarsnessFactor, myHeight/coarsnessFactor ); 
     
     int numVolumes = myOctreeVol -> getNumVolumes(); 
     
     {
        vlOctreeRayCasterDVRFragTechnique* currentActiveTech; 

        switch( myVolRenderConfig->getVolumeRenderingTech() )
        {
            case (int)DVR_MODE:
                currentActiveTech = myOctreeRayCasterDVRFragTechnique[numVolumes - 1][gradientQuality]; 
                break; 
            case (int)GRAD_MODE:
                currentActiveTech = myOctreeRayCasterGradFragTechnique[numVolumes - 1][gradientQuality];
                break; 
            case (int)MIP_MODE:
                currentActiveTech = myOctreeRayCasterMipFragTechnique[numVolumes - 1]; 
                break; 
            case (int)MOP_MODE:
                currentActiveTech = myOctreeRayCasterMopFragTechnique[numVolumes - 1]; 
                break;         
            case (int)ISO_MODE:
                currentActiveTech = myOctreeRayCasterIsosurfaceFragTechnique[numVolumes - 1][gradientQuality]; 
                break; 
            case (int)MININTPROJ_MODE:
                currentActiveTech = myOctreeRayCasterMinIntProjFragTechnique[numVolumes - 1]; 
                break ; 
            case (int)AVGPROJ_MODE: 
                currentActiveTech = myOctreeRayCasterAipFragTechnique[numVolumes - 1]; 
                break; 
            case (int)SUMPROJ_MODE: 
                currentActiveTech = myOctreeRayCasterSipFragTechnique[numVolumes - 1]; 
                break;     
            case (int)RGBA_MODE:
                currentActiveTech = myOctreeRayCasterDVRRGBAFragTechnique[numVolumes - 1][gradientQuality]; 
                break; 
        }   
 
     
        {
            //setting shader uniform . 
           currentActiveTech->use();           
           {
               //raycaster config
               myRayCasterConfig.isRefineFrame = (displayMode == REFINEMENT);
               myRayCasterConfig.isFirstRefinementFrame = (myRenderState == RENDER_STATE_FIRST_ITERATIVE_FRAME );
               myRayCasterConfig.isTextureLinearFiltering = isLinearFilter;
               myRayCasterConfig.isUseBrick = useBricks ;
               myRayCasterConfig.isUseAncestorNode = (displayMode == FULL_FRAME); 
               myRayCasterConfig.isUseAdaptiveSampling = isAdaptiveSampling; 
               myRayCasterConfig.coarsnessFactor = coarsnessFactor; 
               myRayCasterConfig.nodeLevelOfDetail = (uint)nodeLevel; 
               myRayCasterConfig.samplingStepSize = sampleingStepSize;    
               myRayCasterConfig.isUsingCubicSpline = isCubicSpline; 
               myRayCasterConfig.isUsingHardware = isHardwareSampling; 
               currentActiveTech ->setRayCasterConfigUniform(myRayCasterConfig);                      
           }

           {
               //visual config
               Vect3i volDim = this ->myOctreeVol->getVolumeDimension();  
               myVisualConfig.volDataTFRangeSeismic = Vect4f(myDataRangeSeismic[0], myDataRangeSeismic[1], myTfRangeSeismic[0], myTfRangeSeismic[1]);
               myVisualConfig.volDataTFRangeAttribute = Vect4f(myDataRangeAttribute[0], myDataRangeAttribute[1], myTfRangeAttribute[0], myTfRangeAttribute[1]);
               myVisualConfig.viewportSize = Vect2i(internalRenderSize[0], internalRenderSize[1]);
               myVisualConfig.volumeDimensions = Vect4i(volDim[0], volDim[1], volDim[2], 1); 
               myVisualConfig.referenceOrigin = myGeomOrigin;   
               myVisualConfig.referenceNum  = myGeomSize; 
               myVisualConfig.referenceStep = myGeomStep; 
               myVisualConfig.volOrigin = myActiveVolumeOrigin; 
               myVisualConfig.volNum = myActiveVolumeSize; 
               myVisualConfig.volStep = myActiveVolumeStep; 
               currentActiveTech ->setVisualConfig(myVisualConfig);
           }

           {
                if( myVolRenderConfig->isHorizonClip())
                {
                   Vect3f hrzGeomLower(0.0f);
                   Vect3f hrzGeomUpper(0.0f);
                   Vect3f refGeomLower(0.0f);
                   Vect3f refGeomUpper(0.0f);
                   Vect3f volGeomLower(0.0f);
                   Vect3f volGeomUpper(0.0f);
                   Vect3f ext;
                   int hid = 0; 
                   ext[0] = myHrzStep[hid][0] * (myHrzSize[hid][0]-1);
                   ext[1] = myHrzStep[hid][1] * (myHrzSize[hid][1]-1);
                   ext[2] = myHrzStep[hid][2] * (myHrzSize[hid][2]-1);
                   Vect3f c1 = myHrzOrigin[hid] + ext;
                   hrzGeomLower = Vect3f( std::min(myHrzOrigin[hid][0],c1[0]), 
                           std::min(myHrzOrigin[hid][1],c1[1]), 
                           std::min(myHrzOrigin[hid][2],c1[2]) );

                   hrzGeomUpper = Vect3f( std::max(myHrzOrigin[hid][0],c1[0]), 
                           std::max(myHrzOrigin[hid][1],c1[1]), 
                           std::max(myHrzOrigin[hid][2],c1[2]) );

                   ext[0] = myGeomStep[0] * (myGeomSize[0]-1);
                   ext[1] = myGeomStep[1] * (myGeomSize[1]-1);
                   ext[2] = myGeomStep[2] * (myGeomSize[2]-1);
                   c1 = myGeomOrigin + ext;                    
                   refGeomLower = Vect3f( std::min(myGeomOrigin[0],c1[0]), 
                           std::min(myGeomOrigin[1],c1[1]), 
                           std::min(myGeomOrigin[2],c1[2]) );

                   refGeomUpper = Vect3f( std::max(myGeomOrigin[0],c1[0]), 
                           std::max(myGeomOrigin[1],c1[1]), 
                           std::max(myGeomOrigin[2],c1[2]) );

                   ext[0] = myActiveVolumeStep[0] * (myActiveVolumeSize[0]-1);
                   ext[1] = myActiveVolumeStep[1] * (myActiveVolumeSize[1]-1);
                   ext[2] = myActiveVolumeStep[2] * (myActiveVolumeSize[2]-1);
                   c1 = myActiveVolumeOrigin + ext;                    
                   volGeomLower = Vect3f( std::min(myActiveVolumeOrigin[0],c1[0]), 
                           std::min(myActiveVolumeOrigin[1],c1[1]), 
                           std::min(myActiveVolumeOrigin[2],c1[2]) );
                   volGeomUpper = Vect3f( std::max(myActiveVolumeOrigin[0],c1[0]), 
                           std::max(myActiveVolumeOrigin[1],c1[1]), 
                           std::max(myActiveVolumeOrigin[2],c1[2]) );

                   myHrzClipConfig.hrzGeomLower = hrzGeomLower; 
                   myHrzClipConfig.hrzGeomUpper = hrzGeomUpper; 
                   myHrzClipConfig.refGeomLower = refGeomLower; 
                   myHrzClipConfig.refGeomUpper = refGeomUpper; 
                   myHrzClipConfig.volGeomLower = volGeomLower;
                   myHrzClipConfig.volGeomUpper = volGeomUpper;
                   myHrzClipConfig.clipAbove = myVolRenderConfig->isHrzClipAbove(hid); 
                   myHrzClipConfig.isActive = myVolRenderConfig->isHrzClipActive(hid); 
                   currentActiveTech ->setHrzClipConfig(hid, myHrzClipConfig);

                   //bottom horizon
                   hid = 1; 
                   ext[0] = myHrzStep[hid][0] * (myHrzSize[hid][0]-1);
                   ext[1] = myHrzStep[hid][1] * (myHrzSize[hid][1]-1);
                   ext[2] = myHrzStep[hid][2] * (myHrzSize[hid][2]-1);
                   c1 = myHrzOrigin[hid] + ext;
                   hrzGeomLower = Vect3f( std::min(myHrzOrigin[hid][0],c1[0]), 
                           std::min(myHrzOrigin[hid][1],c1[1]), 
                           std::min(myHrzOrigin[hid][2],c1[2]) );

                   hrzGeomUpper = Vect3f( std::max(myHrzOrigin[hid][0],c1[0]), 
                           std::max(myHrzOrigin[hid][1],c1[1]), 
                           std::max(myHrzOrigin[hid][2],c1[2]) );
                   myHrzClipConfig.hrzGeomLower = hrzGeomLower; 
                   myHrzClipConfig.hrzGeomUpper = hrzGeomUpper; 
                   myHrzClipConfig.clipAbove = myVolRenderConfig->isHrzClipAbove(hid); 
                   myHrzClipConfig.isActive = myVolRenderConfig->isHrzClipActive(hid); 
                   currentActiveTech ->setHrzClipConfig(hid, myHrzClipConfig);
                }    

                {
                   myRoiClipConfig.bbmin = this->m_bbMin; 
                   myRoiClipConfig.bbmax = this->m_bbMax; 
                   myRoiClipConfig.isExclusive = myVolRenderConfig->isRenderROIExclusive();
                   myRoiClipConfig.isUseRoiClipping = myVolRenderConfig->isRenderROIOnly(); 
                   currentActiveTech ->setRoiClipConfig(myRoiClipConfig);
                }    
           }

            {
               //voxel pick cfg
               Vect3i mouseLoc = myVolRenderConfig->getLastVoxelPickLoc(); 
               myVoxelPickConfig.voxelPickMouseLoc = mouseLoc; 
               currentActiveTech ->setVoxelPickConfig(myVoxelPickConfig); 
            }

            {
               //isovalue cfg
               myIsosurfaceConfig.isoValueMultiFloat = myVolRenderConfig->getIsoValue(); 
               myIsosurfaceConfig.isoValueNum = myVolRenderConfig->getIsoValueNum(); 
               myIsosurfaceConfig.useIsoTransparency = myVolRenderConfig->isUseIsoTransparency();
               currentActiveTech -> setIsoSurfaceConfig(myIsosurfaceConfig); 
            }

            {
               //shading cfg
               myShadingConfig.eyePosition = myCameraEyePosition; 
               myShadingConfig.lightPosition = myLightPosition;
               //myVolumeRenderingQuality.getLightSourcePosition(); 
               float ka, ks, kd; 
               myVolumeRenderingQuality.getPhongShadingK(ka, kd, ks); 

               myShadingConfig.light.Ka = ka * myVolumeRenderingQuality.getAmbientCoeff(); 
               myShadingConfig.light.Ks = ks * myVolumeRenderingQuality.getSpecularCoeff(); 
               myShadingConfig.light.Kd = kd * myVolumeRenderingQuality.getDiffuseCoeff(); 
               myShadingConfig.light.shiness = myVolumeRenderingQuality.getShiness(); 

               myShadingConfig.light.diffuseColor = myVolumeRenderingQuality.getLightDiffuseColor(); 
               myShadingConfig.light.specularColor = myVolumeRenderingQuality.getLightSpecularColor();
               myShadingConfig.light.ambientColor = myVolumeRenderingQuality.getLightAmbientColor();

               currentActiveTech ->setShadingConfig(myShadingConfig);
           }

           {
               //state cfg
               myStateConfig.useVoxelPick = myVolRenderConfig->isVoxelPickEnabled(); 
               myStateConfig.useHrzClip = myVolRenderConfig->isHorizonClip(); 
               myStateConfig.useLighting = isUseLighting;
               myStateConfig.useOpacityCorrection = myVolRenderConfig->isUseOpacityCorrection();
               myStateConfig.useJittering = isUseJittering; 
               myStateConfig.gradientQuality = gradientQuality;
               myStateConfig.gradientThreshold = myVolumeRenderingQuality.getGradientThreshold();
               myStateConfig.surfaceScalarExp = myVolumeRenderingQuality.getSurfaceScalarExp();
               myStateConfig.gradientScalarExp = myVolumeRenderingQuality.getUnormGradientExp(); 
               myStateConfig.usePostClassification  = myVolRenderConfig->isUsePostClassification(); 
               myStateConfig.visBoundary = myVolRenderConfig->isVisBoundary(); 
               myStateConfig.useBoundaryOpacity = myVolumeRenderingQuality.isUseBoundaryOpacity(); 
               myStateConfig.boundaryOpacityThreshold = myVolumeRenderingQuality.getBoundaryOpacityThreshold(); 
               myStateConfig.boundaryOpacityIntensity = myVolumeRenderingQuality.getBoundaryOpacityIntensity(); 
               myStateConfig.useEdgeColoring = myVolumeRenderingQuality.isUseEdgeColoring(); 
               myStateConfig.edgeColor = myVolumeRenderingQuality.getEdgeColor(); 
               myStateConfig.edgeThreshold = myVolumeRenderingQuality.getEdgeThreshold(); 
               myStateConfig.colorBlendFactor = myVolumeRenderingQuality.getColorBlendingFactor(); 
               myStateConfig.colorBlendSpace = myVolumeRenderingQuality.getColorBlendingSpace(); 
               currentActiveTech ->setStateConfig(myStateConfig); 
           }

           {
               //gain control cfg
               myGainControlConfig.gainType = this->mySeisGainType;    
               myGainControlConfig.linearDivergenceGainParameter = myLinearDivergenceParams;
               myGainControlConfig.sRate = mySrate;
               myGainControlConfig.depthExtent = myDepthExtent;
               currentActiveTech ->setGainControlConfig(myGainControlConfig);
           }            

   #ifdef USE_PERSISTENT_NODEBUFFER
            // critical, triple sized usage buffer. a uniform tells which part is used in shader
               currentActiveTech ->setUsageBufferOffset(this ->myCurrentGLSyncRangeIndex * this ->myOctreeVol->getNumNodes());        
   #else
               currentActiveTech ->setUsageBufferOffset((uint)0);
   #endif                
           }
            // seismic rendering only, attribute rendering only, corender, no volume rendering
           currentActiveTech ->setVolumeRenderMode( (uint)myVolRenderConfig->getMultipleVolumeRenderingMode());
           currentActiveTech ->setMVPMatrix((float*)&myMVPMatrix.mat);
           
           //texture unit: each hardware has fixed number of texture unit. 8 ,16, 32, etc. Need query to know. 
           // Texture Unit 0: reserved for large brick pool texture. (Texture3D )
           // Texture Unit 1: Entry Exit Texture Array (TextureArray2D)
           // Texture Unit 2: Jittering Texture (Texture2D)
           // Texture Unit 3: Top Salt Texture for horizon clipping (Texture2D)
           // Texture Unit 4: TransferFunction Texture for horizon clipping (Texture1DArray)
           // Texutre Unit 5: Bottom Salt Texture for horizon clipping (Texture2D)     
           
           //1. set the uniform. 
           //2. active texture unit and bind. 
           //warning: make them match: 1 --- GL_TEXTURE1, etc. 
           currentActiveTech ->setEntryExitTextureArrayUnit(1);
           currentActiveTech ->setJitteringTexture2DUnit(2);
           currentActiveTech ->setHorizonClipTexture2DUnit(0, 3); 
           currentActiveTech ->setHorizonClipTexture2DUnit(1, 5); 
           currentActiveTech ->setTransferFunctionTextureArrayUnit(4); 
           currentActiveTech-> setOctreeBrickTexture3DUnit(0); 
           currentActiveTech->release(); 
           currentActiveTech->bindPipeline(); 

            glActiveTexture(GL_TEXTURE1); 
            glBindTexture(GL_TEXTURE_2D_ARRAY, myEntryExitBound.textureArray);
            glActiveTexture(GL_TEXTURE0); 
            glBindTexture(GL_TEXTURE_3D, myBrickVolTextureGL);
            vlGLExt::glBindSampler(0, isLinearFilter? this->myLinearSampler : this->myNearestSampler); 
            glActiveTexture(GL_TEXTURE4); 
            glBindTexture(GL_TEXTURE_1D_ARRAY, getTransferFunctionTextureArray());
            glActiveTexture(GL_TEXTURE2); 
            glBindTexture(GL_TEXTURE_2D, myJitteringTexture);     
            glActiveTexture(GL_TEXTURE3); 
            glBindTexture(GL_TEXTURE_2D, myClippingHrzTex2D[0]); 
            glActiveTexture(GL_TEXTURE5); 
            glBindTexture(GL_TEXTURE_2D, myClippingHrzTex2D[1]); 

            //bind buffer: binding point needs to match shader's 
            vlGLExt::glBindBufferBase(GL_SHADER_STORAGE_BUFFER, RAYBUFFERBINDING_POINT, myRayBufferGL[screenResolutionReduction]);
            vlGLExt::glBindBufferBase(GL_SHADER_STORAGE_BUFFER, OCTREENODEBUFFERBINDING_POINT, myNodeBufferGL);
            vlGLExt::glBindBufferBase(GL_SHADER_STORAGE_BUFFER, OCTREEBRICKUSAGEBUFFERBINDING_POINT, myBrickUsageBufferGL);
            vlGLExt::glBindBufferBase(GL_SHADER_STORAGE_BUFFER, VOXELPICKBUFFERBINDING_POINT, myVoxelPickGL);

            vlGLExt::glBindBufferBase(GL_UNIFORM_BUFFER, OCTREEPARAM, myOctreeParamsUniformBlockBuffer );
            vlGLExt::glBindBufferBase(GL_UNIFORM_BUFFER, MASKPARAM, myMaskParamsUniformBlockBuffer );
            vlGLExt::glBindBufferBase(GL_UNIFORM_BUFFER, BUFFERUSAGEPARAM, myBufferUsageUniformBlockBuffer );

            //MRT: MultiRenderTarget, Match shaders. Layer0: color, Layer1: depth
            vlGLExt::glBindFramebufferEXT( GL_FRAMEBUFFER, myIntermiateFBO[screenResolutionReduction] ); 
            GLenum DrawBuffers[2]; 
            DrawBuffers[0] = GL_COLOR_ATTACHMENT0; 
            DrawBuffers[1] = GL_COLOR_ATTACHMENT1; 
            vlGLExt::glDrawBuffers(2, DrawBuffers);

            //full screen quad
            glDisable( GL_DEPTH_TEST);
            glDisable(GL_CULL_FACE);
            vlGLExt::glBindVertexArray(0); 
            glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

            //Reset
            glActiveTexture(GL_TEXTURE1); 
            glBindTexture(GL_TEXTURE_2D_ARRAY, 0);         
            glActiveTexture(GL_TEXTURE4); 
            glBindTexture(GL_TEXTURE_1D_ARRAY, 0);
            glActiveTexture(GL_TEXTURE2); 
            glBindTexture(GL_TEXTURE_2D, 0);  
            glActiveTexture(GL_TEXTURE3); 
            glBindTexture(GL_TEXTURE_2D, 0);   
            glActiveTexture(GL_TEXTURE5); 
            glBindTexture(GL_TEXTURE_2D, 0); 
            //make sure end with GL_TEXTURE0, tornado legacy code needs it. 
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_3D, 0);
            currentActiveTech->unbindPipeline(); 

            vlGLExt::glBindFramebufferEXT( GL_FRAMEBUFFER,0 ); 
            checkError("after renderFrameFS"); 
     }
 }
 
 void VolumeRayCasterAlgorithmImp::rescaleRenderingFS()
{
     //upsampling the ray-castered framebuffer to screen resolution. 
    const uint32_t reduction = this ->myVolRenderConfig->getScreenResolutionReduction();   
    vlGLExt::glBindFramebufferEXT( GL_FRAMEBUFFER, 0 );     
    
    myFullScreenCopyBasicTechnique ->use(); 
    myFullScreenCopyBasicTechnique->setGMVPMatrix((float*)&myMVPMatrix.mat);
    myFullScreenCopyBasicTechnique->setUseAO(myVolumeRenderingQuality.isUseAmbientOcclusion()); 
    myFullScreenCopyBasicTechnique->release();
       
    myFullScreenCopyBasicTechnique->bindPipeline(); 
    glActiveTexture(GL_TEXTURE0); 
#ifdef USETEXTURE2DARRAY
    glBindTexture(GL_TEXTURE_2D_ARRAY, myRayCasterColorDepthTextureArray); 
#else
    glBindTexture(GL_TEXTURE_2D_ARRAY, myRayCasterColorDepthTextureArray[reduction]); 
#endif 
    glActiveTexture(GL_TEXTURE4); 
    glBindTexture(GL_TEXTURE_2D, this->myUseAOBlurPass? this->mySSAOBlurredTexture[reduction] : mySSAOTexture[reduction]);          
    vlGLExt::glBindVertexArray(0); 
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    glActiveTexture(GL_TEXTURE0); 
    glBindTexture(GL_TEXTURE_2D_ARRAY, 0); 
    glActiveTexture(GL_TEXTURE4); 
    glBindTexture(GL_TEXTURE_2D, 0); 
    myFullScreenCopyBasicTechnique->unbindPipeline(); 
    glActiveTexture(GL_TEXTURE0); 
}
 
bool VolumeRayCasterAlgorithmImp::isEarlyDiscardFromRenderingLoop( )
{
    if(this ->myOctreeVol == NULL)
        return true; 
    
    if( ( myOctreeVol -> getSVOBuildMode() == (size_t)OctreeUtils::VOLUMERENDER_SEIS || 
          myOctreeVol -> getSVOBuildMode() == (size_t)OctreeUtils::VOLUMERENDER_ATTR )
            && (size_t)myVolRenderConfig->getMultipleVolumeRenderingMode()  != myOctreeVol -> getSVOBuildMode() )
    {
        return true; 
    }
    
    if(myOctreeVol -> getSVOBuildMode() == (size_t)OctreeUtils::VOLUMERENDER_UNKNOWN || 
            (size_t)myVolRenderConfig->getMultipleVolumeRenderingMode() == VOLUMERENDER_NORENDER  )
        return true; 
    
    return false; 
}

void VolumeRayCasterAlgorithmImp::invalidateNodeBuffer()
 {
    if(myNodeBufferGL!=0)
    {
        checkError("before delete node buffer"); 
        GLint isMapped; 
        vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, myNodeBufferGL);
        vlGLExt::glGetBufferParameteriv(GL_SHADER_STORAGE_BUFFER, GL_BUFFER_MAPPED, &isMapped); 
        if(isMapped == GL_TRUE)
            vlGLExt::glUnmapBuffer( GL_SHADER_STORAGE_BUFFER );
        vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, 0);
      
        vlGLExt::glDeleteBuffers(1, &myNodeBufferGL); 
        myNodeBufferGL = 0; 
        checkError("after delete node buffer"); 
    }
    
    this ->myNodeBufferInvalid = true; 
    //uncommented this to see if has problem.Need test
    glFinish(); 
 }
 
void VolumeRayCasterAlgorithmImp::invalidateStreamSliceTexture()
{


}

 void VolumeRayCasterAlgorithmImp::invalidateBrickBuffer()
 {
    if(myBrickUsageBufferGL != 0 )
    {    
        checkError("before glDeleteBuffers usage buffer"); 
        GLint isMapped; 
        vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, myBrickUsageBufferGL); 
        vlGLExt::glGetBufferParameteriv(GL_SHADER_STORAGE_BUFFER, GL_BUFFER_MAPPED, &isMapped); 
        if(isMapped == GL_TRUE)
            vlGLExt::glUnmapBuffer( GL_SHADER_STORAGE_BUFFER );
        vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, 0);
        vlGLExt::glDeleteBuffers(1, &myBrickUsageBufferGL); 
        myBrickUsageBufferGL = 0; 
        checkError("after glDeleteBuffers usage buffer"); 
    }
    if(myBrickVolTextureGL)
       vlGLExt::glDeleteTextures(1, &myBrickVolTextureGL); 
    myBrickVolTextureGL = 0; 
    this ->myBrickBufferInvalid = true; 
    
    clearIntermiateTexture();
    //uncommented this to see if has problem.Need test
    glFinish(); 
 }
 
 void VolumeRayCasterAlgorithmImp::invalidateVoxelPickBuffer()
 {
    if(myVoxelPickGL != 0 )
    {
        GLint isMapped; 
        vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, myVoxelPickGL); 
        vlGLExt::glGetBufferParameteriv(GL_SHADER_STORAGE_BUFFER, GL_BUFFER_MAPPED, &isMapped); 
        if(isMapped == GL_TRUE)
            vlGLExt::glUnmapBuffer( GL_SHADER_STORAGE_BUFFER );
        vlGLExt::glBindBuffer( GL_SHADER_STORAGE_BUFFER, 0);
        vlGLExt::glDeleteBuffers(1, &myVoxelPickGL); 
        myVoxelPickGL = 0; 
    }
    myVoxelPickInvalid = true; 
 }
 
 void VolumeRayCasterAlgorithmImp::invalidateExtraVolTransferFunction()
 {
     this ->myExtraVolumeTransferFunctionDirty = true; 
 }
 
 void VolumeRayCasterAlgorithmImp::resetRenderState()
 {
     //reset Render state means all intermediate Texture become obsolete, clean it 
    this ->myRenderState = (this ->myVolRenderConfig->getInteractiveMode() != QUALITY ? RENDER_STATE_FIRST_INTERACTION_FRAME: RENDER_STATE_FIRST_FULL_FRAME); 
    clearIntermiateTexture();
 }
 
 void VolumeRayCasterAlgorithmImp::clearIntermiateTexture()
 {
    vlGLExt::glClearTexSubImage(myEntryExitBound.textureArray, 0, 0, 0, 0, myWidth, myHeight, 2,  GL_RGBA, GL_FLOAT, &Vect4f(0.0f)[0] ); 
    for(size_t level = 0; level < MAX_MIPMAP_LEVELS; level++ )
    {
         vlGLExt::glBindFramebufferEXT(GL_FRAMEBUFFER, myIntermiateFBO[level]);  
         glClear (GL_COLOR_BUFFER_BIT| GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);   
    }
    vlGLExt::glBindFramebufferEXT(GL_FRAMEBUFFER, 0);   
    // commented to do a test
    glFinish();  
 }
 
 void VolumeRayCasterAlgorithmImp::compareOctreeNodeToBuffer( const vlSparseVolumeOctreeNode* node, size_t nodeOffset )
 {
     assert( node ); 
     assert( this ->myNodeBuffer ); 
     
     if( nodeOffset > this ->myNodeBufferSize )
     {
         fprintf(stderr, "Invalid octree node offset\n"); 
         assert(false); 
     }
     
     bool inPool, homogeneous; 
     size_t childPointer, brickPointer; 
     uint16_t avgValue; 
     this ->extractOctreeNodeValues( this->myNodeBuffer[nodeOffset], inPool, homogeneous, childPointer, avgValue, brickPointer ); 
        
          
     if( homogeneous == (node ->hasBrick() )) 
         assert(false); 
     uint16_t avgExpected = node ->getAvgVoxelIntensity() >> (16-getAvgMask(0,1).NUMBITS);
     if( avgValue!= avgExpected)
         assert(false); 
     //if( brickPointer != 0 )
     //    assert(false); 
     
     if( childPointer == 0 && node ->m_children[0]!= 0)
         assert(false); 
     else if( childPointer != 0 && node ->m_children[0]== 0)
         assert(false); 
     else if( node ->m_children[0]!= 0 )
     {
         assert( childPointer ); 
         for( int childID = 0; childID < 8; childID++ )
         {
             const vlSparseVolumeOctreeNode* childNode = node ->m_children[childID]; 
             assert( childNode ); 
             size_t childOffset = childPointer + childID; //store consecutively
             this ->compareOctreeNodeToBuffer(childNode, childOffset );   
         }
     }
 }
 
 bool VolumeRayCasterAlgorithmImp::hasOctreeNodeBrick( uint64_t& nodeEntry) const
 {
     return (nodeEntry & MASK_INBRICKPOOL) > 0; 
 }
 
 bool VolumeRayCasterAlgorithmImp::hasOctreeBrickBeenUsed( const uint8_t flagEntry ) const
 {
     return ( ( flagEntry & MASK_BRICK_INUSE ) > 0 ); 
 }
 
 uint8_t VolumeRayCasterAlgorithmImp::setOctreeBrickUsed( const uint8_t flagEntry, const bool used )
 {
     return ( flagEntry & ~MASK_BRICK_INUSE | (used ? MASK_BRICK_INUSE : 0 ));
 }
 
 bool VolumeRayCasterAlgorithmImp::hasOctreeNodeBeenTraversed(const uint8_t flagEntry) const
 {
     return ( ( flagEntry & MASK_NODE_TRAVERSED ) > 0 );  
 }
 
 uint8_t VolumeRayCasterAlgorithmImp::setOctreeNodeTraversed(const uint8_t flagEntry, const bool traversed)
 {
     return ( flagEntry & ~MASK_NODE_TRAVERSED | (traversed ? MASK_NODE_TRAVERSED : 0 ));
 }
 
 bool VolumeRayCasterAlgorithmImp::isOctreeBrickRequested(const uint8_t flagEntry) const
 {
     return ( ( flagEntry & MASK_BRICK_REQUESTED ) > 0  ); 
 }
 
 uint8_t VolumeRayCasterAlgorithmImp::setOctreeBrickRequested(const uint8_t flagEntry, const bool requested)
 {
     return ( flagEntry & ~MASK_BRICK_REQUESTED | (requested ? MASK_BRICK_REQUESTED : 0 ));
 }//1
 
 bool VolumeRayCasterAlgorithmImp::isOctreeNodeHomogeneous(const uint64_t& nodeEntry) const
 {
     return (nodeEntry & MASK_HOMOGENEOUS) > 0; 
 }

 void VolumeRayCasterAlgorithmImp::lockGLBuffer(GLsync& syncObj)
 {
     if(syncObj)
         vlGLExt::glDeleteSync(syncObj); 
     
     syncObj = vlGLExt::glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0); 
 }
 
 bool VolumeRayCasterAlgorithmImp::waitGLBuffer(GLsync& syncObj)
 {
     if(syncObj)
     {
         while(1)
         {
             GLenum waitReturn = vlGLExt::glClientWaitSync(syncObj, GL_SYNC_FLUSH_COMMANDS_BIT, 1); 
             if(waitReturn == GL_ALREADY_SIGNALED || waitReturn == GL_CONDITION_SATISFIED )
                 return  true;        
             
             myGLSyncWaitTime++; 
         }
     }
     else
     {
         return false; 
     }
 }
